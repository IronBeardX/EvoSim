Created by PLY (http://www.dabeaz.com/ply)

Unused terminals:

    newline

Grammar

Rule 0     S' -> test
Rule 1     program -> gene_stmt_list dna_stmt_list behavior_stmt_list entity_org_stmt_list world_stmt sim_stmt
Rule 2     epsilon -> <empty>
Rule 3     test -> program
Rule 4     gene_stmt_list -> gene_stmt gene_stmt_list
Rule 5     gene_stmt_list -> epsilon
Rule 6     gene_stmt -> GENE phygene_stmt
Rule 7     gene_stmt -> GENE percpgene
Rule 8     gene_stmt -> GENE actgene_stmt
Rule 9     percpgene -> SMELLING
Rule 10    percpgene -> VISION
Rule 11    actgene_stmt -> actgene ID { COST NUMBER }
Rule 12    actgene -> MOVE
Rule 13    actgene -> EAT
Rule 14    actgene -> REPRODUCE
Rule 15    actgene -> ATTACK
Rule 16    actgene -> DEFEND
Rule 17    actgene -> PICK
Rule 18    actgene -> SWIM
Rule 19    phygene_stmt -> phygene ID { phygeneprop phygeneprop }
Rule 20    phygene -> HEALTH
Rule 21    phygene -> HUNGER
Rule 22    phygene -> LEGS
Rule 23    phygene -> EYES
Rule 24    phygene -> ARMS
Rule 25    phygene -> HORNS
Rule 26    phygene -> SMELL
Rule 27    phygene -> FINS
Rule 28    phygene -> NOSE
Rule 29    phygene -> MOUTH
Rule 30    phygeneprop -> VALUE NUMBER IN { NUMBER NUMBER }
Rule 31    phygeneprop -> MUTATION { mutationprop mutationprop }
Rule 32    mutationprop -> CHANCE NUMBER
Rule 33    mutationprop -> STEP NUMBER
Rule 34    dna_stmt_list -> dna_stmt dna_stmt_list
Rule 35    dna_stmt_list -> epsilon
Rule 36    dna_stmt -> DNA ID { dna_elem_list }
Rule 37    dna_elem_list -> dna_elem dna_elem_list
Rule 38    dna_elem_list -> epsilon
Rule 39    dna_elem -> ID
Rule 40    dna_elem -> SMELLING
Rule 41    dna_elem -> VISION
Rule 42    dna_elem -> DNA ID
Rule 43    behavior_stmt_list -> behavior_stmt behavior_stmt_list
Rule 44    behavior_stmt_list -> epsilon
Rule 45    behavior_stmt -> BEHAVIOR ID { func_stmt_list decide_stmt }
Rule 46    behavior_stmt -> BEHAVIOR ID
Rule 47    decide_stmt -> DECIDE ORGANISM TIME { stmt_list }
Rule 48    entity_org_stmt_list -> entity_stmt entity_org_stmt_list
Rule 49    entity_org_stmt_list -> organism_stmt entity_org_stmt_list
Rule 50    entity_org_stmt_list -> epsilon
Rule 51    entity_stmt -> ENTITY { entityprop entityprop entityprop }
Rule 52    entityprop -> COEXISTENCE bool
Rule 53    entityprop -> REPR ID
Rule 54    entityprop -> AT { position position_list }
Rule 55    organism_stmt -> ORGANISM { orgprop orgprop orgprop orgprop }
Rule 56    orgprop -> DNA ID
Rule 57    orgprop -> BEHAVIOR ID
Rule 58    orgprop -> REPR ID
Rule 59    orgprop -> AT { position position_list }
Rule 60    position_list -> position position_list
Rule 61    position_list -> epsilon
Rule 62    position -> ( NUMBER NUMBER )
Rule 63    world_stmt -> WORLD { worldprop worldprop }
Rule 64    worldprop -> SIZE worldsize
Rule 65    worldprop -> TERRAIN worldterrain
Rule 66    worldsize -> INFINITE { worldsizeprop worldsizeprop }
Rule 67    worldsize -> { worldsizeprop worldsizeprop }
Rule 68    worldsizeprop -> WIDTH NUMBER
Rule 69    worldsizeprop -> HEIGHT NUMBER
Rule 70    worldterrain -> { terrainprop_list }
Rule 71    terrainprop_list -> terrainprop terrainprop_list
Rule 72    terrainprop_list -> epsilon
Rule 73    terrainprop -> ID
Rule 74    terrainprop -> DEFAULT ID
Rule 75    terrainprop -> ID AT { NUMBER terrainposn_list }
Rule 76    terrainposn_list -> NUMBER terrainposn_list
Rule 77    terrainposn_list -> epsilon
Rule 78    sim_stmt -> SIMULATION { simprop simprop simprop simprop simprop }
Rule 79    simprop -> EPISODES NUMBER
Rule 80    simprop -> MAX_ROUNDS NUMBER
Rule 81    simprop -> ACTIONS_TIME NUMBER
Rule 82    simprop -> STOP SIMULATION { stmt_list }
Rule 83    simprop -> AVAILABLE_COMMANDS { command_list }
Rule 84    command_list -> ID command_list
Rule 85    command_list -> epsilon
Rule 86    func_stmt_list -> func_stmt func_stmt_list
Rule 87    func_stmt_list -> epsilon
Rule 88    func_stmt -> FUNC ID = param_list { stmt_list }
Rule 89    param_list -> ID param_list
Rule 90    param_list -> epsilon
Rule 91    stmt_list -> stmt stmt_list
Rule 92    stmt_list -> epsilon
Rule 93    stmt -> if_stmt
Rule 94    stmt -> var_stmt ;
Rule 95    stmt -> index_stmt ;
Rule 96    stmt -> loop_stmt
Rule 97    stmt -> CONTINUE ;
Rule 98    stmt -> BREAK ;
Rule 99    stmt -> RETURN disjunction ;
Rule 100   stmt -> RETURN ;
Rule 101   var_stmt -> accessing = disjunction
Rule 102   index_stmt -> naming [ disjunction ] = disjunction
Rule 103   if_stmt -> IF disjunction { stmt_list } else_stmt
Rule 104   else_stmt -> ELSE if_stmt
Rule 105   else_stmt -> ELSE { stmt_list }
Rule 106   else_stmt -> epsilon
Rule 107   loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list }
Rule 108   loop_init -> var_stmt
Rule 109   loop_init -> epsilon
Rule 110   loop_set -> var_stmt
Rule 111   loop_set -> epsilon
Rule 112   loop_condition -> disjunction
Rule 113   loop_condition -> epsilon
Rule 114   disjunction -> conjunction OR conjunction
Rule 115   disjunction -> conjunction
Rule 116   conjunction -> negation AND negation
Rule 117   conjunction -> negation
Rule 118   negation -> NOT comparison
Rule 119   negation -> comparison
Rule 120   comparison -> expr EQ expr
Rule 121   comparison -> expr NEQ expr
Rule 122   comparison -> expr GE expr
Rule 123   comparison -> expr LE expr
Rule 124   comparison -> expr > expr
Rule 125   comparison -> expr < expr
Rule 126   comparison -> expr
Rule 127   expr -> expr + term
Rule 128   expr -> expr - term
Rule 129   expr -> term
Rule 130   term -> term * factor
Rule 131   term -> term / factor
Rule 132   term -> term % factor
Rule 133   term -> term INTDIV factor
Rule 134   term -> factor
Rule 135   factor -> - factor
Rule 136   factor -> power
Rule 137   power -> atom ^ factor
Rule 138   power -> atom @ factor
Rule 139   power -> naming
Rule 140   naming -> naming [ disjunction ]
Rule 141   naming -> accessing
Rule 142   naming -> ID ( arg_list )
Rule 143   naming -> atom
Rule 144   atom -> NUMBER
Rule 145   atom -> STRING
Rule 146   atom -> bool
Rule 147   atom -> ( expr )
Rule 148   atom -> [ arg_list ]
Rule 149   atom -> { keyarg_list }
Rule 150   accessing -> word
Rule 151   accessing -> word . accessing
Rule 152   word -> ID
Rule 153   word -> ORGANISM
Rule 154   word -> SIMULATION
Rule 155   bool -> TRUE
Rule 156   bool -> FALSE
Rule 157   arg_list -> disjunction
Rule 158   arg_list -> disjunction , arg_list
Rule 159   arg_list -> epsilon
Rule 160   keyarg_list -> keyarg
Rule 161   keyarg_list -> keyarg , keyarg_list
Rule 162   keyarg_list -> epsilon
Rule 163   keyarg -> disjunction = disjunction
Rule 164   test_world -> world_stmt

Terminals, with rules where they appear

%                    : 132
(                    : 62 142 147
)                    : 62 142 147
*                    : 130
+                    : 127
,                    : 107 107 158 161
-                    : 128 135
.                    : 151
/                    : 131
;                    : 94 95 97 98 99 100
<                    : 125
=                    : 88 101 102 163
>                    : 124
@                    : 138
ACTIONS_TIME         : 81
AND                  : 116
ARMS                 : 24
AT                   : 54 59 75
ATTACK               : 15
AVAILABLE_COMMANDS   : 83
BEHAVIOR             : 45 46 57
BREAK                : 98
CHANCE               : 32
COEXISTENCE          : 52
CONTINUE             : 97
COST                 : 11
DECIDE               : 47
DEFAULT              : 74
DEFEND               : 16
DNA                  : 36 42 56
EAT                  : 13
ELSE                 : 104 105
ENTITY               : 51
EPISODES             : 79
EQ                   : 120
EYES                 : 23
FALSE                : 156
FINS                 : 27
FUNC                 : 88
GE                   : 122
GENE                 : 6 7 8
HEALTH               : 20
HEIGHT               : 69
HORNS                : 25
HUNGER               : 21
ID                   : 11 19 36 39 42 45 46 53 56 57 58 73 74 75 84 88 89 142 152
IF                   : 103
IN                   : 30
INFINITE             : 66
INTDIV               : 133
LE                   : 123
LEGS                 : 22
LOOP                 : 107
MAX_ROUNDS           : 80
MOUTH                : 29
MOVE                 : 12
MUTATION             : 31
NEQ                  : 121
NOSE                 : 28
NOT                  : 118
NUMBER               : 11 30 30 30 32 33 62 62 68 69 75 76 79 80 81 144
OR                   : 114
ORGANISM             : 47 55 153
PICK                 : 17
REPR                 : 53 58
REPRODUCE            : 14
RETURN               : 99 100
SIMULATION           : 78 82 154
SIZE                 : 64
SMELL                : 26
SMELLING             : 9 40
STEP                 : 33
STOP                 : 82
STRING               : 145
SWIM                 : 18
TERRAIN              : 65
TIME                 : 47
TRUE                 : 155
VALUE                : 30
VISION               : 10 41
WIDTH                : 68
WORLD                : 63
[                    : 102 140 148
]                    : 102 140 148
^                    : 137
error                : 
newline              : 
{                    : 11 19 30 31 36 45 47 51 54 55 59 63 66 67 70 75 78 82 83 88 103 105 107 149
}                    : 11 19 30 31 36 45 47 51 54 55 59 63 66 67 70 75 78 82 83 88 103 105 107 149

Nonterminals, with rules where they appear

accessing            : 101 141 151
actgene              : 11
actgene_stmt         : 8
arg_list             : 142 148 158
atom                 : 137 138 143
behavior_stmt        : 43
behavior_stmt_list   : 1 43
bool                 : 52 146
command_list         : 83 84
comparison           : 118 119
conjunction          : 114 114 115
decide_stmt          : 45
disjunction          : 99 101 102 102 103 112 140 157 158 163 163
dna_elem             : 37
dna_elem_list        : 36 37
dna_stmt             : 34
dna_stmt_list        : 1 34
else_stmt            : 103
entity_org_stmt_list : 1 48 49
entity_stmt          : 48
entityprop           : 51 51 51
epsilon              : 5 35 38 44 50 61 72 77 85 87 90 92 106 109 111 113 159 162
expr                 : 120 120 121 121 122 122 123 123 124 124 125 125 126 127 128 147
factor               : 130 131 132 133 134 135 137 138
func_stmt            : 86
func_stmt_list       : 45 86
gene_stmt            : 4
gene_stmt_list       : 1 4
if_stmt              : 93 104
index_stmt           : 95
keyarg               : 160 161
keyarg_list          : 149 161
loop_condition       : 107
loop_init            : 107
loop_set             : 107
loop_stmt            : 96
mutationprop         : 31 31
naming               : 102 139 140
negation             : 116 116 117
organism_stmt        : 49
orgprop              : 55 55 55 55
param_list           : 88 89
percpgene            : 7
phygene              : 19
phygene_stmt         : 6
phygeneprop          : 19 19
position             : 54 59 60
position_list        : 54 59 60
power                : 136
program              : 3
sim_stmt             : 1
simprop              : 78 78 78 78 78
stmt                 : 91
stmt_list            : 47 82 88 91 103 105 107
term                 : 127 128 129 130 131 132 133
terrainposn_list     : 75 76
terrainprop          : 71
terrainprop_list     : 70 71
test                 : 0
test_world           : 
var_stmt             : 94 108 110
word                 : 150 151
world_stmt           : 1 164
worldprop            : 63 63
worldsize            : 64
worldsizeprop        : 66 66 67 67
worldterrain         : 65


state 0

    (0) S' -> . test
    (3) test -> . program
    (1) program -> . gene_stmt_list dna_stmt_list behavior_stmt_list entity_org_stmt_list world_stmt sim_stmt
    (4) gene_stmt_list -> . gene_stmt gene_stmt_list
    (5) gene_stmt_list -> . epsilon
    (6) gene_stmt -> . GENE phygene_stmt
    (7) gene_stmt -> . GENE percpgene
    (8) gene_stmt -> . GENE actgene_stmt
    (2) epsilon -> .

    GENE            shift and go to state 6
    DNA             reduce using rule 2 (epsilon -> .)
    BEHAVIOR        reduce using rule 2 (epsilon -> .)
    ENTITY          reduce using rule 2 (epsilon -> .)
    ORGANISM        reduce using rule 2 (epsilon -> .)
    WORLD           reduce using rule 2 (epsilon -> .)

    test                           shift and go to state 1
    program                        shift and go to state 2
    gene_stmt_list                 shift and go to state 3
    gene_stmt                      shift and go to state 4
    epsilon                        shift and go to state 5

state 1

    (0) S' -> test .



state 2

    (3) test -> program .

    $end            reduce using rule 3 (test -> program .)


state 3

    (1) program -> gene_stmt_list . dna_stmt_list behavior_stmt_list entity_org_stmt_list world_stmt sim_stmt
    (34) dna_stmt_list -> . dna_stmt dna_stmt_list
    (35) dna_stmt_list -> . epsilon
    (36) dna_stmt -> . DNA ID { dna_elem_list }
    (2) epsilon -> .

    DNA             shift and go to state 10
    BEHAVIOR        reduce using rule 2 (epsilon -> .)
    ENTITY          reduce using rule 2 (epsilon -> .)
    ORGANISM        reduce using rule 2 (epsilon -> .)
    WORLD           reduce using rule 2 (epsilon -> .)

    dna_stmt_list                  shift and go to state 7
    dna_stmt                       shift and go to state 8
    epsilon                        shift and go to state 9

state 4

    (4) gene_stmt_list -> gene_stmt . gene_stmt_list
    (4) gene_stmt_list -> . gene_stmt gene_stmt_list
    (5) gene_stmt_list -> . epsilon
    (6) gene_stmt -> . GENE phygene_stmt
    (7) gene_stmt -> . GENE percpgene
    (8) gene_stmt -> . GENE actgene_stmt
    (2) epsilon -> .

    GENE            shift and go to state 6
    DNA             reduce using rule 2 (epsilon -> .)
    BEHAVIOR        reduce using rule 2 (epsilon -> .)
    ENTITY          reduce using rule 2 (epsilon -> .)
    ORGANISM        reduce using rule 2 (epsilon -> .)
    WORLD           reduce using rule 2 (epsilon -> .)

    gene_stmt                      shift and go to state 4
    gene_stmt_list                 shift and go to state 11
    epsilon                        shift and go to state 5

state 5

    (5) gene_stmt_list -> epsilon .

    DNA             reduce using rule 5 (gene_stmt_list -> epsilon .)
    BEHAVIOR        reduce using rule 5 (gene_stmt_list -> epsilon .)
    ENTITY          reduce using rule 5 (gene_stmt_list -> epsilon .)
    ORGANISM        reduce using rule 5 (gene_stmt_list -> epsilon .)
    WORLD           reduce using rule 5 (gene_stmt_list -> epsilon .)


state 6

    (6) gene_stmt -> GENE . phygene_stmt
    (7) gene_stmt -> GENE . percpgene
    (8) gene_stmt -> GENE . actgene_stmt
    (19) phygene_stmt -> . phygene ID { phygeneprop phygeneprop }
    (9) percpgene -> . SMELLING
    (10) percpgene -> . VISION
    (11) actgene_stmt -> . actgene ID { COST NUMBER }
    (20) phygene -> . HEALTH
    (21) phygene -> . HUNGER
    (22) phygene -> . LEGS
    (23) phygene -> . EYES
    (24) phygene -> . ARMS
    (25) phygene -> . HORNS
    (26) phygene -> . SMELL
    (27) phygene -> . FINS
    (28) phygene -> . NOSE
    (29) phygene -> . MOUTH
    (12) actgene -> . MOVE
    (13) actgene -> . EAT
    (14) actgene -> . REPRODUCE
    (15) actgene -> . ATTACK
    (16) actgene -> . DEFEND
    (17) actgene -> . PICK
    (18) actgene -> . SWIM

    SMELLING        shift and go to state 16
    VISION          shift and go to state 17
    HEALTH          shift and go to state 19
    HUNGER          shift and go to state 20
    LEGS            shift and go to state 21
    EYES            shift and go to state 22
    ARMS            shift and go to state 23
    HORNS           shift and go to state 24
    SMELL           shift and go to state 25
    FINS            shift and go to state 26
    NOSE            shift and go to state 27
    MOUTH           shift and go to state 28
    MOVE            shift and go to state 29
    EAT             shift and go to state 30
    REPRODUCE       shift and go to state 31
    ATTACK          shift and go to state 32
    DEFEND          shift and go to state 33
    PICK            shift and go to state 34
    SWIM            shift and go to state 35

    phygene_stmt                   shift and go to state 12
    percpgene                      shift and go to state 13
    actgene_stmt                   shift and go to state 14
    phygene                        shift and go to state 15
    actgene                        shift and go to state 18

state 7

    (1) program -> gene_stmt_list dna_stmt_list . behavior_stmt_list entity_org_stmt_list world_stmt sim_stmt
    (43) behavior_stmt_list -> . behavior_stmt behavior_stmt_list
    (44) behavior_stmt_list -> . epsilon
    (45) behavior_stmt -> . BEHAVIOR ID { func_stmt_list decide_stmt }
    (46) behavior_stmt -> . BEHAVIOR ID
    (2) epsilon -> .

    BEHAVIOR        shift and go to state 39
    ENTITY          reduce using rule 2 (epsilon -> .)
    ORGANISM        reduce using rule 2 (epsilon -> .)
    WORLD           reduce using rule 2 (epsilon -> .)

    behavior_stmt_list             shift and go to state 36
    behavior_stmt                  shift and go to state 37
    epsilon                        shift and go to state 38

state 8

    (34) dna_stmt_list -> dna_stmt . dna_stmt_list
    (34) dna_stmt_list -> . dna_stmt dna_stmt_list
    (35) dna_stmt_list -> . epsilon
    (36) dna_stmt -> . DNA ID { dna_elem_list }
    (2) epsilon -> .

    DNA             shift and go to state 10
    BEHAVIOR        reduce using rule 2 (epsilon -> .)
    ENTITY          reduce using rule 2 (epsilon -> .)
    ORGANISM        reduce using rule 2 (epsilon -> .)
    WORLD           reduce using rule 2 (epsilon -> .)

    dna_stmt                       shift and go to state 8
    dna_stmt_list                  shift and go to state 40
    epsilon                        shift and go to state 9

state 9

    (35) dna_stmt_list -> epsilon .

    BEHAVIOR        reduce using rule 35 (dna_stmt_list -> epsilon .)
    ENTITY          reduce using rule 35 (dna_stmt_list -> epsilon .)
    ORGANISM        reduce using rule 35 (dna_stmt_list -> epsilon .)
    WORLD           reduce using rule 35 (dna_stmt_list -> epsilon .)


state 10

    (36) dna_stmt -> DNA . ID { dna_elem_list }

    ID              shift and go to state 41


state 11

    (4) gene_stmt_list -> gene_stmt gene_stmt_list .

    DNA             reduce using rule 4 (gene_stmt_list -> gene_stmt gene_stmt_list .)
    BEHAVIOR        reduce using rule 4 (gene_stmt_list -> gene_stmt gene_stmt_list .)
    ENTITY          reduce using rule 4 (gene_stmt_list -> gene_stmt gene_stmt_list .)
    ORGANISM        reduce using rule 4 (gene_stmt_list -> gene_stmt gene_stmt_list .)
    WORLD           reduce using rule 4 (gene_stmt_list -> gene_stmt gene_stmt_list .)


state 12

    (6) gene_stmt -> GENE phygene_stmt .

    GENE            reduce using rule 6 (gene_stmt -> GENE phygene_stmt .)
    DNA             reduce using rule 6 (gene_stmt -> GENE phygene_stmt .)
    BEHAVIOR        reduce using rule 6 (gene_stmt -> GENE phygene_stmt .)
    ENTITY          reduce using rule 6 (gene_stmt -> GENE phygene_stmt .)
    ORGANISM        reduce using rule 6 (gene_stmt -> GENE phygene_stmt .)
    WORLD           reduce using rule 6 (gene_stmt -> GENE phygene_stmt .)


state 13

    (7) gene_stmt -> GENE percpgene .

    GENE            reduce using rule 7 (gene_stmt -> GENE percpgene .)
    DNA             reduce using rule 7 (gene_stmt -> GENE percpgene .)
    BEHAVIOR        reduce using rule 7 (gene_stmt -> GENE percpgene .)
    ENTITY          reduce using rule 7 (gene_stmt -> GENE percpgene .)
    ORGANISM        reduce using rule 7 (gene_stmt -> GENE percpgene .)
    WORLD           reduce using rule 7 (gene_stmt -> GENE percpgene .)


state 14

    (8) gene_stmt -> GENE actgene_stmt .

    GENE            reduce using rule 8 (gene_stmt -> GENE actgene_stmt .)
    DNA             reduce using rule 8 (gene_stmt -> GENE actgene_stmt .)
    BEHAVIOR        reduce using rule 8 (gene_stmt -> GENE actgene_stmt .)
    ENTITY          reduce using rule 8 (gene_stmt -> GENE actgene_stmt .)
    ORGANISM        reduce using rule 8 (gene_stmt -> GENE actgene_stmt .)
    WORLD           reduce using rule 8 (gene_stmt -> GENE actgene_stmt .)


state 15

    (19) phygene_stmt -> phygene . ID { phygeneprop phygeneprop }

    ID              shift and go to state 42


state 16

    (9) percpgene -> SMELLING .

    GENE            reduce using rule 9 (percpgene -> SMELLING .)
    DNA             reduce using rule 9 (percpgene -> SMELLING .)
    BEHAVIOR        reduce using rule 9 (percpgene -> SMELLING .)
    ENTITY          reduce using rule 9 (percpgene -> SMELLING .)
    ORGANISM        reduce using rule 9 (percpgene -> SMELLING .)
    WORLD           reduce using rule 9 (percpgene -> SMELLING .)


state 17

    (10) percpgene -> VISION .

    GENE            reduce using rule 10 (percpgene -> VISION .)
    DNA             reduce using rule 10 (percpgene -> VISION .)
    BEHAVIOR        reduce using rule 10 (percpgene -> VISION .)
    ENTITY          reduce using rule 10 (percpgene -> VISION .)
    ORGANISM        reduce using rule 10 (percpgene -> VISION .)
    WORLD           reduce using rule 10 (percpgene -> VISION .)


state 18

    (11) actgene_stmt -> actgene . ID { COST NUMBER }

    ID              shift and go to state 43


state 19

    (20) phygene -> HEALTH .

    ID              reduce using rule 20 (phygene -> HEALTH .)


state 20

    (21) phygene -> HUNGER .

    ID              reduce using rule 21 (phygene -> HUNGER .)


state 21

    (22) phygene -> LEGS .

    ID              reduce using rule 22 (phygene -> LEGS .)


state 22

    (23) phygene -> EYES .

    ID              reduce using rule 23 (phygene -> EYES .)


state 23

    (24) phygene -> ARMS .

    ID              reduce using rule 24 (phygene -> ARMS .)


state 24

    (25) phygene -> HORNS .

    ID              reduce using rule 25 (phygene -> HORNS .)


state 25

    (26) phygene -> SMELL .

    ID              reduce using rule 26 (phygene -> SMELL .)


state 26

    (27) phygene -> FINS .

    ID              reduce using rule 27 (phygene -> FINS .)


state 27

    (28) phygene -> NOSE .

    ID              reduce using rule 28 (phygene -> NOSE .)


state 28

    (29) phygene -> MOUTH .

    ID              reduce using rule 29 (phygene -> MOUTH .)


state 29

    (12) actgene -> MOVE .

    ID              reduce using rule 12 (actgene -> MOVE .)


state 30

    (13) actgene -> EAT .

    ID              reduce using rule 13 (actgene -> EAT .)


state 31

    (14) actgene -> REPRODUCE .

    ID              reduce using rule 14 (actgene -> REPRODUCE .)


state 32

    (15) actgene -> ATTACK .

    ID              reduce using rule 15 (actgene -> ATTACK .)


state 33

    (16) actgene -> DEFEND .

    ID              reduce using rule 16 (actgene -> DEFEND .)


state 34

    (17) actgene -> PICK .

    ID              reduce using rule 17 (actgene -> PICK .)


state 35

    (18) actgene -> SWIM .

    ID              reduce using rule 18 (actgene -> SWIM .)


state 36

    (1) program -> gene_stmt_list dna_stmt_list behavior_stmt_list . entity_org_stmt_list world_stmt sim_stmt
    (48) entity_org_stmt_list -> . entity_stmt entity_org_stmt_list
    (49) entity_org_stmt_list -> . organism_stmt entity_org_stmt_list
    (50) entity_org_stmt_list -> . epsilon
    (51) entity_stmt -> . ENTITY { entityprop entityprop entityprop }
    (55) organism_stmt -> . ORGANISM { orgprop orgprop orgprop orgprop }
    (2) epsilon -> .

    ENTITY          shift and go to state 48
    ORGANISM        shift and go to state 49
    WORLD           reduce using rule 2 (epsilon -> .)

    entity_org_stmt_list           shift and go to state 44
    entity_stmt                    shift and go to state 45
    organism_stmt                  shift and go to state 46
    epsilon                        shift and go to state 47

state 37

    (43) behavior_stmt_list -> behavior_stmt . behavior_stmt_list
    (43) behavior_stmt_list -> . behavior_stmt behavior_stmt_list
    (44) behavior_stmt_list -> . epsilon
    (45) behavior_stmt -> . BEHAVIOR ID { func_stmt_list decide_stmt }
    (46) behavior_stmt -> . BEHAVIOR ID
    (2) epsilon -> .

    BEHAVIOR        shift and go to state 39
    ENTITY          reduce using rule 2 (epsilon -> .)
    ORGANISM        reduce using rule 2 (epsilon -> .)
    WORLD           reduce using rule 2 (epsilon -> .)

    behavior_stmt                  shift and go to state 37
    behavior_stmt_list             shift and go to state 50
    epsilon                        shift and go to state 38

state 38

    (44) behavior_stmt_list -> epsilon .

    ENTITY          reduce using rule 44 (behavior_stmt_list -> epsilon .)
    ORGANISM        reduce using rule 44 (behavior_stmt_list -> epsilon .)
    WORLD           reduce using rule 44 (behavior_stmt_list -> epsilon .)


state 39

    (45) behavior_stmt -> BEHAVIOR . ID { func_stmt_list decide_stmt }
    (46) behavior_stmt -> BEHAVIOR . ID

    ID              shift and go to state 51


state 40

    (34) dna_stmt_list -> dna_stmt dna_stmt_list .

    BEHAVIOR        reduce using rule 34 (dna_stmt_list -> dna_stmt dna_stmt_list .)
    ENTITY          reduce using rule 34 (dna_stmt_list -> dna_stmt dna_stmt_list .)
    ORGANISM        reduce using rule 34 (dna_stmt_list -> dna_stmt dna_stmt_list .)
    WORLD           reduce using rule 34 (dna_stmt_list -> dna_stmt dna_stmt_list .)


state 41

    (36) dna_stmt -> DNA ID . { dna_elem_list }

    {               shift and go to state 52


state 42

    (19) phygene_stmt -> phygene ID . { phygeneprop phygeneprop }

    {               shift and go to state 53


state 43

    (11) actgene_stmt -> actgene ID . { COST NUMBER }

    {               shift and go to state 54


state 44

    (1) program -> gene_stmt_list dna_stmt_list behavior_stmt_list entity_org_stmt_list . world_stmt sim_stmt
    (63) world_stmt -> . WORLD { worldprop worldprop }

    WORLD           shift and go to state 56

    world_stmt                     shift and go to state 55

state 45

    (48) entity_org_stmt_list -> entity_stmt . entity_org_stmt_list
    (48) entity_org_stmt_list -> . entity_stmt entity_org_stmt_list
    (49) entity_org_stmt_list -> . organism_stmt entity_org_stmt_list
    (50) entity_org_stmt_list -> . epsilon
    (51) entity_stmt -> . ENTITY { entityprop entityprop entityprop }
    (55) organism_stmt -> . ORGANISM { orgprop orgprop orgprop orgprop }
    (2) epsilon -> .

    ENTITY          shift and go to state 48
    ORGANISM        shift and go to state 49
    WORLD           reduce using rule 2 (epsilon -> .)

    entity_stmt                    shift and go to state 45
    entity_org_stmt_list           shift and go to state 57
    organism_stmt                  shift and go to state 46
    epsilon                        shift and go to state 47

state 46

    (49) entity_org_stmt_list -> organism_stmt . entity_org_stmt_list
    (48) entity_org_stmt_list -> . entity_stmt entity_org_stmt_list
    (49) entity_org_stmt_list -> . organism_stmt entity_org_stmt_list
    (50) entity_org_stmt_list -> . epsilon
    (51) entity_stmt -> . ENTITY { entityprop entityprop entityprop }
    (55) organism_stmt -> . ORGANISM { orgprop orgprop orgprop orgprop }
    (2) epsilon -> .

    ENTITY          shift and go to state 48
    ORGANISM        shift and go to state 49
    WORLD           reduce using rule 2 (epsilon -> .)

    organism_stmt                  shift and go to state 46
    entity_org_stmt_list           shift and go to state 58
    entity_stmt                    shift and go to state 45
    epsilon                        shift and go to state 47

state 47

    (50) entity_org_stmt_list -> epsilon .

    WORLD           reduce using rule 50 (entity_org_stmt_list -> epsilon .)


state 48

    (51) entity_stmt -> ENTITY . { entityprop entityprop entityprop }

    {               shift and go to state 59


state 49

    (55) organism_stmt -> ORGANISM . { orgprop orgprop orgprop orgprop }

    {               shift and go to state 60


state 50

    (43) behavior_stmt_list -> behavior_stmt behavior_stmt_list .

    ENTITY          reduce using rule 43 (behavior_stmt_list -> behavior_stmt behavior_stmt_list .)
    ORGANISM        reduce using rule 43 (behavior_stmt_list -> behavior_stmt behavior_stmt_list .)
    WORLD           reduce using rule 43 (behavior_stmt_list -> behavior_stmt behavior_stmt_list .)


state 51

    (45) behavior_stmt -> BEHAVIOR ID . { func_stmt_list decide_stmt }
    (46) behavior_stmt -> BEHAVIOR ID .

    {               shift and go to state 61
    BEHAVIOR        reduce using rule 46 (behavior_stmt -> BEHAVIOR ID .)
    ENTITY          reduce using rule 46 (behavior_stmt -> BEHAVIOR ID .)
    ORGANISM        reduce using rule 46 (behavior_stmt -> BEHAVIOR ID .)
    WORLD           reduce using rule 46 (behavior_stmt -> BEHAVIOR ID .)


state 52

    (36) dna_stmt -> DNA ID { . dna_elem_list }
    (37) dna_elem_list -> . dna_elem dna_elem_list
    (38) dna_elem_list -> . epsilon
    (39) dna_elem -> . ID
    (40) dna_elem -> . SMELLING
    (41) dna_elem -> . VISION
    (42) dna_elem -> . DNA ID
    (2) epsilon -> .

    ID              shift and go to state 63
    SMELLING        shift and go to state 67
    VISION          shift and go to state 68
    DNA             shift and go to state 62
    }               reduce using rule 2 (epsilon -> .)

    dna_elem_list                  shift and go to state 64
    dna_elem                       shift and go to state 65
    epsilon                        shift and go to state 66

state 53

    (19) phygene_stmt -> phygene ID { . phygeneprop phygeneprop }
    (30) phygeneprop -> . VALUE NUMBER IN { NUMBER NUMBER }
    (31) phygeneprop -> . MUTATION { mutationprop mutationprop }

    VALUE           shift and go to state 70
    MUTATION        shift and go to state 71

    phygeneprop                    shift and go to state 69

state 54

    (11) actgene_stmt -> actgene ID { . COST NUMBER }

    COST            shift and go to state 72


state 55

    (1) program -> gene_stmt_list dna_stmt_list behavior_stmt_list entity_org_stmt_list world_stmt . sim_stmt
    (78) sim_stmt -> . SIMULATION { simprop simprop simprop simprop simprop }

    SIMULATION      shift and go to state 74

    sim_stmt                       shift and go to state 73

state 56

    (63) world_stmt -> WORLD . { worldprop worldprop }

    {               shift and go to state 75


state 57

    (48) entity_org_stmt_list -> entity_stmt entity_org_stmt_list .

    WORLD           reduce using rule 48 (entity_org_stmt_list -> entity_stmt entity_org_stmt_list .)


state 58

    (49) entity_org_stmt_list -> organism_stmt entity_org_stmt_list .

    WORLD           reduce using rule 49 (entity_org_stmt_list -> organism_stmt entity_org_stmt_list .)


state 59

    (51) entity_stmt -> ENTITY { . entityprop entityprop entityprop }
    (52) entityprop -> . COEXISTENCE bool
    (53) entityprop -> . REPR ID
    (54) entityprop -> . AT { position position_list }

    COEXISTENCE     shift and go to state 77
    REPR            shift and go to state 78
    AT              shift and go to state 79

    entityprop                     shift and go to state 76

state 60

    (55) organism_stmt -> ORGANISM { . orgprop orgprop orgprop orgprop }
    (56) orgprop -> . DNA ID
    (57) orgprop -> . BEHAVIOR ID
    (58) orgprop -> . REPR ID
    (59) orgprop -> . AT { position position_list }

    DNA             shift and go to state 81
    BEHAVIOR        shift and go to state 82
    REPR            shift and go to state 83
    AT              shift and go to state 84

    orgprop                        shift and go to state 80

state 61

    (45) behavior_stmt -> BEHAVIOR ID { . func_stmt_list decide_stmt }
    (86) func_stmt_list -> . func_stmt func_stmt_list
    (87) func_stmt_list -> . epsilon
    (88) func_stmt -> . FUNC ID = param_list { stmt_list }
    (2) epsilon -> .

    FUNC            shift and go to state 88
    DECIDE          reduce using rule 2 (epsilon -> .)

    func_stmt_list                 shift and go to state 85
    func_stmt                      shift and go to state 86
    epsilon                        shift and go to state 87

state 62

    (42) dna_elem -> DNA . ID

    ID              shift and go to state 89


state 63

    (39) dna_elem -> ID .

    ID              reduce using rule 39 (dna_elem -> ID .)
    SMELLING        reduce using rule 39 (dna_elem -> ID .)
    VISION          reduce using rule 39 (dna_elem -> ID .)
    DNA             reduce using rule 39 (dna_elem -> ID .)
    }               reduce using rule 39 (dna_elem -> ID .)


state 64

    (36) dna_stmt -> DNA ID { dna_elem_list . }

    }               shift and go to state 90


state 65

    (37) dna_elem_list -> dna_elem . dna_elem_list
    (37) dna_elem_list -> . dna_elem dna_elem_list
    (38) dna_elem_list -> . epsilon
    (39) dna_elem -> . ID
    (40) dna_elem -> . SMELLING
    (41) dna_elem -> . VISION
    (42) dna_elem -> . DNA ID
    (2) epsilon -> .

    ID              shift and go to state 63
    SMELLING        shift and go to state 67
    VISION          shift and go to state 68
    DNA             shift and go to state 62
    }               reduce using rule 2 (epsilon -> .)

    dna_elem                       shift and go to state 65
    dna_elem_list                  shift and go to state 91
    epsilon                        shift and go to state 66

state 66

    (38) dna_elem_list -> epsilon .

    }               reduce using rule 38 (dna_elem_list -> epsilon .)


state 67

    (40) dna_elem -> SMELLING .

    ID              reduce using rule 40 (dna_elem -> SMELLING .)
    SMELLING        reduce using rule 40 (dna_elem -> SMELLING .)
    VISION          reduce using rule 40 (dna_elem -> SMELLING .)
    DNA             reduce using rule 40 (dna_elem -> SMELLING .)
    }               reduce using rule 40 (dna_elem -> SMELLING .)


state 68

    (41) dna_elem -> VISION .

    ID              reduce using rule 41 (dna_elem -> VISION .)
    SMELLING        reduce using rule 41 (dna_elem -> VISION .)
    VISION          reduce using rule 41 (dna_elem -> VISION .)
    DNA             reduce using rule 41 (dna_elem -> VISION .)
    }               reduce using rule 41 (dna_elem -> VISION .)


state 69

    (19) phygene_stmt -> phygene ID { phygeneprop . phygeneprop }
    (30) phygeneprop -> . VALUE NUMBER IN { NUMBER NUMBER }
    (31) phygeneprop -> . MUTATION { mutationprop mutationprop }

    VALUE           shift and go to state 70
    MUTATION        shift and go to state 71

    phygeneprop                    shift and go to state 92

state 70

    (30) phygeneprop -> VALUE . NUMBER IN { NUMBER NUMBER }

    NUMBER          shift and go to state 93


state 71

    (31) phygeneprop -> MUTATION . { mutationprop mutationprop }

    {               shift and go to state 94


state 72

    (11) actgene_stmt -> actgene ID { COST . NUMBER }

    NUMBER          shift and go to state 95


state 73

    (1) program -> gene_stmt_list dna_stmt_list behavior_stmt_list entity_org_stmt_list world_stmt sim_stmt .

    $end            reduce using rule 1 (program -> gene_stmt_list dna_stmt_list behavior_stmt_list entity_org_stmt_list world_stmt sim_stmt .)


state 74

    (78) sim_stmt -> SIMULATION . { simprop simprop simprop simprop simprop }

    {               shift and go to state 96


state 75

    (63) world_stmt -> WORLD { . worldprop worldprop }
    (64) worldprop -> . SIZE worldsize
    (65) worldprop -> . TERRAIN worldterrain

    SIZE            shift and go to state 98
    TERRAIN         shift and go to state 99

    worldprop                      shift and go to state 97

state 76

    (51) entity_stmt -> ENTITY { entityprop . entityprop entityprop }
    (52) entityprop -> . COEXISTENCE bool
    (53) entityprop -> . REPR ID
    (54) entityprop -> . AT { position position_list }

    COEXISTENCE     shift and go to state 77
    REPR            shift and go to state 78
    AT              shift and go to state 79

    entityprop                     shift and go to state 100

state 77

    (52) entityprop -> COEXISTENCE . bool
    (155) bool -> . TRUE
    (156) bool -> . FALSE

    TRUE            shift and go to state 102
    FALSE           shift and go to state 103

    bool                           shift and go to state 101

state 78

    (53) entityprop -> REPR . ID

    ID              shift and go to state 104


state 79

    (54) entityprop -> AT . { position position_list }

    {               shift and go to state 105


state 80

    (55) organism_stmt -> ORGANISM { orgprop . orgprop orgprop orgprop }
    (56) orgprop -> . DNA ID
    (57) orgprop -> . BEHAVIOR ID
    (58) orgprop -> . REPR ID
    (59) orgprop -> . AT { position position_list }

    DNA             shift and go to state 81
    BEHAVIOR        shift and go to state 82
    REPR            shift and go to state 83
    AT              shift and go to state 84

    orgprop                        shift and go to state 106

state 81

    (56) orgprop -> DNA . ID

    ID              shift and go to state 107


state 82

    (57) orgprop -> BEHAVIOR . ID

    ID              shift and go to state 108


state 83

    (58) orgprop -> REPR . ID

    ID              shift and go to state 109


state 84

    (59) orgprop -> AT . { position position_list }

    {               shift and go to state 110


state 85

    (45) behavior_stmt -> BEHAVIOR ID { func_stmt_list . decide_stmt }
    (47) decide_stmt -> . DECIDE ORGANISM TIME { stmt_list }

    DECIDE          shift and go to state 112

    decide_stmt                    shift and go to state 111

state 86

    (86) func_stmt_list -> func_stmt . func_stmt_list
    (86) func_stmt_list -> . func_stmt func_stmt_list
    (87) func_stmt_list -> . epsilon
    (88) func_stmt -> . FUNC ID = param_list { stmt_list }
    (2) epsilon -> .

    FUNC            shift and go to state 88
    DECIDE          reduce using rule 2 (epsilon -> .)

    func_stmt                      shift and go to state 86
    func_stmt_list                 shift and go to state 113
    epsilon                        shift and go to state 87

state 87

    (87) func_stmt_list -> epsilon .

    DECIDE          reduce using rule 87 (func_stmt_list -> epsilon .)


state 88

    (88) func_stmt -> FUNC . ID = param_list { stmt_list }

    ID              shift and go to state 114


state 89

    (42) dna_elem -> DNA ID .

    ID              reduce using rule 42 (dna_elem -> DNA ID .)
    SMELLING        reduce using rule 42 (dna_elem -> DNA ID .)
    VISION          reduce using rule 42 (dna_elem -> DNA ID .)
    DNA             reduce using rule 42 (dna_elem -> DNA ID .)
    }               reduce using rule 42 (dna_elem -> DNA ID .)


state 90

    (36) dna_stmt -> DNA ID { dna_elem_list } .

    DNA             reduce using rule 36 (dna_stmt -> DNA ID { dna_elem_list } .)
    BEHAVIOR        reduce using rule 36 (dna_stmt -> DNA ID { dna_elem_list } .)
    ENTITY          reduce using rule 36 (dna_stmt -> DNA ID { dna_elem_list } .)
    ORGANISM        reduce using rule 36 (dna_stmt -> DNA ID { dna_elem_list } .)
    WORLD           reduce using rule 36 (dna_stmt -> DNA ID { dna_elem_list } .)


state 91

    (37) dna_elem_list -> dna_elem dna_elem_list .

    }               reduce using rule 37 (dna_elem_list -> dna_elem dna_elem_list .)


state 92

    (19) phygene_stmt -> phygene ID { phygeneprop phygeneprop . }

    }               shift and go to state 115


state 93

    (30) phygeneprop -> VALUE NUMBER . IN { NUMBER NUMBER }

    IN              shift and go to state 116


state 94

    (31) phygeneprop -> MUTATION { . mutationprop mutationprop }
    (32) mutationprop -> . CHANCE NUMBER
    (33) mutationprop -> . STEP NUMBER

    CHANCE          shift and go to state 118
    STEP            shift and go to state 119

    mutationprop                   shift and go to state 117

state 95

    (11) actgene_stmt -> actgene ID { COST NUMBER . }

    }               shift and go to state 120


state 96

    (78) sim_stmt -> SIMULATION { . simprop simprop simprop simprop simprop }
    (79) simprop -> . EPISODES NUMBER
    (80) simprop -> . MAX_ROUNDS NUMBER
    (81) simprop -> . ACTIONS_TIME NUMBER
    (82) simprop -> . STOP SIMULATION { stmt_list }
    (83) simprop -> . AVAILABLE_COMMANDS { command_list }

    EPISODES        shift and go to state 122
    MAX_ROUNDS      shift and go to state 123
    ACTIONS_TIME    shift and go to state 124
    STOP            shift and go to state 125
    AVAILABLE_COMMANDS shift and go to state 126

    simprop                        shift and go to state 121

state 97

    (63) world_stmt -> WORLD { worldprop . worldprop }
    (64) worldprop -> . SIZE worldsize
    (65) worldprop -> . TERRAIN worldterrain

    SIZE            shift and go to state 98
    TERRAIN         shift and go to state 99

    worldprop                      shift and go to state 127

state 98

    (64) worldprop -> SIZE . worldsize
    (66) worldsize -> . INFINITE { worldsizeprop worldsizeprop }
    (67) worldsize -> . { worldsizeprop worldsizeprop }

    INFINITE        shift and go to state 129
    {               shift and go to state 130

    worldsize                      shift and go to state 128

state 99

    (65) worldprop -> TERRAIN . worldterrain
    (70) worldterrain -> . { terrainprop_list }

    {               shift and go to state 132

    worldterrain                   shift and go to state 131

state 100

    (51) entity_stmt -> ENTITY { entityprop entityprop . entityprop }
    (52) entityprop -> . COEXISTENCE bool
    (53) entityprop -> . REPR ID
    (54) entityprop -> . AT { position position_list }

    COEXISTENCE     shift and go to state 77
    REPR            shift and go to state 78
    AT              shift and go to state 79

    entityprop                     shift and go to state 133

state 101

    (52) entityprop -> COEXISTENCE bool .

    COEXISTENCE     reduce using rule 52 (entityprop -> COEXISTENCE bool .)
    REPR            reduce using rule 52 (entityprop -> COEXISTENCE bool .)
    AT              reduce using rule 52 (entityprop -> COEXISTENCE bool .)
    }               reduce using rule 52 (entityprop -> COEXISTENCE bool .)


state 102

    (155) bool -> TRUE .

    COEXISTENCE     reduce using rule 155 (bool -> TRUE .)
    REPR            reduce using rule 155 (bool -> TRUE .)
    AT              reduce using rule 155 (bool -> TRUE .)
    }               reduce using rule 155 (bool -> TRUE .)
    [               reduce using rule 155 (bool -> TRUE .)
    ^               reduce using rule 155 (bool -> TRUE .)
    @               reduce using rule 155 (bool -> TRUE .)
    *               reduce using rule 155 (bool -> TRUE .)
    /               reduce using rule 155 (bool -> TRUE .)
    %               reduce using rule 155 (bool -> TRUE .)
    INTDIV          reduce using rule 155 (bool -> TRUE .)
    EQ              reduce using rule 155 (bool -> TRUE .)
    NEQ             reduce using rule 155 (bool -> TRUE .)
    GE              reduce using rule 155 (bool -> TRUE .)
    LE              reduce using rule 155 (bool -> TRUE .)
    >               reduce using rule 155 (bool -> TRUE .)
    <               reduce using rule 155 (bool -> TRUE .)
    +               reduce using rule 155 (bool -> TRUE .)
    -               reduce using rule 155 (bool -> TRUE .)
    AND             reduce using rule 155 (bool -> TRUE .)
    OR              reduce using rule 155 (bool -> TRUE .)
    =               reduce using rule 155 (bool -> TRUE .)
    ;               reduce using rule 155 (bool -> TRUE .)
    {               reduce using rule 155 (bool -> TRUE .)
    ,               reduce using rule 155 (bool -> TRUE .)
    ]               reduce using rule 155 (bool -> TRUE .)
    )               reduce using rule 155 (bool -> TRUE .)


state 103

    (156) bool -> FALSE .

    COEXISTENCE     reduce using rule 156 (bool -> FALSE .)
    REPR            reduce using rule 156 (bool -> FALSE .)
    AT              reduce using rule 156 (bool -> FALSE .)
    }               reduce using rule 156 (bool -> FALSE .)
    [               reduce using rule 156 (bool -> FALSE .)
    ^               reduce using rule 156 (bool -> FALSE .)
    @               reduce using rule 156 (bool -> FALSE .)
    *               reduce using rule 156 (bool -> FALSE .)
    /               reduce using rule 156 (bool -> FALSE .)
    %               reduce using rule 156 (bool -> FALSE .)
    INTDIV          reduce using rule 156 (bool -> FALSE .)
    EQ              reduce using rule 156 (bool -> FALSE .)
    NEQ             reduce using rule 156 (bool -> FALSE .)
    GE              reduce using rule 156 (bool -> FALSE .)
    LE              reduce using rule 156 (bool -> FALSE .)
    >               reduce using rule 156 (bool -> FALSE .)
    <               reduce using rule 156 (bool -> FALSE .)
    +               reduce using rule 156 (bool -> FALSE .)
    -               reduce using rule 156 (bool -> FALSE .)
    AND             reduce using rule 156 (bool -> FALSE .)
    OR              reduce using rule 156 (bool -> FALSE .)
    =               reduce using rule 156 (bool -> FALSE .)
    ;               reduce using rule 156 (bool -> FALSE .)
    {               reduce using rule 156 (bool -> FALSE .)
    ,               reduce using rule 156 (bool -> FALSE .)
    ]               reduce using rule 156 (bool -> FALSE .)
    )               reduce using rule 156 (bool -> FALSE .)


state 104

    (53) entityprop -> REPR ID .

    COEXISTENCE     reduce using rule 53 (entityprop -> REPR ID .)
    REPR            reduce using rule 53 (entityprop -> REPR ID .)
    AT              reduce using rule 53 (entityprop -> REPR ID .)
    }               reduce using rule 53 (entityprop -> REPR ID .)


state 105

    (54) entityprop -> AT { . position position_list }
    (62) position -> . ( NUMBER NUMBER )

    (               shift and go to state 135

    position                       shift and go to state 134

state 106

    (55) organism_stmt -> ORGANISM { orgprop orgprop . orgprop orgprop }
    (56) orgprop -> . DNA ID
    (57) orgprop -> . BEHAVIOR ID
    (58) orgprop -> . REPR ID
    (59) orgprop -> . AT { position position_list }

    DNA             shift and go to state 81
    BEHAVIOR        shift and go to state 82
    REPR            shift and go to state 83
    AT              shift and go to state 84

    orgprop                        shift and go to state 136

state 107

    (56) orgprop -> DNA ID .

    DNA             reduce using rule 56 (orgprop -> DNA ID .)
    BEHAVIOR        reduce using rule 56 (orgprop -> DNA ID .)
    REPR            reduce using rule 56 (orgprop -> DNA ID .)
    AT              reduce using rule 56 (orgprop -> DNA ID .)
    }               reduce using rule 56 (orgprop -> DNA ID .)


state 108

    (57) orgprop -> BEHAVIOR ID .

    DNA             reduce using rule 57 (orgprop -> BEHAVIOR ID .)
    BEHAVIOR        reduce using rule 57 (orgprop -> BEHAVIOR ID .)
    REPR            reduce using rule 57 (orgprop -> BEHAVIOR ID .)
    AT              reduce using rule 57 (orgprop -> BEHAVIOR ID .)
    }               reduce using rule 57 (orgprop -> BEHAVIOR ID .)


state 109

    (58) orgprop -> REPR ID .

    DNA             reduce using rule 58 (orgprop -> REPR ID .)
    BEHAVIOR        reduce using rule 58 (orgprop -> REPR ID .)
    REPR            reduce using rule 58 (orgprop -> REPR ID .)
    AT              reduce using rule 58 (orgprop -> REPR ID .)
    }               reduce using rule 58 (orgprop -> REPR ID .)


state 110

    (59) orgprop -> AT { . position position_list }
    (62) position -> . ( NUMBER NUMBER )

    (               shift and go to state 135

    position                       shift and go to state 137

state 111

    (45) behavior_stmt -> BEHAVIOR ID { func_stmt_list decide_stmt . }

    }               shift and go to state 138


state 112

    (47) decide_stmt -> DECIDE . ORGANISM TIME { stmt_list }

    ORGANISM        shift and go to state 139


state 113

    (86) func_stmt_list -> func_stmt func_stmt_list .

    DECIDE          reduce using rule 86 (func_stmt_list -> func_stmt func_stmt_list .)


state 114

    (88) func_stmt -> FUNC ID . = param_list { stmt_list }

    =               shift and go to state 140


state 115

    (19) phygene_stmt -> phygene ID { phygeneprop phygeneprop } .

    GENE            reduce using rule 19 (phygene_stmt -> phygene ID { phygeneprop phygeneprop } .)
    DNA             reduce using rule 19 (phygene_stmt -> phygene ID { phygeneprop phygeneprop } .)
    BEHAVIOR        reduce using rule 19 (phygene_stmt -> phygene ID { phygeneprop phygeneprop } .)
    ENTITY          reduce using rule 19 (phygene_stmt -> phygene ID { phygeneprop phygeneprop } .)
    ORGANISM        reduce using rule 19 (phygene_stmt -> phygene ID { phygeneprop phygeneprop } .)
    WORLD           reduce using rule 19 (phygene_stmt -> phygene ID { phygeneprop phygeneprop } .)


state 116

    (30) phygeneprop -> VALUE NUMBER IN . { NUMBER NUMBER }

    {               shift and go to state 141


state 117

    (31) phygeneprop -> MUTATION { mutationprop . mutationprop }
    (32) mutationprop -> . CHANCE NUMBER
    (33) mutationprop -> . STEP NUMBER

    CHANCE          shift and go to state 118
    STEP            shift and go to state 119

    mutationprop                   shift and go to state 142

state 118

    (32) mutationprop -> CHANCE . NUMBER

    NUMBER          shift and go to state 143


state 119

    (33) mutationprop -> STEP . NUMBER

    NUMBER          shift and go to state 144


state 120

    (11) actgene_stmt -> actgene ID { COST NUMBER } .

    GENE            reduce using rule 11 (actgene_stmt -> actgene ID { COST NUMBER } .)
    DNA             reduce using rule 11 (actgene_stmt -> actgene ID { COST NUMBER } .)
    BEHAVIOR        reduce using rule 11 (actgene_stmt -> actgene ID { COST NUMBER } .)
    ENTITY          reduce using rule 11 (actgene_stmt -> actgene ID { COST NUMBER } .)
    ORGANISM        reduce using rule 11 (actgene_stmt -> actgene ID { COST NUMBER } .)
    WORLD           reduce using rule 11 (actgene_stmt -> actgene ID { COST NUMBER } .)


state 121

    (78) sim_stmt -> SIMULATION { simprop . simprop simprop simprop simprop }
    (79) simprop -> . EPISODES NUMBER
    (80) simprop -> . MAX_ROUNDS NUMBER
    (81) simprop -> . ACTIONS_TIME NUMBER
    (82) simprop -> . STOP SIMULATION { stmt_list }
    (83) simprop -> . AVAILABLE_COMMANDS { command_list }

    EPISODES        shift and go to state 122
    MAX_ROUNDS      shift and go to state 123
    ACTIONS_TIME    shift and go to state 124
    STOP            shift and go to state 125
    AVAILABLE_COMMANDS shift and go to state 126

    simprop                        shift and go to state 145

state 122

    (79) simprop -> EPISODES . NUMBER

    NUMBER          shift and go to state 146


state 123

    (80) simprop -> MAX_ROUNDS . NUMBER

    NUMBER          shift and go to state 147


state 124

    (81) simprop -> ACTIONS_TIME . NUMBER

    NUMBER          shift and go to state 148


state 125

    (82) simprop -> STOP . SIMULATION { stmt_list }

    SIMULATION      shift and go to state 149


state 126

    (83) simprop -> AVAILABLE_COMMANDS . { command_list }

    {               shift and go to state 150


state 127

    (63) world_stmt -> WORLD { worldprop worldprop . }

    }               shift and go to state 151


state 128

    (64) worldprop -> SIZE worldsize .

    SIZE            reduce using rule 64 (worldprop -> SIZE worldsize .)
    TERRAIN         reduce using rule 64 (worldprop -> SIZE worldsize .)
    }               reduce using rule 64 (worldprop -> SIZE worldsize .)


state 129

    (66) worldsize -> INFINITE . { worldsizeprop worldsizeprop }

    {               shift and go to state 152


state 130

    (67) worldsize -> { . worldsizeprop worldsizeprop }
    (68) worldsizeprop -> . WIDTH NUMBER
    (69) worldsizeprop -> . HEIGHT NUMBER

    WIDTH           shift and go to state 154
    HEIGHT          shift and go to state 155

    worldsizeprop                  shift and go to state 153

state 131

    (65) worldprop -> TERRAIN worldterrain .

    SIZE            reduce using rule 65 (worldprop -> TERRAIN worldterrain .)
    TERRAIN         reduce using rule 65 (worldprop -> TERRAIN worldterrain .)
    }               reduce using rule 65 (worldprop -> TERRAIN worldterrain .)


state 132

    (70) worldterrain -> { . terrainprop_list }
    (71) terrainprop_list -> . terrainprop terrainprop_list
    (72) terrainprop_list -> . epsilon
    (73) terrainprop -> . ID
    (74) terrainprop -> . DEFAULT ID
    (75) terrainprop -> . ID AT { NUMBER terrainposn_list }
    (2) epsilon -> .

    ID              shift and go to state 159
    DEFAULT         shift and go to state 160
    }               reduce using rule 2 (epsilon -> .)

    terrainprop_list               shift and go to state 156
    terrainprop                    shift and go to state 157
    epsilon                        shift and go to state 158

state 133

    (51) entity_stmt -> ENTITY { entityprop entityprop entityprop . }

    }               shift and go to state 161


state 134

    (54) entityprop -> AT { position . position_list }
    (60) position_list -> . position position_list
    (61) position_list -> . epsilon
    (62) position -> . ( NUMBER NUMBER )
    (2) epsilon -> .

    (               shift and go to state 135
    }               reduce using rule 2 (epsilon -> .)

    position                       shift and go to state 162
    position_list                  shift and go to state 163
    epsilon                        shift and go to state 164

state 135

    (62) position -> ( . NUMBER NUMBER )

    NUMBER          shift and go to state 165


state 136

    (55) organism_stmt -> ORGANISM { orgprop orgprop orgprop . orgprop }
    (56) orgprop -> . DNA ID
    (57) orgprop -> . BEHAVIOR ID
    (58) orgprop -> . REPR ID
    (59) orgprop -> . AT { position position_list }

    DNA             shift and go to state 81
    BEHAVIOR        shift and go to state 82
    REPR            shift and go to state 83
    AT              shift and go to state 84

    orgprop                        shift and go to state 166

state 137

    (59) orgprop -> AT { position . position_list }
    (60) position_list -> . position position_list
    (61) position_list -> . epsilon
    (62) position -> . ( NUMBER NUMBER )
    (2) epsilon -> .

    (               shift and go to state 135
    }               reduce using rule 2 (epsilon -> .)

    position                       shift and go to state 162
    position_list                  shift and go to state 167
    epsilon                        shift and go to state 164

state 138

    (45) behavior_stmt -> BEHAVIOR ID { func_stmt_list decide_stmt } .

    BEHAVIOR        reduce using rule 45 (behavior_stmt -> BEHAVIOR ID { func_stmt_list decide_stmt } .)
    ENTITY          reduce using rule 45 (behavior_stmt -> BEHAVIOR ID { func_stmt_list decide_stmt } .)
    ORGANISM        reduce using rule 45 (behavior_stmt -> BEHAVIOR ID { func_stmt_list decide_stmt } .)
    WORLD           reduce using rule 45 (behavior_stmt -> BEHAVIOR ID { func_stmt_list decide_stmt } .)


state 139

    (47) decide_stmt -> DECIDE ORGANISM . TIME { stmt_list }

    TIME            shift and go to state 168


state 140

    (88) func_stmt -> FUNC ID = . param_list { stmt_list }
    (89) param_list -> . ID param_list
    (90) param_list -> . epsilon
    (2) epsilon -> .

    ID              shift and go to state 169
    {               reduce using rule 2 (epsilon -> .)

    param_list                     shift and go to state 170
    epsilon                        shift and go to state 171

state 141

    (30) phygeneprop -> VALUE NUMBER IN { . NUMBER NUMBER }

    NUMBER          shift and go to state 172


state 142

    (31) phygeneprop -> MUTATION { mutationprop mutationprop . }

    }               shift and go to state 173


state 143

    (32) mutationprop -> CHANCE NUMBER .

    CHANCE          reduce using rule 32 (mutationprop -> CHANCE NUMBER .)
    STEP            reduce using rule 32 (mutationprop -> CHANCE NUMBER .)
    }               reduce using rule 32 (mutationprop -> CHANCE NUMBER .)


state 144

    (33) mutationprop -> STEP NUMBER .

    CHANCE          reduce using rule 33 (mutationprop -> STEP NUMBER .)
    STEP            reduce using rule 33 (mutationprop -> STEP NUMBER .)
    }               reduce using rule 33 (mutationprop -> STEP NUMBER .)


state 145

    (78) sim_stmt -> SIMULATION { simprop simprop . simprop simprop simprop }
    (79) simprop -> . EPISODES NUMBER
    (80) simprop -> . MAX_ROUNDS NUMBER
    (81) simprop -> . ACTIONS_TIME NUMBER
    (82) simprop -> . STOP SIMULATION { stmt_list }
    (83) simprop -> . AVAILABLE_COMMANDS { command_list }

    EPISODES        shift and go to state 122
    MAX_ROUNDS      shift and go to state 123
    ACTIONS_TIME    shift and go to state 124
    STOP            shift and go to state 125
    AVAILABLE_COMMANDS shift and go to state 126

    simprop                        shift and go to state 174

state 146

    (79) simprop -> EPISODES NUMBER .

    EPISODES        reduce using rule 79 (simprop -> EPISODES NUMBER .)
    MAX_ROUNDS      reduce using rule 79 (simprop -> EPISODES NUMBER .)
    ACTIONS_TIME    reduce using rule 79 (simprop -> EPISODES NUMBER .)
    STOP            reduce using rule 79 (simprop -> EPISODES NUMBER .)
    AVAILABLE_COMMANDS reduce using rule 79 (simprop -> EPISODES NUMBER .)
    }               reduce using rule 79 (simprop -> EPISODES NUMBER .)


state 147

    (80) simprop -> MAX_ROUNDS NUMBER .

    EPISODES        reduce using rule 80 (simprop -> MAX_ROUNDS NUMBER .)
    MAX_ROUNDS      reduce using rule 80 (simprop -> MAX_ROUNDS NUMBER .)
    ACTIONS_TIME    reduce using rule 80 (simprop -> MAX_ROUNDS NUMBER .)
    STOP            reduce using rule 80 (simprop -> MAX_ROUNDS NUMBER .)
    AVAILABLE_COMMANDS reduce using rule 80 (simprop -> MAX_ROUNDS NUMBER .)
    }               reduce using rule 80 (simprop -> MAX_ROUNDS NUMBER .)


state 148

    (81) simprop -> ACTIONS_TIME NUMBER .

    EPISODES        reduce using rule 81 (simprop -> ACTIONS_TIME NUMBER .)
    MAX_ROUNDS      reduce using rule 81 (simprop -> ACTIONS_TIME NUMBER .)
    ACTIONS_TIME    reduce using rule 81 (simprop -> ACTIONS_TIME NUMBER .)
    STOP            reduce using rule 81 (simprop -> ACTIONS_TIME NUMBER .)
    AVAILABLE_COMMANDS reduce using rule 81 (simprop -> ACTIONS_TIME NUMBER .)
    }               reduce using rule 81 (simprop -> ACTIONS_TIME NUMBER .)


state 149

    (82) simprop -> STOP SIMULATION . { stmt_list }

    {               shift and go to state 175


state 150

    (83) simprop -> AVAILABLE_COMMANDS { . command_list }
    (84) command_list -> . ID command_list
    (85) command_list -> . epsilon
    (2) epsilon -> .

    ID              shift and go to state 177
    }               reduce using rule 2 (epsilon -> .)

    command_list                   shift and go to state 176
    epsilon                        shift and go to state 178

state 151

    (63) world_stmt -> WORLD { worldprop worldprop } .

    SIMULATION      reduce using rule 63 (world_stmt -> WORLD { worldprop worldprop } .)


state 152

    (66) worldsize -> INFINITE { . worldsizeprop worldsizeprop }
    (68) worldsizeprop -> . WIDTH NUMBER
    (69) worldsizeprop -> . HEIGHT NUMBER

    WIDTH           shift and go to state 154
    HEIGHT          shift and go to state 155

    worldsizeprop                  shift and go to state 179

state 153

    (67) worldsize -> { worldsizeprop . worldsizeprop }
    (68) worldsizeprop -> . WIDTH NUMBER
    (69) worldsizeprop -> . HEIGHT NUMBER

    WIDTH           shift and go to state 154
    HEIGHT          shift and go to state 155

    worldsizeprop                  shift and go to state 180

state 154

    (68) worldsizeprop -> WIDTH . NUMBER

    NUMBER          shift and go to state 181


state 155

    (69) worldsizeprop -> HEIGHT . NUMBER

    NUMBER          shift and go to state 182


state 156

    (70) worldterrain -> { terrainprop_list . }

    }               shift and go to state 183


state 157

    (71) terrainprop_list -> terrainprop . terrainprop_list
    (71) terrainprop_list -> . terrainprop terrainprop_list
    (72) terrainprop_list -> . epsilon
    (73) terrainprop -> . ID
    (74) terrainprop -> . DEFAULT ID
    (75) terrainprop -> . ID AT { NUMBER terrainposn_list }
    (2) epsilon -> .

    ID              shift and go to state 159
    DEFAULT         shift and go to state 160
    }               reduce using rule 2 (epsilon -> .)

    terrainprop                    shift and go to state 157
    terrainprop_list               shift and go to state 184
    epsilon                        shift and go to state 158

state 158

    (72) terrainprop_list -> epsilon .

    }               reduce using rule 72 (terrainprop_list -> epsilon .)


state 159

    (73) terrainprop -> ID .
    (75) terrainprop -> ID . AT { NUMBER terrainposn_list }

    ID              reduce using rule 73 (terrainprop -> ID .)
    DEFAULT         reduce using rule 73 (terrainprop -> ID .)
    }               reduce using rule 73 (terrainprop -> ID .)
    AT              shift and go to state 185


state 160

    (74) terrainprop -> DEFAULT . ID

    ID              shift and go to state 186


state 161

    (51) entity_stmt -> ENTITY { entityprop entityprop entityprop } .

    ENTITY          reduce using rule 51 (entity_stmt -> ENTITY { entityprop entityprop entityprop } .)
    ORGANISM        reduce using rule 51 (entity_stmt -> ENTITY { entityprop entityprop entityprop } .)
    WORLD           reduce using rule 51 (entity_stmt -> ENTITY { entityprop entityprop entityprop } .)


state 162

    (60) position_list -> position . position_list
    (60) position_list -> . position position_list
    (61) position_list -> . epsilon
    (62) position -> . ( NUMBER NUMBER )
    (2) epsilon -> .

    (               shift and go to state 135
    }               reduce using rule 2 (epsilon -> .)

    position                       shift and go to state 162
    position_list                  shift and go to state 187
    epsilon                        shift and go to state 164

state 163

    (54) entityprop -> AT { position position_list . }

    }               shift and go to state 188


state 164

    (61) position_list -> epsilon .

    }               reduce using rule 61 (position_list -> epsilon .)


state 165

    (62) position -> ( NUMBER . NUMBER )

    NUMBER          shift and go to state 189


state 166

    (55) organism_stmt -> ORGANISM { orgprop orgprop orgprop orgprop . }

    }               shift and go to state 190


state 167

    (59) orgprop -> AT { position position_list . }

    }               shift and go to state 191


state 168

    (47) decide_stmt -> DECIDE ORGANISM TIME . { stmt_list }

    {               shift and go to state 192


state 169

    (89) param_list -> ID . param_list
    (89) param_list -> . ID param_list
    (90) param_list -> . epsilon
    (2) epsilon -> .

    ID              shift and go to state 169
    {               reduce using rule 2 (epsilon -> .)

    param_list                     shift and go to state 193
    epsilon                        shift and go to state 171

state 170

    (88) func_stmt -> FUNC ID = param_list . { stmt_list }

    {               shift and go to state 194


state 171

    (90) param_list -> epsilon .

    {               reduce using rule 90 (param_list -> epsilon .)


state 172

    (30) phygeneprop -> VALUE NUMBER IN { NUMBER . NUMBER }

    NUMBER          shift and go to state 195


state 173

    (31) phygeneprop -> MUTATION { mutationprop mutationprop } .

    VALUE           reduce using rule 31 (phygeneprop -> MUTATION { mutationprop mutationprop } .)
    MUTATION        reduce using rule 31 (phygeneprop -> MUTATION { mutationprop mutationprop } .)
    }               reduce using rule 31 (phygeneprop -> MUTATION { mutationprop mutationprop } .)


state 174

    (78) sim_stmt -> SIMULATION { simprop simprop simprop . simprop simprop }
    (79) simprop -> . EPISODES NUMBER
    (80) simprop -> . MAX_ROUNDS NUMBER
    (81) simprop -> . ACTIONS_TIME NUMBER
    (82) simprop -> . STOP SIMULATION { stmt_list }
    (83) simprop -> . AVAILABLE_COMMANDS { command_list }

    EPISODES        shift and go to state 122
    MAX_ROUNDS      shift and go to state 123
    ACTIONS_TIME    shift and go to state 124
    STOP            shift and go to state 125
    AVAILABLE_COMMANDS shift and go to state 126

    simprop                        shift and go to state 196

state 175

    (82) simprop -> STOP SIMULATION { . stmt_list }
    (91) stmt_list -> . stmt stmt_list
    (92) stmt_list -> . epsilon
    (93) stmt -> . if_stmt
    (94) stmt -> . var_stmt ;
    (95) stmt -> . index_stmt ;
    (96) stmt -> . loop_stmt
    (97) stmt -> . CONTINUE ;
    (98) stmt -> . BREAK ;
    (99) stmt -> . RETURN disjunction ;
    (100) stmt -> . RETURN ;
    (2) epsilon -> .
    (103) if_stmt -> . IF disjunction { stmt_list } else_stmt
    (101) var_stmt -> . accessing = disjunction
    (102) index_stmt -> . naming [ disjunction ] = disjunction
    (107) loop_stmt -> . LOOP loop_init , loop_condition , loop_set { stmt_list }
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (155) bool -> . TRUE
    (156) bool -> . FALSE

    CONTINUE        shift and go to state 206
    BREAK           shift and go to state 207
    RETURN          shift and go to state 208
    }               reduce using rule 2 (epsilon -> .)
    IF              shift and go to state 209
    LOOP            shift and go to state 213
    ID              shift and go to state 215
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103

    stmt_list                      shift and go to state 199
    stmt                           shift and go to state 200
    epsilon                        shift and go to state 201
    if_stmt                        shift and go to state 202
    var_stmt                       shift and go to state 203
    index_stmt                     shift and go to state 204
    loop_stmt                      shift and go to state 205
    accessing                      shift and go to state 210
    naming                         shift and go to state 211
    word                           shift and go to state 214
    atom                           shift and go to state 217
    bool                           shift and go to state 221

state 176

    (83) simprop -> AVAILABLE_COMMANDS { command_list . }

    }               shift and go to state 222


state 177

    (84) command_list -> ID . command_list
    (84) command_list -> . ID command_list
    (85) command_list -> . epsilon
    (2) epsilon -> .

    ID              shift and go to state 177
    }               reduce using rule 2 (epsilon -> .)

    command_list                   shift and go to state 223
    epsilon                        shift and go to state 178

state 178

    (85) command_list -> epsilon .

    }               reduce using rule 85 (command_list -> epsilon .)


state 179

    (66) worldsize -> INFINITE { worldsizeprop . worldsizeprop }
    (68) worldsizeprop -> . WIDTH NUMBER
    (69) worldsizeprop -> . HEIGHT NUMBER

    WIDTH           shift and go to state 154
    HEIGHT          shift and go to state 155

    worldsizeprop                  shift and go to state 224

state 180

    (67) worldsize -> { worldsizeprop worldsizeprop . }

    }               shift and go to state 225


state 181

    (68) worldsizeprop -> WIDTH NUMBER .

    WIDTH           reduce using rule 68 (worldsizeprop -> WIDTH NUMBER .)
    HEIGHT          reduce using rule 68 (worldsizeprop -> WIDTH NUMBER .)
    }               reduce using rule 68 (worldsizeprop -> WIDTH NUMBER .)


state 182

    (69) worldsizeprop -> HEIGHT NUMBER .

    WIDTH           reduce using rule 69 (worldsizeprop -> HEIGHT NUMBER .)
    HEIGHT          reduce using rule 69 (worldsizeprop -> HEIGHT NUMBER .)
    }               reduce using rule 69 (worldsizeprop -> HEIGHT NUMBER .)


state 183

    (70) worldterrain -> { terrainprop_list } .

    SIZE            reduce using rule 70 (worldterrain -> { terrainprop_list } .)
    TERRAIN         reduce using rule 70 (worldterrain -> { terrainprop_list } .)
    }               reduce using rule 70 (worldterrain -> { terrainprop_list } .)


state 184

    (71) terrainprop_list -> terrainprop terrainprop_list .

    }               reduce using rule 71 (terrainprop_list -> terrainprop terrainprop_list .)


state 185

    (75) terrainprop -> ID AT . { NUMBER terrainposn_list }

    {               shift and go to state 226


state 186

    (74) terrainprop -> DEFAULT ID .

    ID              reduce using rule 74 (terrainprop -> DEFAULT ID .)
    DEFAULT         reduce using rule 74 (terrainprop -> DEFAULT ID .)
    }               reduce using rule 74 (terrainprop -> DEFAULT ID .)


state 187

    (60) position_list -> position position_list .

    }               reduce using rule 60 (position_list -> position position_list .)


state 188

    (54) entityprop -> AT { position position_list } .

    COEXISTENCE     reduce using rule 54 (entityprop -> AT { position position_list } .)
    REPR            reduce using rule 54 (entityprop -> AT { position position_list } .)
    AT              reduce using rule 54 (entityprop -> AT { position position_list } .)
    }               reduce using rule 54 (entityprop -> AT { position position_list } .)


state 189

    (62) position -> ( NUMBER NUMBER . )

    )               shift and go to state 227


state 190

    (55) organism_stmt -> ORGANISM { orgprop orgprop orgprop orgprop } .

    ENTITY          reduce using rule 55 (organism_stmt -> ORGANISM { orgprop orgprop orgprop orgprop } .)
    ORGANISM        reduce using rule 55 (organism_stmt -> ORGANISM { orgprop orgprop orgprop orgprop } .)
    WORLD           reduce using rule 55 (organism_stmt -> ORGANISM { orgprop orgprop orgprop orgprop } .)


state 191

    (59) orgprop -> AT { position position_list } .

    DNA             reduce using rule 59 (orgprop -> AT { position position_list } .)
    BEHAVIOR        reduce using rule 59 (orgprop -> AT { position position_list } .)
    REPR            reduce using rule 59 (orgprop -> AT { position position_list } .)
    AT              reduce using rule 59 (orgprop -> AT { position position_list } .)
    }               reduce using rule 59 (orgprop -> AT { position position_list } .)


state 192

    (47) decide_stmt -> DECIDE ORGANISM TIME { . stmt_list }
    (91) stmt_list -> . stmt stmt_list
    (92) stmt_list -> . epsilon
    (93) stmt -> . if_stmt
    (94) stmt -> . var_stmt ;
    (95) stmt -> . index_stmt ;
    (96) stmt -> . loop_stmt
    (97) stmt -> . CONTINUE ;
    (98) stmt -> . BREAK ;
    (99) stmt -> . RETURN disjunction ;
    (100) stmt -> . RETURN ;
    (2) epsilon -> .
    (103) if_stmt -> . IF disjunction { stmt_list } else_stmt
    (101) var_stmt -> . accessing = disjunction
    (102) index_stmt -> . naming [ disjunction ] = disjunction
    (107) loop_stmt -> . LOOP loop_init , loop_condition , loop_set { stmt_list }
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (155) bool -> . TRUE
    (156) bool -> . FALSE

    CONTINUE        shift and go to state 206
    BREAK           shift and go to state 207
    RETURN          shift and go to state 208
    }               reduce using rule 2 (epsilon -> .)
    IF              shift and go to state 209
    LOOP            shift and go to state 213
    ID              shift and go to state 215
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103

    stmt_list                      shift and go to state 228
    stmt                           shift and go to state 200
    epsilon                        shift and go to state 201
    if_stmt                        shift and go to state 202
    var_stmt                       shift and go to state 203
    index_stmt                     shift and go to state 204
    loop_stmt                      shift and go to state 205
    accessing                      shift and go to state 210
    naming                         shift and go to state 211
    word                           shift and go to state 214
    atom                           shift and go to state 217
    bool                           shift and go to state 221

state 193

    (89) param_list -> ID param_list .

    {               reduce using rule 89 (param_list -> ID param_list .)


state 194

    (88) func_stmt -> FUNC ID = param_list { . stmt_list }
    (91) stmt_list -> . stmt stmt_list
    (92) stmt_list -> . epsilon
    (93) stmt -> . if_stmt
    (94) stmt -> . var_stmt ;
    (95) stmt -> . index_stmt ;
    (96) stmt -> . loop_stmt
    (97) stmt -> . CONTINUE ;
    (98) stmt -> . BREAK ;
    (99) stmt -> . RETURN disjunction ;
    (100) stmt -> . RETURN ;
    (2) epsilon -> .
    (103) if_stmt -> . IF disjunction { stmt_list } else_stmt
    (101) var_stmt -> . accessing = disjunction
    (102) index_stmt -> . naming [ disjunction ] = disjunction
    (107) loop_stmt -> . LOOP loop_init , loop_condition , loop_set { stmt_list }
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (155) bool -> . TRUE
    (156) bool -> . FALSE

    CONTINUE        shift and go to state 206
    BREAK           shift and go to state 207
    RETURN          shift and go to state 208
    }               reduce using rule 2 (epsilon -> .)
    IF              shift and go to state 209
    LOOP            shift and go to state 213
    ID              shift and go to state 215
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103

    stmt_list                      shift and go to state 229
    stmt                           shift and go to state 200
    epsilon                        shift and go to state 201
    if_stmt                        shift and go to state 202
    var_stmt                       shift and go to state 203
    index_stmt                     shift and go to state 204
    loop_stmt                      shift and go to state 205
    accessing                      shift and go to state 210
    naming                         shift and go to state 211
    word                           shift and go to state 214
    atom                           shift and go to state 217
    bool                           shift and go to state 221

state 195

    (30) phygeneprop -> VALUE NUMBER IN { NUMBER NUMBER . }

    }               shift and go to state 230


state 196

    (78) sim_stmt -> SIMULATION { simprop simprop simprop simprop . simprop }
    (79) simprop -> . EPISODES NUMBER
    (80) simprop -> . MAX_ROUNDS NUMBER
    (81) simprop -> . ACTIONS_TIME NUMBER
    (82) simprop -> . STOP SIMULATION { stmt_list }
    (83) simprop -> . AVAILABLE_COMMANDS { command_list }

    EPISODES        shift and go to state 122
    MAX_ROUNDS      shift and go to state 123
    ACTIONS_TIME    shift and go to state 124
    STOP            shift and go to state 125
    AVAILABLE_COMMANDS shift and go to state 126

    simprop                        shift and go to state 231

state 197

    (154) word -> SIMULATION .

    .               reduce using rule 154 (word -> SIMULATION .)
    =               reduce using rule 154 (word -> SIMULATION .)
    [               reduce using rule 154 (word -> SIMULATION .)
    *               reduce using rule 154 (word -> SIMULATION .)
    /               reduce using rule 154 (word -> SIMULATION .)
    %               reduce using rule 154 (word -> SIMULATION .)
    INTDIV          reduce using rule 154 (word -> SIMULATION .)
    EQ              reduce using rule 154 (word -> SIMULATION .)
    NEQ             reduce using rule 154 (word -> SIMULATION .)
    GE              reduce using rule 154 (word -> SIMULATION .)
    LE              reduce using rule 154 (word -> SIMULATION .)
    >               reduce using rule 154 (word -> SIMULATION .)
    <               reduce using rule 154 (word -> SIMULATION .)
    +               reduce using rule 154 (word -> SIMULATION .)
    -               reduce using rule 154 (word -> SIMULATION .)
    AND             reduce using rule 154 (word -> SIMULATION .)
    OR              reduce using rule 154 (word -> SIMULATION .)
    ;               reduce using rule 154 (word -> SIMULATION .)
    {               reduce using rule 154 (word -> SIMULATION .)
    ,               reduce using rule 154 (word -> SIMULATION .)
    ]               reduce using rule 154 (word -> SIMULATION .)
    )               reduce using rule 154 (word -> SIMULATION .)
    }               reduce using rule 154 (word -> SIMULATION .)


state 198

    (149) atom -> { . keyarg_list }
    (160) keyarg_list -> . keyarg
    (161) keyarg_list -> . keyarg , keyarg_list
    (162) keyarg_list -> . epsilon
    (163) keyarg -> . disjunction = disjunction
    (2) epsilon -> .
    (114) disjunction -> . conjunction OR conjunction
    (115) disjunction -> . conjunction
    (116) conjunction -> . negation AND negation
    (117) conjunction -> . negation
    (118) negation -> . NOT comparison
    (119) negation -> . comparison
    (120) comparison -> . expr EQ expr
    (121) comparison -> . expr NEQ expr
    (122) comparison -> . expr GE expr
    (123) comparison -> . expr LE expr
    (124) comparison -> . expr > expr
    (125) comparison -> . expr < expr
    (126) comparison -> . expr
    (127) expr -> . expr + term
    (128) expr -> . expr - term
    (129) expr -> . term
    (130) term -> . term * factor
    (131) term -> . term / factor
    (132) term -> . term % factor
    (133) term -> . term INTDIV factor
    (134) term -> . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    }               reduce using rule 2 (epsilon -> .)
    NOT             shift and go to state 238
    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    keyarg_list                    shift and go to state 232
    keyarg                         shift and go to state 233
    epsilon                        shift and go to state 234
    disjunction                    shift and go to state 235
    conjunction                    shift and go to state 236
    negation                       shift and go to state 237
    comparison                     shift and go to state 239
    expr                           shift and go to state 240
    term                           shift and go to state 241
    factor                         shift and go to state 243
    power                          shift and go to state 244
    atom                           shift and go to state 245
    naming                         shift and go to state 246
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 199

    (82) simprop -> STOP SIMULATION { stmt_list . }

    }               shift and go to state 248


state 200

    (91) stmt_list -> stmt . stmt_list
    (91) stmt_list -> . stmt stmt_list
    (92) stmt_list -> . epsilon
    (93) stmt -> . if_stmt
    (94) stmt -> . var_stmt ;
    (95) stmt -> . index_stmt ;
    (96) stmt -> . loop_stmt
    (97) stmt -> . CONTINUE ;
    (98) stmt -> . BREAK ;
    (99) stmt -> . RETURN disjunction ;
    (100) stmt -> . RETURN ;
    (2) epsilon -> .
    (103) if_stmt -> . IF disjunction { stmt_list } else_stmt
    (101) var_stmt -> . accessing = disjunction
    (102) index_stmt -> . naming [ disjunction ] = disjunction
    (107) loop_stmt -> . LOOP loop_init , loop_condition , loop_set { stmt_list }
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (155) bool -> . TRUE
    (156) bool -> . FALSE

    CONTINUE        shift and go to state 206
    BREAK           shift and go to state 207
    RETURN          shift and go to state 208
    }               reduce using rule 2 (epsilon -> .)
    IF              shift and go to state 209
    LOOP            shift and go to state 213
    ID              shift and go to state 215
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103

    stmt                           shift and go to state 200
    stmt_list                      shift and go to state 249
    epsilon                        shift and go to state 201
    if_stmt                        shift and go to state 202
    var_stmt                       shift and go to state 203
    index_stmt                     shift and go to state 204
    loop_stmt                      shift and go to state 205
    accessing                      shift and go to state 210
    naming                         shift and go to state 211
    word                           shift and go to state 214
    atom                           shift and go to state 217
    bool                           shift and go to state 221

state 201

    (92) stmt_list -> epsilon .

    }               reduce using rule 92 (stmt_list -> epsilon .)


state 202

    (93) stmt -> if_stmt .

    CONTINUE        reduce using rule 93 (stmt -> if_stmt .)
    BREAK           reduce using rule 93 (stmt -> if_stmt .)
    RETURN          reduce using rule 93 (stmt -> if_stmt .)
    IF              reduce using rule 93 (stmt -> if_stmt .)
    LOOP            reduce using rule 93 (stmt -> if_stmt .)
    ID              reduce using rule 93 (stmt -> if_stmt .)
    ORGANISM        reduce using rule 93 (stmt -> if_stmt .)
    SIMULATION      reduce using rule 93 (stmt -> if_stmt .)
    NUMBER          reduce using rule 93 (stmt -> if_stmt .)
    STRING          reduce using rule 93 (stmt -> if_stmt .)
    (               reduce using rule 93 (stmt -> if_stmt .)
    [               reduce using rule 93 (stmt -> if_stmt .)
    {               reduce using rule 93 (stmt -> if_stmt .)
    TRUE            reduce using rule 93 (stmt -> if_stmt .)
    FALSE           reduce using rule 93 (stmt -> if_stmt .)
    }               reduce using rule 93 (stmt -> if_stmt .)


state 203

    (94) stmt -> var_stmt . ;

    ;               shift and go to state 250


state 204

    (95) stmt -> index_stmt . ;

    ;               shift and go to state 251


state 205

    (96) stmt -> loop_stmt .

    CONTINUE        reduce using rule 96 (stmt -> loop_stmt .)
    BREAK           reduce using rule 96 (stmt -> loop_stmt .)
    RETURN          reduce using rule 96 (stmt -> loop_stmt .)
    IF              reduce using rule 96 (stmt -> loop_stmt .)
    LOOP            reduce using rule 96 (stmt -> loop_stmt .)
    ID              reduce using rule 96 (stmt -> loop_stmt .)
    ORGANISM        reduce using rule 96 (stmt -> loop_stmt .)
    SIMULATION      reduce using rule 96 (stmt -> loop_stmt .)
    NUMBER          reduce using rule 96 (stmt -> loop_stmt .)
    STRING          reduce using rule 96 (stmt -> loop_stmt .)
    (               reduce using rule 96 (stmt -> loop_stmt .)
    [               reduce using rule 96 (stmt -> loop_stmt .)
    {               reduce using rule 96 (stmt -> loop_stmt .)
    TRUE            reduce using rule 96 (stmt -> loop_stmt .)
    FALSE           reduce using rule 96 (stmt -> loop_stmt .)
    }               reduce using rule 96 (stmt -> loop_stmt .)


state 206

    (97) stmt -> CONTINUE . ;

    ;               shift and go to state 252


state 207

    (98) stmt -> BREAK . ;

    ;               shift and go to state 253


state 208

    (99) stmt -> RETURN . disjunction ;
    (100) stmt -> RETURN . ;
    (114) disjunction -> . conjunction OR conjunction
    (115) disjunction -> . conjunction
    (116) conjunction -> . negation AND negation
    (117) conjunction -> . negation
    (118) negation -> . NOT comparison
    (119) negation -> . comparison
    (120) comparison -> . expr EQ expr
    (121) comparison -> . expr NEQ expr
    (122) comparison -> . expr GE expr
    (123) comparison -> . expr LE expr
    (124) comparison -> . expr > expr
    (125) comparison -> . expr < expr
    (126) comparison -> . expr
    (127) expr -> . expr + term
    (128) expr -> . expr - term
    (129) expr -> . term
    (130) term -> . term * factor
    (131) term -> . term / factor
    (132) term -> . term % factor
    (133) term -> . term INTDIV factor
    (134) term -> . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    ;               shift and go to state 255
    NOT             shift and go to state 238
    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    disjunction                    shift and go to state 254
    conjunction                    shift and go to state 236
    negation                       shift and go to state 237
    comparison                     shift and go to state 239
    expr                           shift and go to state 240
    term                           shift and go to state 241
    factor                         shift and go to state 243
    power                          shift and go to state 244
    atom                           shift and go to state 245
    naming                         shift and go to state 246
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 209

    (103) if_stmt -> IF . disjunction { stmt_list } else_stmt
    (114) disjunction -> . conjunction OR conjunction
    (115) disjunction -> . conjunction
    (116) conjunction -> . negation AND negation
    (117) conjunction -> . negation
    (118) negation -> . NOT comparison
    (119) negation -> . comparison
    (120) comparison -> . expr EQ expr
    (121) comparison -> . expr NEQ expr
    (122) comparison -> . expr GE expr
    (123) comparison -> . expr LE expr
    (124) comparison -> . expr > expr
    (125) comparison -> . expr < expr
    (126) comparison -> . expr
    (127) expr -> . expr + term
    (128) expr -> . expr - term
    (129) expr -> . term
    (130) term -> . term * factor
    (131) term -> . term / factor
    (132) term -> . term % factor
    (133) term -> . term INTDIV factor
    (134) term -> . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    NOT             shift and go to state 238
    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    disjunction                    shift and go to state 256
    conjunction                    shift and go to state 236
    negation                       shift and go to state 237
    comparison                     shift and go to state 239
    expr                           shift and go to state 240
    term                           shift and go to state 241
    factor                         shift and go to state 243
    power                          shift and go to state 244
    atom                           shift and go to state 245
    naming                         shift and go to state 246
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 210

    (101) var_stmt -> accessing . = disjunction
    (141) naming -> accessing .

    =               shift and go to state 257
    [               reduce using rule 141 (naming -> accessing .)


state 211

    (102) index_stmt -> naming . [ disjunction ] = disjunction
    (140) naming -> naming . [ disjunction ]

    [               shift and go to state 258


state 212

    (148) atom -> [ . arg_list ]
    (157) arg_list -> . disjunction
    (158) arg_list -> . disjunction , arg_list
    (159) arg_list -> . epsilon
    (114) disjunction -> . conjunction OR conjunction
    (115) disjunction -> . conjunction
    (2) epsilon -> .
    (116) conjunction -> . negation AND negation
    (117) conjunction -> . negation
    (118) negation -> . NOT comparison
    (119) negation -> . comparison
    (120) comparison -> . expr EQ expr
    (121) comparison -> . expr NEQ expr
    (122) comparison -> . expr GE expr
    (123) comparison -> . expr LE expr
    (124) comparison -> . expr > expr
    (125) comparison -> . expr < expr
    (126) comparison -> . expr
    (127) expr -> . expr + term
    (128) expr -> . expr - term
    (129) expr -> . term
    (130) term -> . term * factor
    (131) term -> . term / factor
    (132) term -> . term % factor
    (133) term -> . term INTDIV factor
    (134) term -> . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    ]               reduce using rule 2 (epsilon -> .)
    NOT             shift and go to state 238
    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    arg_list                       shift and go to state 259
    disjunction                    shift and go to state 260
    epsilon                        shift and go to state 261
    conjunction                    shift and go to state 236
    negation                       shift and go to state 237
    comparison                     shift and go to state 239
    expr                           shift and go to state 240
    term                           shift and go to state 241
    factor                         shift and go to state 243
    power                          shift and go to state 244
    atom                           shift and go to state 245
    naming                         shift and go to state 246
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 213

    (107) loop_stmt -> LOOP . loop_init , loop_condition , loop_set { stmt_list }
    (108) loop_init -> . var_stmt
    (109) loop_init -> . epsilon
    (101) var_stmt -> . accessing = disjunction
    (2) epsilon -> .
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    ,               reduce using rule 2 (epsilon -> .)
    ID              shift and go to state 266
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    loop_init                      shift and go to state 262
    var_stmt                       shift and go to state 263
    epsilon                        shift and go to state 264
    accessing                      shift and go to state 265
    word                           shift and go to state 214

state 214

    (150) accessing -> word .
    (151) accessing -> word . . accessing

    =               reduce using rule 150 (accessing -> word .)
    [               reduce using rule 150 (accessing -> word .)
    *               reduce using rule 150 (accessing -> word .)
    /               reduce using rule 150 (accessing -> word .)
    %               reduce using rule 150 (accessing -> word .)
    INTDIV          reduce using rule 150 (accessing -> word .)
    EQ              reduce using rule 150 (accessing -> word .)
    NEQ             reduce using rule 150 (accessing -> word .)
    GE              reduce using rule 150 (accessing -> word .)
    LE              reduce using rule 150 (accessing -> word .)
    >               reduce using rule 150 (accessing -> word .)
    <               reduce using rule 150 (accessing -> word .)
    +               reduce using rule 150 (accessing -> word .)
    -               reduce using rule 150 (accessing -> word .)
    AND             reduce using rule 150 (accessing -> word .)
    OR              reduce using rule 150 (accessing -> word .)
    ;               reduce using rule 150 (accessing -> word .)
    {               reduce using rule 150 (accessing -> word .)
    ,               reduce using rule 150 (accessing -> word .)
    ]               reduce using rule 150 (accessing -> word .)
    )               reduce using rule 150 (accessing -> word .)
    }               reduce using rule 150 (accessing -> word .)
    .               shift and go to state 267


state 215

    (142) naming -> ID . ( arg_list )
    (152) word -> ID .

    (               shift and go to state 268
    .               reduce using rule 152 (word -> ID .)
    =               reduce using rule 152 (word -> ID .)
    [               reduce using rule 152 (word -> ID .)
    *               reduce using rule 152 (word -> ID .)
    /               reduce using rule 152 (word -> ID .)
    %               reduce using rule 152 (word -> ID .)
    INTDIV          reduce using rule 152 (word -> ID .)
    EQ              reduce using rule 152 (word -> ID .)
    NEQ             reduce using rule 152 (word -> ID .)
    GE              reduce using rule 152 (word -> ID .)
    LE              reduce using rule 152 (word -> ID .)
    >               reduce using rule 152 (word -> ID .)
    <               reduce using rule 152 (word -> ID .)
    +               reduce using rule 152 (word -> ID .)
    -               reduce using rule 152 (word -> ID .)
    AND             reduce using rule 152 (word -> ID .)
    OR              reduce using rule 152 (word -> ID .)
    ;               reduce using rule 152 (word -> ID .)
    {               reduce using rule 152 (word -> ID .)
    ,               reduce using rule 152 (word -> ID .)
    ]               reduce using rule 152 (word -> ID .)
    )               reduce using rule 152 (word -> ID .)
    }               reduce using rule 152 (word -> ID .)


state 216

    (147) atom -> ( . expr )
    (127) expr -> . expr + term
    (128) expr -> . expr - term
    (129) expr -> . term
    (130) term -> . term * factor
    (131) term -> . term / factor
    (132) term -> . term % factor
    (133) term -> . term INTDIV factor
    (134) term -> . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    expr                           shift and go to state 269
    term                           shift and go to state 241
    factor                         shift and go to state 243
    power                          shift and go to state 244
    atom                           shift and go to state 245
    naming                         shift and go to state 246
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 217

    (143) naming -> atom .

    [               reduce using rule 143 (naming -> atom .)


state 218

    (153) word -> ORGANISM .

    .               reduce using rule 153 (word -> ORGANISM .)
    =               reduce using rule 153 (word -> ORGANISM .)
    [               reduce using rule 153 (word -> ORGANISM .)
    *               reduce using rule 153 (word -> ORGANISM .)
    /               reduce using rule 153 (word -> ORGANISM .)
    %               reduce using rule 153 (word -> ORGANISM .)
    INTDIV          reduce using rule 153 (word -> ORGANISM .)
    EQ              reduce using rule 153 (word -> ORGANISM .)
    NEQ             reduce using rule 153 (word -> ORGANISM .)
    GE              reduce using rule 153 (word -> ORGANISM .)
    LE              reduce using rule 153 (word -> ORGANISM .)
    >               reduce using rule 153 (word -> ORGANISM .)
    <               reduce using rule 153 (word -> ORGANISM .)
    +               reduce using rule 153 (word -> ORGANISM .)
    -               reduce using rule 153 (word -> ORGANISM .)
    AND             reduce using rule 153 (word -> ORGANISM .)
    OR              reduce using rule 153 (word -> ORGANISM .)
    ;               reduce using rule 153 (word -> ORGANISM .)
    {               reduce using rule 153 (word -> ORGANISM .)
    ,               reduce using rule 153 (word -> ORGANISM .)
    ]               reduce using rule 153 (word -> ORGANISM .)
    )               reduce using rule 153 (word -> ORGANISM .)
    }               reduce using rule 153 (word -> ORGANISM .)


state 219

    (144) atom -> NUMBER .

    [               reduce using rule 144 (atom -> NUMBER .)
    ^               reduce using rule 144 (atom -> NUMBER .)
    @               reduce using rule 144 (atom -> NUMBER .)
    *               reduce using rule 144 (atom -> NUMBER .)
    /               reduce using rule 144 (atom -> NUMBER .)
    %               reduce using rule 144 (atom -> NUMBER .)
    INTDIV          reduce using rule 144 (atom -> NUMBER .)
    EQ              reduce using rule 144 (atom -> NUMBER .)
    NEQ             reduce using rule 144 (atom -> NUMBER .)
    GE              reduce using rule 144 (atom -> NUMBER .)
    LE              reduce using rule 144 (atom -> NUMBER .)
    >               reduce using rule 144 (atom -> NUMBER .)
    <               reduce using rule 144 (atom -> NUMBER .)
    +               reduce using rule 144 (atom -> NUMBER .)
    -               reduce using rule 144 (atom -> NUMBER .)
    AND             reduce using rule 144 (atom -> NUMBER .)
    OR              reduce using rule 144 (atom -> NUMBER .)
    =               reduce using rule 144 (atom -> NUMBER .)
    ;               reduce using rule 144 (atom -> NUMBER .)
    {               reduce using rule 144 (atom -> NUMBER .)
    ,               reduce using rule 144 (atom -> NUMBER .)
    ]               reduce using rule 144 (atom -> NUMBER .)
    )               reduce using rule 144 (atom -> NUMBER .)
    }               reduce using rule 144 (atom -> NUMBER .)


state 220

    (145) atom -> STRING .

    [               reduce using rule 145 (atom -> STRING .)
    ^               reduce using rule 145 (atom -> STRING .)
    @               reduce using rule 145 (atom -> STRING .)
    *               reduce using rule 145 (atom -> STRING .)
    /               reduce using rule 145 (atom -> STRING .)
    %               reduce using rule 145 (atom -> STRING .)
    INTDIV          reduce using rule 145 (atom -> STRING .)
    EQ              reduce using rule 145 (atom -> STRING .)
    NEQ             reduce using rule 145 (atom -> STRING .)
    GE              reduce using rule 145 (atom -> STRING .)
    LE              reduce using rule 145 (atom -> STRING .)
    >               reduce using rule 145 (atom -> STRING .)
    <               reduce using rule 145 (atom -> STRING .)
    +               reduce using rule 145 (atom -> STRING .)
    -               reduce using rule 145 (atom -> STRING .)
    AND             reduce using rule 145 (atom -> STRING .)
    OR              reduce using rule 145 (atom -> STRING .)
    =               reduce using rule 145 (atom -> STRING .)
    ;               reduce using rule 145 (atom -> STRING .)
    {               reduce using rule 145 (atom -> STRING .)
    ,               reduce using rule 145 (atom -> STRING .)
    ]               reduce using rule 145 (atom -> STRING .)
    )               reduce using rule 145 (atom -> STRING .)
    }               reduce using rule 145 (atom -> STRING .)


state 221

    (146) atom -> bool .

    [               reduce using rule 146 (atom -> bool .)
    ^               reduce using rule 146 (atom -> bool .)
    @               reduce using rule 146 (atom -> bool .)
    *               reduce using rule 146 (atom -> bool .)
    /               reduce using rule 146 (atom -> bool .)
    %               reduce using rule 146 (atom -> bool .)
    INTDIV          reduce using rule 146 (atom -> bool .)
    EQ              reduce using rule 146 (atom -> bool .)
    NEQ             reduce using rule 146 (atom -> bool .)
    GE              reduce using rule 146 (atom -> bool .)
    LE              reduce using rule 146 (atom -> bool .)
    >               reduce using rule 146 (atom -> bool .)
    <               reduce using rule 146 (atom -> bool .)
    +               reduce using rule 146 (atom -> bool .)
    -               reduce using rule 146 (atom -> bool .)
    AND             reduce using rule 146 (atom -> bool .)
    OR              reduce using rule 146 (atom -> bool .)
    =               reduce using rule 146 (atom -> bool .)
    ;               reduce using rule 146 (atom -> bool .)
    {               reduce using rule 146 (atom -> bool .)
    ,               reduce using rule 146 (atom -> bool .)
    ]               reduce using rule 146 (atom -> bool .)
    )               reduce using rule 146 (atom -> bool .)
    }               reduce using rule 146 (atom -> bool .)


state 222

    (83) simprop -> AVAILABLE_COMMANDS { command_list } .

    EPISODES        reduce using rule 83 (simprop -> AVAILABLE_COMMANDS { command_list } .)
    MAX_ROUNDS      reduce using rule 83 (simprop -> AVAILABLE_COMMANDS { command_list } .)
    ACTIONS_TIME    reduce using rule 83 (simprop -> AVAILABLE_COMMANDS { command_list } .)
    STOP            reduce using rule 83 (simprop -> AVAILABLE_COMMANDS { command_list } .)
    AVAILABLE_COMMANDS reduce using rule 83 (simprop -> AVAILABLE_COMMANDS { command_list } .)
    }               reduce using rule 83 (simprop -> AVAILABLE_COMMANDS { command_list } .)


state 223

    (84) command_list -> ID command_list .

    }               reduce using rule 84 (command_list -> ID command_list .)


state 224

    (66) worldsize -> INFINITE { worldsizeprop worldsizeprop . }

    }               shift and go to state 270


state 225

    (67) worldsize -> { worldsizeprop worldsizeprop } .

    SIZE            reduce using rule 67 (worldsize -> { worldsizeprop worldsizeprop } .)
    TERRAIN         reduce using rule 67 (worldsize -> { worldsizeprop worldsizeprop } .)
    }               reduce using rule 67 (worldsize -> { worldsizeprop worldsizeprop } .)


state 226

    (75) terrainprop -> ID AT { . NUMBER terrainposn_list }

    NUMBER          shift and go to state 271


state 227

    (62) position -> ( NUMBER NUMBER ) .

    (               reduce using rule 62 (position -> ( NUMBER NUMBER ) .)
    }               reduce using rule 62 (position -> ( NUMBER NUMBER ) .)


state 228

    (47) decide_stmt -> DECIDE ORGANISM TIME { stmt_list . }

    }               shift and go to state 272


state 229

    (88) func_stmt -> FUNC ID = param_list { stmt_list . }

    }               shift and go to state 273


state 230

    (30) phygeneprop -> VALUE NUMBER IN { NUMBER NUMBER } .

    VALUE           reduce using rule 30 (phygeneprop -> VALUE NUMBER IN { NUMBER NUMBER } .)
    MUTATION        reduce using rule 30 (phygeneprop -> VALUE NUMBER IN { NUMBER NUMBER } .)
    }               reduce using rule 30 (phygeneprop -> VALUE NUMBER IN { NUMBER NUMBER } .)


state 231

    (78) sim_stmt -> SIMULATION { simprop simprop simprop simprop simprop . }

    }               shift and go to state 274


state 232

    (149) atom -> { keyarg_list . }

    }               shift and go to state 275


state 233

    (160) keyarg_list -> keyarg .
    (161) keyarg_list -> keyarg . , keyarg_list

    }               reduce using rule 160 (keyarg_list -> keyarg .)
    ,               shift and go to state 276


state 234

    (162) keyarg_list -> epsilon .

    }               reduce using rule 162 (keyarg_list -> epsilon .)


state 235

    (163) keyarg -> disjunction . = disjunction

    =               shift and go to state 277


state 236

    (114) disjunction -> conjunction . OR conjunction
    (115) disjunction -> conjunction .

    OR              shift and go to state 278
    =               reduce using rule 115 (disjunction -> conjunction .)
    ;               reduce using rule 115 (disjunction -> conjunction .)
    {               reduce using rule 115 (disjunction -> conjunction .)
    ,               reduce using rule 115 (disjunction -> conjunction .)
    ]               reduce using rule 115 (disjunction -> conjunction .)
    )               reduce using rule 115 (disjunction -> conjunction .)
    }               reduce using rule 115 (disjunction -> conjunction .)


state 237

    (116) conjunction -> negation . AND negation
    (117) conjunction -> negation .

    AND             shift and go to state 279
    OR              reduce using rule 117 (conjunction -> negation .)
    =               reduce using rule 117 (conjunction -> negation .)
    ;               reduce using rule 117 (conjunction -> negation .)
    {               reduce using rule 117 (conjunction -> negation .)
    ,               reduce using rule 117 (conjunction -> negation .)
    ]               reduce using rule 117 (conjunction -> negation .)
    )               reduce using rule 117 (conjunction -> negation .)
    }               reduce using rule 117 (conjunction -> negation .)


state 238

    (118) negation -> NOT . comparison
    (120) comparison -> . expr EQ expr
    (121) comparison -> . expr NEQ expr
    (122) comparison -> . expr GE expr
    (123) comparison -> . expr LE expr
    (124) comparison -> . expr > expr
    (125) comparison -> . expr < expr
    (126) comparison -> . expr
    (127) expr -> . expr + term
    (128) expr -> . expr - term
    (129) expr -> . term
    (130) term -> . term * factor
    (131) term -> . term / factor
    (132) term -> . term % factor
    (133) term -> . term INTDIV factor
    (134) term -> . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    comparison                     shift and go to state 280
    expr                           shift and go to state 240
    term                           shift and go to state 241
    factor                         shift and go to state 243
    power                          shift and go to state 244
    atom                           shift and go to state 245
    naming                         shift and go to state 246
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 239

    (119) negation -> comparison .

    AND             reduce using rule 119 (negation -> comparison .)
    OR              reduce using rule 119 (negation -> comparison .)
    =               reduce using rule 119 (negation -> comparison .)
    ;               reduce using rule 119 (negation -> comparison .)
    {               reduce using rule 119 (negation -> comparison .)
    ,               reduce using rule 119 (negation -> comparison .)
    ]               reduce using rule 119 (negation -> comparison .)
    )               reduce using rule 119 (negation -> comparison .)
    }               reduce using rule 119 (negation -> comparison .)


state 240

    (120) comparison -> expr . EQ expr
    (121) comparison -> expr . NEQ expr
    (122) comparison -> expr . GE expr
    (123) comparison -> expr . LE expr
    (124) comparison -> expr . > expr
    (125) comparison -> expr . < expr
    (126) comparison -> expr .
    (127) expr -> expr . + term
    (128) expr -> expr . - term

    EQ              shift and go to state 281
    NEQ             shift and go to state 282
    GE              shift and go to state 283
    LE              shift and go to state 284
    >               shift and go to state 285
    <               shift and go to state 286
    AND             reduce using rule 126 (comparison -> expr .)
    OR              reduce using rule 126 (comparison -> expr .)
    =               reduce using rule 126 (comparison -> expr .)
    ;               reduce using rule 126 (comparison -> expr .)
    {               reduce using rule 126 (comparison -> expr .)
    ,               reduce using rule 126 (comparison -> expr .)
    ]               reduce using rule 126 (comparison -> expr .)
    )               reduce using rule 126 (comparison -> expr .)
    }               reduce using rule 126 (comparison -> expr .)
    +               shift and go to state 287
    -               shift and go to state 288


state 241

    (129) expr -> term .
    (130) term -> term . * factor
    (131) term -> term . / factor
    (132) term -> term . % factor
    (133) term -> term . INTDIV factor

    EQ              reduce using rule 129 (expr -> term .)
    NEQ             reduce using rule 129 (expr -> term .)
    GE              reduce using rule 129 (expr -> term .)
    LE              reduce using rule 129 (expr -> term .)
    >               reduce using rule 129 (expr -> term .)
    <               reduce using rule 129 (expr -> term .)
    +               reduce using rule 129 (expr -> term .)
    -               reduce using rule 129 (expr -> term .)
    AND             reduce using rule 129 (expr -> term .)
    OR              reduce using rule 129 (expr -> term .)
    =               reduce using rule 129 (expr -> term .)
    ;               reduce using rule 129 (expr -> term .)
    {               reduce using rule 129 (expr -> term .)
    ,               reduce using rule 129 (expr -> term .)
    ]               reduce using rule 129 (expr -> term .)
    )               reduce using rule 129 (expr -> term .)
    }               reduce using rule 129 (expr -> term .)
    *               shift and go to state 289
    /               shift and go to state 290
    %               shift and go to state 291
    INTDIV          shift and go to state 292


state 242

    (135) factor -> - . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    factor                         shift and go to state 293
    power                          shift and go to state 244
    atom                           shift and go to state 245
    naming                         shift and go to state 246
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 243

    (134) term -> factor .

    *               reduce using rule 134 (term -> factor .)
    /               reduce using rule 134 (term -> factor .)
    %               reduce using rule 134 (term -> factor .)
    INTDIV          reduce using rule 134 (term -> factor .)
    EQ              reduce using rule 134 (term -> factor .)
    NEQ             reduce using rule 134 (term -> factor .)
    GE              reduce using rule 134 (term -> factor .)
    LE              reduce using rule 134 (term -> factor .)
    >               reduce using rule 134 (term -> factor .)
    <               reduce using rule 134 (term -> factor .)
    +               reduce using rule 134 (term -> factor .)
    -               reduce using rule 134 (term -> factor .)
    AND             reduce using rule 134 (term -> factor .)
    OR              reduce using rule 134 (term -> factor .)
    =               reduce using rule 134 (term -> factor .)
    ;               reduce using rule 134 (term -> factor .)
    {               reduce using rule 134 (term -> factor .)
    ,               reduce using rule 134 (term -> factor .)
    ]               reduce using rule 134 (term -> factor .)
    )               reduce using rule 134 (term -> factor .)
    }               reduce using rule 134 (term -> factor .)


state 244

    (136) factor -> power .

    *               reduce using rule 136 (factor -> power .)
    /               reduce using rule 136 (factor -> power .)
    %               reduce using rule 136 (factor -> power .)
    INTDIV          reduce using rule 136 (factor -> power .)
    EQ              reduce using rule 136 (factor -> power .)
    NEQ             reduce using rule 136 (factor -> power .)
    GE              reduce using rule 136 (factor -> power .)
    LE              reduce using rule 136 (factor -> power .)
    >               reduce using rule 136 (factor -> power .)
    <               reduce using rule 136 (factor -> power .)
    +               reduce using rule 136 (factor -> power .)
    -               reduce using rule 136 (factor -> power .)
    AND             reduce using rule 136 (factor -> power .)
    OR              reduce using rule 136 (factor -> power .)
    =               reduce using rule 136 (factor -> power .)
    ;               reduce using rule 136 (factor -> power .)
    {               reduce using rule 136 (factor -> power .)
    ,               reduce using rule 136 (factor -> power .)
    ]               reduce using rule 136 (factor -> power .)
    )               reduce using rule 136 (factor -> power .)
    }               reduce using rule 136 (factor -> power .)


state 245

    (137) power -> atom . ^ factor
    (138) power -> atom . @ factor
    (143) naming -> atom .

    ^               shift and go to state 294
    @               shift and go to state 295
    [               reduce using rule 143 (naming -> atom .)
    *               reduce using rule 143 (naming -> atom .)
    /               reduce using rule 143 (naming -> atom .)
    %               reduce using rule 143 (naming -> atom .)
    INTDIV          reduce using rule 143 (naming -> atom .)
    EQ              reduce using rule 143 (naming -> atom .)
    NEQ             reduce using rule 143 (naming -> atom .)
    GE              reduce using rule 143 (naming -> atom .)
    LE              reduce using rule 143 (naming -> atom .)
    >               reduce using rule 143 (naming -> atom .)
    <               reduce using rule 143 (naming -> atom .)
    +               reduce using rule 143 (naming -> atom .)
    -               reduce using rule 143 (naming -> atom .)
    AND             reduce using rule 143 (naming -> atom .)
    OR              reduce using rule 143 (naming -> atom .)
    =               reduce using rule 143 (naming -> atom .)
    ;               reduce using rule 143 (naming -> atom .)
    {               reduce using rule 143 (naming -> atom .)
    ,               reduce using rule 143 (naming -> atom .)
    ]               reduce using rule 143 (naming -> atom .)
    )               reduce using rule 143 (naming -> atom .)
    }               reduce using rule 143 (naming -> atom .)


state 246

    (139) power -> naming .
    (140) naming -> naming . [ disjunction ]

    *               reduce using rule 139 (power -> naming .)
    /               reduce using rule 139 (power -> naming .)
    %               reduce using rule 139 (power -> naming .)
    INTDIV          reduce using rule 139 (power -> naming .)
    EQ              reduce using rule 139 (power -> naming .)
    NEQ             reduce using rule 139 (power -> naming .)
    GE              reduce using rule 139 (power -> naming .)
    LE              reduce using rule 139 (power -> naming .)
    >               reduce using rule 139 (power -> naming .)
    <               reduce using rule 139 (power -> naming .)
    +               reduce using rule 139 (power -> naming .)
    -               reduce using rule 139 (power -> naming .)
    AND             reduce using rule 139 (power -> naming .)
    OR              reduce using rule 139 (power -> naming .)
    =               reduce using rule 139 (power -> naming .)
    ;               reduce using rule 139 (power -> naming .)
    {               reduce using rule 139 (power -> naming .)
    ,               reduce using rule 139 (power -> naming .)
    ]               reduce using rule 139 (power -> naming .)
    )               reduce using rule 139 (power -> naming .)
    }               reduce using rule 139 (power -> naming .)
    [               shift and go to state 296


state 247

    (141) naming -> accessing .

    [               reduce using rule 141 (naming -> accessing .)
    *               reduce using rule 141 (naming -> accessing .)
    /               reduce using rule 141 (naming -> accessing .)
    %               reduce using rule 141 (naming -> accessing .)
    INTDIV          reduce using rule 141 (naming -> accessing .)
    EQ              reduce using rule 141 (naming -> accessing .)
    NEQ             reduce using rule 141 (naming -> accessing .)
    GE              reduce using rule 141 (naming -> accessing .)
    LE              reduce using rule 141 (naming -> accessing .)
    >               reduce using rule 141 (naming -> accessing .)
    <               reduce using rule 141 (naming -> accessing .)
    +               reduce using rule 141 (naming -> accessing .)
    -               reduce using rule 141 (naming -> accessing .)
    AND             reduce using rule 141 (naming -> accessing .)
    OR              reduce using rule 141 (naming -> accessing .)
    =               reduce using rule 141 (naming -> accessing .)
    ;               reduce using rule 141 (naming -> accessing .)
    {               reduce using rule 141 (naming -> accessing .)
    ,               reduce using rule 141 (naming -> accessing .)
    ]               reduce using rule 141 (naming -> accessing .)
    )               reduce using rule 141 (naming -> accessing .)
    }               reduce using rule 141 (naming -> accessing .)


state 248

    (82) simprop -> STOP SIMULATION { stmt_list } .

    EPISODES        reduce using rule 82 (simprop -> STOP SIMULATION { stmt_list } .)
    MAX_ROUNDS      reduce using rule 82 (simprop -> STOP SIMULATION { stmt_list } .)
    ACTIONS_TIME    reduce using rule 82 (simprop -> STOP SIMULATION { stmt_list } .)
    STOP            reduce using rule 82 (simprop -> STOP SIMULATION { stmt_list } .)
    AVAILABLE_COMMANDS reduce using rule 82 (simprop -> STOP SIMULATION { stmt_list } .)
    }               reduce using rule 82 (simprop -> STOP SIMULATION { stmt_list } .)


state 249

    (91) stmt_list -> stmt stmt_list .

    }               reduce using rule 91 (stmt_list -> stmt stmt_list .)


state 250

    (94) stmt -> var_stmt ; .

    CONTINUE        reduce using rule 94 (stmt -> var_stmt ; .)
    BREAK           reduce using rule 94 (stmt -> var_stmt ; .)
    RETURN          reduce using rule 94 (stmt -> var_stmt ; .)
    IF              reduce using rule 94 (stmt -> var_stmt ; .)
    LOOP            reduce using rule 94 (stmt -> var_stmt ; .)
    ID              reduce using rule 94 (stmt -> var_stmt ; .)
    ORGANISM        reduce using rule 94 (stmt -> var_stmt ; .)
    SIMULATION      reduce using rule 94 (stmt -> var_stmt ; .)
    NUMBER          reduce using rule 94 (stmt -> var_stmt ; .)
    STRING          reduce using rule 94 (stmt -> var_stmt ; .)
    (               reduce using rule 94 (stmt -> var_stmt ; .)
    [               reduce using rule 94 (stmt -> var_stmt ; .)
    {               reduce using rule 94 (stmt -> var_stmt ; .)
    TRUE            reduce using rule 94 (stmt -> var_stmt ; .)
    FALSE           reduce using rule 94 (stmt -> var_stmt ; .)
    }               reduce using rule 94 (stmt -> var_stmt ; .)


state 251

    (95) stmt -> index_stmt ; .

    CONTINUE        reduce using rule 95 (stmt -> index_stmt ; .)
    BREAK           reduce using rule 95 (stmt -> index_stmt ; .)
    RETURN          reduce using rule 95 (stmt -> index_stmt ; .)
    IF              reduce using rule 95 (stmt -> index_stmt ; .)
    LOOP            reduce using rule 95 (stmt -> index_stmt ; .)
    ID              reduce using rule 95 (stmt -> index_stmt ; .)
    ORGANISM        reduce using rule 95 (stmt -> index_stmt ; .)
    SIMULATION      reduce using rule 95 (stmt -> index_stmt ; .)
    NUMBER          reduce using rule 95 (stmt -> index_stmt ; .)
    STRING          reduce using rule 95 (stmt -> index_stmt ; .)
    (               reduce using rule 95 (stmt -> index_stmt ; .)
    [               reduce using rule 95 (stmt -> index_stmt ; .)
    {               reduce using rule 95 (stmt -> index_stmt ; .)
    TRUE            reduce using rule 95 (stmt -> index_stmt ; .)
    FALSE           reduce using rule 95 (stmt -> index_stmt ; .)
    }               reduce using rule 95 (stmt -> index_stmt ; .)


state 252

    (97) stmt -> CONTINUE ; .

    CONTINUE        reduce using rule 97 (stmt -> CONTINUE ; .)
    BREAK           reduce using rule 97 (stmt -> CONTINUE ; .)
    RETURN          reduce using rule 97 (stmt -> CONTINUE ; .)
    IF              reduce using rule 97 (stmt -> CONTINUE ; .)
    LOOP            reduce using rule 97 (stmt -> CONTINUE ; .)
    ID              reduce using rule 97 (stmt -> CONTINUE ; .)
    ORGANISM        reduce using rule 97 (stmt -> CONTINUE ; .)
    SIMULATION      reduce using rule 97 (stmt -> CONTINUE ; .)
    NUMBER          reduce using rule 97 (stmt -> CONTINUE ; .)
    STRING          reduce using rule 97 (stmt -> CONTINUE ; .)
    (               reduce using rule 97 (stmt -> CONTINUE ; .)
    [               reduce using rule 97 (stmt -> CONTINUE ; .)
    {               reduce using rule 97 (stmt -> CONTINUE ; .)
    TRUE            reduce using rule 97 (stmt -> CONTINUE ; .)
    FALSE           reduce using rule 97 (stmt -> CONTINUE ; .)
    }               reduce using rule 97 (stmt -> CONTINUE ; .)


state 253

    (98) stmt -> BREAK ; .

    CONTINUE        reduce using rule 98 (stmt -> BREAK ; .)
    BREAK           reduce using rule 98 (stmt -> BREAK ; .)
    RETURN          reduce using rule 98 (stmt -> BREAK ; .)
    IF              reduce using rule 98 (stmt -> BREAK ; .)
    LOOP            reduce using rule 98 (stmt -> BREAK ; .)
    ID              reduce using rule 98 (stmt -> BREAK ; .)
    ORGANISM        reduce using rule 98 (stmt -> BREAK ; .)
    SIMULATION      reduce using rule 98 (stmt -> BREAK ; .)
    NUMBER          reduce using rule 98 (stmt -> BREAK ; .)
    STRING          reduce using rule 98 (stmt -> BREAK ; .)
    (               reduce using rule 98 (stmt -> BREAK ; .)
    [               reduce using rule 98 (stmt -> BREAK ; .)
    {               reduce using rule 98 (stmt -> BREAK ; .)
    TRUE            reduce using rule 98 (stmt -> BREAK ; .)
    FALSE           reduce using rule 98 (stmt -> BREAK ; .)
    }               reduce using rule 98 (stmt -> BREAK ; .)


state 254

    (99) stmt -> RETURN disjunction . ;

    ;               shift and go to state 297


state 255

    (100) stmt -> RETURN ; .

    CONTINUE        reduce using rule 100 (stmt -> RETURN ; .)
    BREAK           reduce using rule 100 (stmt -> RETURN ; .)
    RETURN          reduce using rule 100 (stmt -> RETURN ; .)
    IF              reduce using rule 100 (stmt -> RETURN ; .)
    LOOP            reduce using rule 100 (stmt -> RETURN ; .)
    ID              reduce using rule 100 (stmt -> RETURN ; .)
    ORGANISM        reduce using rule 100 (stmt -> RETURN ; .)
    SIMULATION      reduce using rule 100 (stmt -> RETURN ; .)
    NUMBER          reduce using rule 100 (stmt -> RETURN ; .)
    STRING          reduce using rule 100 (stmt -> RETURN ; .)
    (               reduce using rule 100 (stmt -> RETURN ; .)
    [               reduce using rule 100 (stmt -> RETURN ; .)
    {               reduce using rule 100 (stmt -> RETURN ; .)
    TRUE            reduce using rule 100 (stmt -> RETURN ; .)
    FALSE           reduce using rule 100 (stmt -> RETURN ; .)
    }               reduce using rule 100 (stmt -> RETURN ; .)


state 256

    (103) if_stmt -> IF disjunction . { stmt_list } else_stmt

    {               shift and go to state 298


state 257

    (101) var_stmt -> accessing = . disjunction
    (114) disjunction -> . conjunction OR conjunction
    (115) disjunction -> . conjunction
    (116) conjunction -> . negation AND negation
    (117) conjunction -> . negation
    (118) negation -> . NOT comparison
    (119) negation -> . comparison
    (120) comparison -> . expr EQ expr
    (121) comparison -> . expr NEQ expr
    (122) comparison -> . expr GE expr
    (123) comparison -> . expr LE expr
    (124) comparison -> . expr > expr
    (125) comparison -> . expr < expr
    (126) comparison -> . expr
    (127) expr -> . expr + term
    (128) expr -> . expr - term
    (129) expr -> . term
    (130) term -> . term * factor
    (131) term -> . term / factor
    (132) term -> . term % factor
    (133) term -> . term INTDIV factor
    (134) term -> . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    NOT             shift and go to state 238
    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    accessing                      shift and go to state 247
    disjunction                    shift and go to state 299
    conjunction                    shift and go to state 236
    negation                       shift and go to state 237
    comparison                     shift and go to state 239
    expr                           shift and go to state 240
    term                           shift and go to state 241
    factor                         shift and go to state 243
    power                          shift and go to state 244
    atom                           shift and go to state 245
    naming                         shift and go to state 246
    bool                           shift and go to state 221
    word                           shift and go to state 214

state 258

    (102) index_stmt -> naming [ . disjunction ] = disjunction
    (140) naming -> naming [ . disjunction ]
    (114) disjunction -> . conjunction OR conjunction
    (115) disjunction -> . conjunction
    (116) conjunction -> . negation AND negation
    (117) conjunction -> . negation
    (118) negation -> . NOT comparison
    (119) negation -> . comparison
    (120) comparison -> . expr EQ expr
    (121) comparison -> . expr NEQ expr
    (122) comparison -> . expr GE expr
    (123) comparison -> . expr LE expr
    (124) comparison -> . expr > expr
    (125) comparison -> . expr < expr
    (126) comparison -> . expr
    (127) expr -> . expr + term
    (128) expr -> . expr - term
    (129) expr -> . term
    (130) term -> . term * factor
    (131) term -> . term / factor
    (132) term -> . term % factor
    (133) term -> . term INTDIV factor
    (134) term -> . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    NOT             shift and go to state 238
    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    naming                         shift and go to state 246
    disjunction                    shift and go to state 300
    conjunction                    shift and go to state 236
    negation                       shift and go to state 237
    comparison                     shift and go to state 239
    expr                           shift and go to state 240
    term                           shift and go to state 241
    factor                         shift and go to state 243
    power                          shift and go to state 244
    atom                           shift and go to state 245
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 259

    (148) atom -> [ arg_list . ]

    ]               shift and go to state 301


state 260

    (157) arg_list -> disjunction .
    (158) arg_list -> disjunction . , arg_list

    ]               reduce using rule 157 (arg_list -> disjunction .)
    )               reduce using rule 157 (arg_list -> disjunction .)
    ,               shift and go to state 302


state 261

    (159) arg_list -> epsilon .

    ]               reduce using rule 159 (arg_list -> epsilon .)
    )               reduce using rule 159 (arg_list -> epsilon .)


state 262

    (107) loop_stmt -> LOOP loop_init . , loop_condition , loop_set { stmt_list }

    ,               shift and go to state 303


state 263

    (108) loop_init -> var_stmt .

    ,               reduce using rule 108 (loop_init -> var_stmt .)


state 264

    (109) loop_init -> epsilon .

    ,               reduce using rule 109 (loop_init -> epsilon .)


state 265

    (101) var_stmt -> accessing . = disjunction

    =               shift and go to state 257


state 266

    (152) word -> ID .

    .               reduce using rule 152 (word -> ID .)
    =               reduce using rule 152 (word -> ID .)
    [               reduce using rule 152 (word -> ID .)
    *               reduce using rule 152 (word -> ID .)
    /               reduce using rule 152 (word -> ID .)
    %               reduce using rule 152 (word -> ID .)
    INTDIV          reduce using rule 152 (word -> ID .)
    EQ              reduce using rule 152 (word -> ID .)
    NEQ             reduce using rule 152 (word -> ID .)
    GE              reduce using rule 152 (word -> ID .)
    LE              reduce using rule 152 (word -> ID .)
    >               reduce using rule 152 (word -> ID .)
    <               reduce using rule 152 (word -> ID .)
    +               reduce using rule 152 (word -> ID .)
    -               reduce using rule 152 (word -> ID .)
    AND             reduce using rule 152 (word -> ID .)
    OR              reduce using rule 152 (word -> ID .)
    ;               reduce using rule 152 (word -> ID .)
    {               reduce using rule 152 (word -> ID .)
    ,               reduce using rule 152 (word -> ID .)
    ]               reduce using rule 152 (word -> ID .)
    )               reduce using rule 152 (word -> ID .)
    }               reduce using rule 152 (word -> ID .)


state 267

    (151) accessing -> word . . accessing
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    ID              shift and go to state 266
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    word                           shift and go to state 214
    accessing                      shift and go to state 304

state 268

    (142) naming -> ID ( . arg_list )
    (157) arg_list -> . disjunction
    (158) arg_list -> . disjunction , arg_list
    (159) arg_list -> . epsilon
    (114) disjunction -> . conjunction OR conjunction
    (115) disjunction -> . conjunction
    (2) epsilon -> .
    (116) conjunction -> . negation AND negation
    (117) conjunction -> . negation
    (118) negation -> . NOT comparison
    (119) negation -> . comparison
    (120) comparison -> . expr EQ expr
    (121) comparison -> . expr NEQ expr
    (122) comparison -> . expr GE expr
    (123) comparison -> . expr LE expr
    (124) comparison -> . expr > expr
    (125) comparison -> . expr < expr
    (126) comparison -> . expr
    (127) expr -> . expr + term
    (128) expr -> . expr - term
    (129) expr -> . term
    (130) term -> . term * factor
    (131) term -> . term / factor
    (132) term -> . term % factor
    (133) term -> . term INTDIV factor
    (134) term -> . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    )               reduce using rule 2 (epsilon -> .)
    NOT             shift and go to state 238
    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    arg_list                       shift and go to state 305
    disjunction                    shift and go to state 260
    epsilon                        shift and go to state 261
    conjunction                    shift and go to state 236
    negation                       shift and go to state 237
    comparison                     shift and go to state 239
    expr                           shift and go to state 240
    term                           shift and go to state 241
    factor                         shift and go to state 243
    power                          shift and go to state 244
    atom                           shift and go to state 245
    naming                         shift and go to state 246
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 269

    (147) atom -> ( expr . )
    (127) expr -> expr . + term
    (128) expr -> expr . - term

    )               shift and go to state 306
    +               shift and go to state 287
    -               shift and go to state 288


state 270

    (66) worldsize -> INFINITE { worldsizeprop worldsizeprop } .

    SIZE            reduce using rule 66 (worldsize -> INFINITE { worldsizeprop worldsizeprop } .)
    TERRAIN         reduce using rule 66 (worldsize -> INFINITE { worldsizeprop worldsizeprop } .)
    }               reduce using rule 66 (worldsize -> INFINITE { worldsizeprop worldsizeprop } .)


state 271

    (75) terrainprop -> ID AT { NUMBER . terrainposn_list }
    (76) terrainposn_list -> . NUMBER terrainposn_list
    (77) terrainposn_list -> . epsilon
    (2) epsilon -> .

    NUMBER          shift and go to state 307
    }               reduce using rule 2 (epsilon -> .)

    terrainposn_list               shift and go to state 308
    epsilon                        shift and go to state 309

state 272

    (47) decide_stmt -> DECIDE ORGANISM TIME { stmt_list } .

    }               reduce using rule 47 (decide_stmt -> DECIDE ORGANISM TIME { stmt_list } .)


state 273

    (88) func_stmt -> FUNC ID = param_list { stmt_list } .

    FUNC            reduce using rule 88 (func_stmt -> FUNC ID = param_list { stmt_list } .)
    DECIDE          reduce using rule 88 (func_stmt -> FUNC ID = param_list { stmt_list } .)


state 274

    (78) sim_stmt -> SIMULATION { simprop simprop simprop simprop simprop } .

    $end            reduce using rule 78 (sim_stmt -> SIMULATION { simprop simprop simprop simprop simprop } .)


state 275

    (149) atom -> { keyarg_list } .

    [               reduce using rule 149 (atom -> { keyarg_list } .)
    ^               reduce using rule 149 (atom -> { keyarg_list } .)
    @               reduce using rule 149 (atom -> { keyarg_list } .)
    *               reduce using rule 149 (atom -> { keyarg_list } .)
    /               reduce using rule 149 (atom -> { keyarg_list } .)
    %               reduce using rule 149 (atom -> { keyarg_list } .)
    INTDIV          reduce using rule 149 (atom -> { keyarg_list } .)
    EQ              reduce using rule 149 (atom -> { keyarg_list } .)
    NEQ             reduce using rule 149 (atom -> { keyarg_list } .)
    GE              reduce using rule 149 (atom -> { keyarg_list } .)
    LE              reduce using rule 149 (atom -> { keyarg_list } .)
    >               reduce using rule 149 (atom -> { keyarg_list } .)
    <               reduce using rule 149 (atom -> { keyarg_list } .)
    +               reduce using rule 149 (atom -> { keyarg_list } .)
    -               reduce using rule 149 (atom -> { keyarg_list } .)
    AND             reduce using rule 149 (atom -> { keyarg_list } .)
    OR              reduce using rule 149 (atom -> { keyarg_list } .)
    =               reduce using rule 149 (atom -> { keyarg_list } .)
    ;               reduce using rule 149 (atom -> { keyarg_list } .)
    {               reduce using rule 149 (atom -> { keyarg_list } .)
    ,               reduce using rule 149 (atom -> { keyarg_list } .)
    ]               reduce using rule 149 (atom -> { keyarg_list } .)
    )               reduce using rule 149 (atom -> { keyarg_list } .)
    }               reduce using rule 149 (atom -> { keyarg_list } .)


state 276

    (161) keyarg_list -> keyarg , . keyarg_list
    (160) keyarg_list -> . keyarg
    (161) keyarg_list -> . keyarg , keyarg_list
    (162) keyarg_list -> . epsilon
    (163) keyarg -> . disjunction = disjunction
    (2) epsilon -> .
    (114) disjunction -> . conjunction OR conjunction
    (115) disjunction -> . conjunction
    (116) conjunction -> . negation AND negation
    (117) conjunction -> . negation
    (118) negation -> . NOT comparison
    (119) negation -> . comparison
    (120) comparison -> . expr EQ expr
    (121) comparison -> . expr NEQ expr
    (122) comparison -> . expr GE expr
    (123) comparison -> . expr LE expr
    (124) comparison -> . expr > expr
    (125) comparison -> . expr < expr
    (126) comparison -> . expr
    (127) expr -> . expr + term
    (128) expr -> . expr - term
    (129) expr -> . term
    (130) term -> . term * factor
    (131) term -> . term / factor
    (132) term -> . term % factor
    (133) term -> . term INTDIV factor
    (134) term -> . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    }               reduce using rule 2 (epsilon -> .)
    NOT             shift and go to state 238
    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    keyarg                         shift and go to state 233
    keyarg_list                    shift and go to state 310
    epsilon                        shift and go to state 234
    disjunction                    shift and go to state 235
    conjunction                    shift and go to state 236
    negation                       shift and go to state 237
    comparison                     shift and go to state 239
    expr                           shift and go to state 240
    term                           shift and go to state 241
    factor                         shift and go to state 243
    power                          shift and go to state 244
    atom                           shift and go to state 245
    naming                         shift and go to state 246
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 277

    (163) keyarg -> disjunction = . disjunction
    (114) disjunction -> . conjunction OR conjunction
    (115) disjunction -> . conjunction
    (116) conjunction -> . negation AND negation
    (117) conjunction -> . negation
    (118) negation -> . NOT comparison
    (119) negation -> . comparison
    (120) comparison -> . expr EQ expr
    (121) comparison -> . expr NEQ expr
    (122) comparison -> . expr GE expr
    (123) comparison -> . expr LE expr
    (124) comparison -> . expr > expr
    (125) comparison -> . expr < expr
    (126) comparison -> . expr
    (127) expr -> . expr + term
    (128) expr -> . expr - term
    (129) expr -> . term
    (130) term -> . term * factor
    (131) term -> . term / factor
    (132) term -> . term % factor
    (133) term -> . term INTDIV factor
    (134) term -> . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    NOT             shift and go to state 238
    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    disjunction                    shift and go to state 311
    conjunction                    shift and go to state 236
    negation                       shift and go to state 237
    comparison                     shift and go to state 239
    expr                           shift and go to state 240
    term                           shift and go to state 241
    factor                         shift and go to state 243
    power                          shift and go to state 244
    atom                           shift and go to state 245
    naming                         shift and go to state 246
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 278

    (114) disjunction -> conjunction OR . conjunction
    (116) conjunction -> . negation AND negation
    (117) conjunction -> . negation
    (118) negation -> . NOT comparison
    (119) negation -> . comparison
    (120) comparison -> . expr EQ expr
    (121) comparison -> . expr NEQ expr
    (122) comparison -> . expr GE expr
    (123) comparison -> . expr LE expr
    (124) comparison -> . expr > expr
    (125) comparison -> . expr < expr
    (126) comparison -> . expr
    (127) expr -> . expr + term
    (128) expr -> . expr - term
    (129) expr -> . term
    (130) term -> . term * factor
    (131) term -> . term / factor
    (132) term -> . term % factor
    (133) term -> . term INTDIV factor
    (134) term -> . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    NOT             shift and go to state 238
    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    conjunction                    shift and go to state 312
    negation                       shift and go to state 237
    comparison                     shift and go to state 239
    expr                           shift and go to state 240
    term                           shift and go to state 241
    factor                         shift and go to state 243
    power                          shift and go to state 244
    atom                           shift and go to state 245
    naming                         shift and go to state 246
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 279

    (116) conjunction -> negation AND . negation
    (118) negation -> . NOT comparison
    (119) negation -> . comparison
    (120) comparison -> . expr EQ expr
    (121) comparison -> . expr NEQ expr
    (122) comparison -> . expr GE expr
    (123) comparison -> . expr LE expr
    (124) comparison -> . expr > expr
    (125) comparison -> . expr < expr
    (126) comparison -> . expr
    (127) expr -> . expr + term
    (128) expr -> . expr - term
    (129) expr -> . term
    (130) term -> . term * factor
    (131) term -> . term / factor
    (132) term -> . term % factor
    (133) term -> . term INTDIV factor
    (134) term -> . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    NOT             shift and go to state 238
    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    negation                       shift and go to state 313
    comparison                     shift and go to state 239
    expr                           shift and go to state 240
    term                           shift and go to state 241
    factor                         shift and go to state 243
    power                          shift and go to state 244
    atom                           shift and go to state 245
    naming                         shift and go to state 246
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 280

    (118) negation -> NOT comparison .

    AND             reduce using rule 118 (negation -> NOT comparison .)
    OR              reduce using rule 118 (negation -> NOT comparison .)
    =               reduce using rule 118 (negation -> NOT comparison .)
    ;               reduce using rule 118 (negation -> NOT comparison .)
    {               reduce using rule 118 (negation -> NOT comparison .)
    ,               reduce using rule 118 (negation -> NOT comparison .)
    ]               reduce using rule 118 (negation -> NOT comparison .)
    )               reduce using rule 118 (negation -> NOT comparison .)
    }               reduce using rule 118 (negation -> NOT comparison .)


state 281

    (120) comparison -> expr EQ . expr
    (127) expr -> . expr + term
    (128) expr -> . expr - term
    (129) expr -> . term
    (130) term -> . term * factor
    (131) term -> . term / factor
    (132) term -> . term % factor
    (133) term -> . term INTDIV factor
    (134) term -> . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    expr                           shift and go to state 314
    term                           shift and go to state 241
    factor                         shift and go to state 243
    power                          shift and go to state 244
    atom                           shift and go to state 245
    naming                         shift and go to state 246
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 282

    (121) comparison -> expr NEQ . expr
    (127) expr -> . expr + term
    (128) expr -> . expr - term
    (129) expr -> . term
    (130) term -> . term * factor
    (131) term -> . term / factor
    (132) term -> . term % factor
    (133) term -> . term INTDIV factor
    (134) term -> . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    expr                           shift and go to state 315
    term                           shift and go to state 241
    factor                         shift and go to state 243
    power                          shift and go to state 244
    atom                           shift and go to state 245
    naming                         shift and go to state 246
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 283

    (122) comparison -> expr GE . expr
    (127) expr -> . expr + term
    (128) expr -> . expr - term
    (129) expr -> . term
    (130) term -> . term * factor
    (131) term -> . term / factor
    (132) term -> . term % factor
    (133) term -> . term INTDIV factor
    (134) term -> . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    expr                           shift and go to state 316
    term                           shift and go to state 241
    factor                         shift and go to state 243
    power                          shift and go to state 244
    atom                           shift and go to state 245
    naming                         shift and go to state 246
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 284

    (123) comparison -> expr LE . expr
    (127) expr -> . expr + term
    (128) expr -> . expr - term
    (129) expr -> . term
    (130) term -> . term * factor
    (131) term -> . term / factor
    (132) term -> . term % factor
    (133) term -> . term INTDIV factor
    (134) term -> . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    expr                           shift and go to state 317
    term                           shift and go to state 241
    factor                         shift and go to state 243
    power                          shift and go to state 244
    atom                           shift and go to state 245
    naming                         shift and go to state 246
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 285

    (124) comparison -> expr > . expr
    (127) expr -> . expr + term
    (128) expr -> . expr - term
    (129) expr -> . term
    (130) term -> . term * factor
    (131) term -> . term / factor
    (132) term -> . term % factor
    (133) term -> . term INTDIV factor
    (134) term -> . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    expr                           shift and go to state 318
    term                           shift and go to state 241
    factor                         shift and go to state 243
    power                          shift and go to state 244
    atom                           shift and go to state 245
    naming                         shift and go to state 246
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 286

    (125) comparison -> expr < . expr
    (127) expr -> . expr + term
    (128) expr -> . expr - term
    (129) expr -> . term
    (130) term -> . term * factor
    (131) term -> . term / factor
    (132) term -> . term % factor
    (133) term -> . term INTDIV factor
    (134) term -> . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    expr                           shift and go to state 319
    term                           shift and go to state 241
    factor                         shift and go to state 243
    power                          shift and go to state 244
    atom                           shift and go to state 245
    naming                         shift and go to state 246
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 287

    (127) expr -> expr + . term
    (130) term -> . term * factor
    (131) term -> . term / factor
    (132) term -> . term % factor
    (133) term -> . term INTDIV factor
    (134) term -> . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    term                           shift and go to state 320
    factor                         shift and go to state 243
    power                          shift and go to state 244
    atom                           shift and go to state 245
    naming                         shift and go to state 246
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 288

    (128) expr -> expr - . term
    (130) term -> . term * factor
    (131) term -> . term / factor
    (132) term -> . term % factor
    (133) term -> . term INTDIV factor
    (134) term -> . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    term                           shift and go to state 321
    factor                         shift and go to state 243
    power                          shift and go to state 244
    atom                           shift and go to state 245
    naming                         shift and go to state 246
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 289

    (130) term -> term * . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    factor                         shift and go to state 322
    power                          shift and go to state 244
    atom                           shift and go to state 245
    naming                         shift and go to state 246
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 290

    (131) term -> term / . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    factor                         shift and go to state 323
    power                          shift and go to state 244
    atom                           shift and go to state 245
    naming                         shift and go to state 246
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 291

    (132) term -> term % . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    factor                         shift and go to state 324
    power                          shift and go to state 244
    atom                           shift and go to state 245
    naming                         shift and go to state 246
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 292

    (133) term -> term INTDIV . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    factor                         shift and go to state 325
    power                          shift and go to state 244
    atom                           shift and go to state 245
    naming                         shift and go to state 246
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 293

    (135) factor -> - factor .

    *               reduce using rule 135 (factor -> - factor .)
    /               reduce using rule 135 (factor -> - factor .)
    %               reduce using rule 135 (factor -> - factor .)
    INTDIV          reduce using rule 135 (factor -> - factor .)
    EQ              reduce using rule 135 (factor -> - factor .)
    NEQ             reduce using rule 135 (factor -> - factor .)
    GE              reduce using rule 135 (factor -> - factor .)
    LE              reduce using rule 135 (factor -> - factor .)
    >               reduce using rule 135 (factor -> - factor .)
    <               reduce using rule 135 (factor -> - factor .)
    +               reduce using rule 135 (factor -> - factor .)
    -               reduce using rule 135 (factor -> - factor .)
    AND             reduce using rule 135 (factor -> - factor .)
    OR              reduce using rule 135 (factor -> - factor .)
    =               reduce using rule 135 (factor -> - factor .)
    ;               reduce using rule 135 (factor -> - factor .)
    {               reduce using rule 135 (factor -> - factor .)
    ,               reduce using rule 135 (factor -> - factor .)
    ]               reduce using rule 135 (factor -> - factor .)
    )               reduce using rule 135 (factor -> - factor .)
    }               reduce using rule 135 (factor -> - factor .)


state 294

    (137) power -> atom ^ . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    atom                           shift and go to state 245
    factor                         shift and go to state 326
    power                          shift and go to state 244
    naming                         shift and go to state 246
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 295

    (138) power -> atom @ . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    atom                           shift and go to state 245
    factor                         shift and go to state 327
    power                          shift and go to state 244
    naming                         shift and go to state 246
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 296

    (140) naming -> naming [ . disjunction ]
    (114) disjunction -> . conjunction OR conjunction
    (115) disjunction -> . conjunction
    (116) conjunction -> . negation AND negation
    (117) conjunction -> . negation
    (118) negation -> . NOT comparison
    (119) negation -> . comparison
    (120) comparison -> . expr EQ expr
    (121) comparison -> . expr NEQ expr
    (122) comparison -> . expr GE expr
    (123) comparison -> . expr LE expr
    (124) comparison -> . expr > expr
    (125) comparison -> . expr < expr
    (126) comparison -> . expr
    (127) expr -> . expr + term
    (128) expr -> . expr - term
    (129) expr -> . term
    (130) term -> . term * factor
    (131) term -> . term / factor
    (132) term -> . term % factor
    (133) term -> . term INTDIV factor
    (134) term -> . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    NOT             shift and go to state 238
    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    naming                         shift and go to state 246
    disjunction                    shift and go to state 328
    conjunction                    shift and go to state 236
    negation                       shift and go to state 237
    comparison                     shift and go to state 239
    expr                           shift and go to state 240
    term                           shift and go to state 241
    factor                         shift and go to state 243
    power                          shift and go to state 244
    atom                           shift and go to state 245
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 297

    (99) stmt -> RETURN disjunction ; .

    CONTINUE        reduce using rule 99 (stmt -> RETURN disjunction ; .)
    BREAK           reduce using rule 99 (stmt -> RETURN disjunction ; .)
    RETURN          reduce using rule 99 (stmt -> RETURN disjunction ; .)
    IF              reduce using rule 99 (stmt -> RETURN disjunction ; .)
    LOOP            reduce using rule 99 (stmt -> RETURN disjunction ; .)
    ID              reduce using rule 99 (stmt -> RETURN disjunction ; .)
    ORGANISM        reduce using rule 99 (stmt -> RETURN disjunction ; .)
    SIMULATION      reduce using rule 99 (stmt -> RETURN disjunction ; .)
    NUMBER          reduce using rule 99 (stmt -> RETURN disjunction ; .)
    STRING          reduce using rule 99 (stmt -> RETURN disjunction ; .)
    (               reduce using rule 99 (stmt -> RETURN disjunction ; .)
    [               reduce using rule 99 (stmt -> RETURN disjunction ; .)
    {               reduce using rule 99 (stmt -> RETURN disjunction ; .)
    TRUE            reduce using rule 99 (stmt -> RETURN disjunction ; .)
    FALSE           reduce using rule 99 (stmt -> RETURN disjunction ; .)
    }               reduce using rule 99 (stmt -> RETURN disjunction ; .)


state 298

    (103) if_stmt -> IF disjunction { . stmt_list } else_stmt
    (91) stmt_list -> . stmt stmt_list
    (92) stmt_list -> . epsilon
    (93) stmt -> . if_stmt
    (94) stmt -> . var_stmt ;
    (95) stmt -> . index_stmt ;
    (96) stmt -> . loop_stmt
    (97) stmt -> . CONTINUE ;
    (98) stmt -> . BREAK ;
    (99) stmt -> . RETURN disjunction ;
    (100) stmt -> . RETURN ;
    (2) epsilon -> .
    (103) if_stmt -> . IF disjunction { stmt_list } else_stmt
    (101) var_stmt -> . accessing = disjunction
    (102) index_stmt -> . naming [ disjunction ] = disjunction
    (107) loop_stmt -> . LOOP loop_init , loop_condition , loop_set { stmt_list }
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (155) bool -> . TRUE
    (156) bool -> . FALSE

    CONTINUE        shift and go to state 206
    BREAK           shift and go to state 207
    RETURN          shift and go to state 208
    }               reduce using rule 2 (epsilon -> .)
    IF              shift and go to state 209
    LOOP            shift and go to state 213
    ID              shift and go to state 215
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103

    stmt_list                      shift and go to state 329
    stmt                           shift and go to state 200
    epsilon                        shift and go to state 201
    if_stmt                        shift and go to state 202
    var_stmt                       shift and go to state 203
    index_stmt                     shift and go to state 204
    loop_stmt                      shift and go to state 205
    accessing                      shift and go to state 210
    naming                         shift and go to state 211
    word                           shift and go to state 214
    atom                           shift and go to state 217
    bool                           shift and go to state 221

state 299

    (101) var_stmt -> accessing = disjunction .

    ;               reduce using rule 101 (var_stmt -> accessing = disjunction .)
    ,               reduce using rule 101 (var_stmt -> accessing = disjunction .)
    {               reduce using rule 101 (var_stmt -> accessing = disjunction .)


state 300

    (102) index_stmt -> naming [ disjunction . ] = disjunction
    (140) naming -> naming [ disjunction . ]

    ]               shift and go to state 330


state 301

    (148) atom -> [ arg_list ] .

    [               reduce using rule 148 (atom -> [ arg_list ] .)
    ^               reduce using rule 148 (atom -> [ arg_list ] .)
    @               reduce using rule 148 (atom -> [ arg_list ] .)
    *               reduce using rule 148 (atom -> [ arg_list ] .)
    /               reduce using rule 148 (atom -> [ arg_list ] .)
    %               reduce using rule 148 (atom -> [ arg_list ] .)
    INTDIV          reduce using rule 148 (atom -> [ arg_list ] .)
    EQ              reduce using rule 148 (atom -> [ arg_list ] .)
    NEQ             reduce using rule 148 (atom -> [ arg_list ] .)
    GE              reduce using rule 148 (atom -> [ arg_list ] .)
    LE              reduce using rule 148 (atom -> [ arg_list ] .)
    >               reduce using rule 148 (atom -> [ arg_list ] .)
    <               reduce using rule 148 (atom -> [ arg_list ] .)
    +               reduce using rule 148 (atom -> [ arg_list ] .)
    -               reduce using rule 148 (atom -> [ arg_list ] .)
    AND             reduce using rule 148 (atom -> [ arg_list ] .)
    OR              reduce using rule 148 (atom -> [ arg_list ] .)
    =               reduce using rule 148 (atom -> [ arg_list ] .)
    ;               reduce using rule 148 (atom -> [ arg_list ] .)
    {               reduce using rule 148 (atom -> [ arg_list ] .)
    ,               reduce using rule 148 (atom -> [ arg_list ] .)
    ]               reduce using rule 148 (atom -> [ arg_list ] .)
    )               reduce using rule 148 (atom -> [ arg_list ] .)
    }               reduce using rule 148 (atom -> [ arg_list ] .)


state 302

    (158) arg_list -> disjunction , . arg_list
    (157) arg_list -> . disjunction
    (158) arg_list -> . disjunction , arg_list
    (159) arg_list -> . epsilon
    (114) disjunction -> . conjunction OR conjunction
    (115) disjunction -> . conjunction
    (2) epsilon -> .
    (116) conjunction -> . negation AND negation
    (117) conjunction -> . negation
    (118) negation -> . NOT comparison
    (119) negation -> . comparison
    (120) comparison -> . expr EQ expr
    (121) comparison -> . expr NEQ expr
    (122) comparison -> . expr GE expr
    (123) comparison -> . expr LE expr
    (124) comparison -> . expr > expr
    (125) comparison -> . expr < expr
    (126) comparison -> . expr
    (127) expr -> . expr + term
    (128) expr -> . expr - term
    (129) expr -> . term
    (130) term -> . term * factor
    (131) term -> . term / factor
    (132) term -> . term % factor
    (133) term -> . term INTDIV factor
    (134) term -> . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    ]               reduce using rule 2 (epsilon -> .)
    )               reduce using rule 2 (epsilon -> .)
    NOT             shift and go to state 238
    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    disjunction                    shift and go to state 260
    arg_list                       shift and go to state 331
    epsilon                        shift and go to state 261
    conjunction                    shift and go to state 236
    negation                       shift and go to state 237
    comparison                     shift and go to state 239
    expr                           shift and go to state 240
    term                           shift and go to state 241
    factor                         shift and go to state 243
    power                          shift and go to state 244
    atom                           shift and go to state 245
    naming                         shift and go to state 246
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 303

    (107) loop_stmt -> LOOP loop_init , . loop_condition , loop_set { stmt_list }
    (112) loop_condition -> . disjunction
    (113) loop_condition -> . epsilon
    (114) disjunction -> . conjunction OR conjunction
    (115) disjunction -> . conjunction
    (2) epsilon -> .
    (116) conjunction -> . negation AND negation
    (117) conjunction -> . negation
    (118) negation -> . NOT comparison
    (119) negation -> . comparison
    (120) comparison -> . expr EQ expr
    (121) comparison -> . expr NEQ expr
    (122) comparison -> . expr GE expr
    (123) comparison -> . expr LE expr
    (124) comparison -> . expr > expr
    (125) comparison -> . expr < expr
    (126) comparison -> . expr
    (127) expr -> . expr + term
    (128) expr -> . expr - term
    (129) expr -> . term
    (130) term -> . term * factor
    (131) term -> . term / factor
    (132) term -> . term % factor
    (133) term -> . term INTDIV factor
    (134) term -> . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    ,               reduce using rule 2 (epsilon -> .)
    NOT             shift and go to state 238
    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    loop_condition                 shift and go to state 332
    disjunction                    shift and go to state 333
    epsilon                        shift and go to state 334
    conjunction                    shift and go to state 236
    negation                       shift and go to state 237
    comparison                     shift and go to state 239
    expr                           shift and go to state 240
    term                           shift and go to state 241
    factor                         shift and go to state 243
    power                          shift and go to state 244
    atom                           shift and go to state 245
    naming                         shift and go to state 246
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 304

    (151) accessing -> word . accessing .

    =               reduce using rule 151 (accessing -> word . accessing .)
    [               reduce using rule 151 (accessing -> word . accessing .)
    *               reduce using rule 151 (accessing -> word . accessing .)
    /               reduce using rule 151 (accessing -> word . accessing .)
    %               reduce using rule 151 (accessing -> word . accessing .)
    INTDIV          reduce using rule 151 (accessing -> word . accessing .)
    EQ              reduce using rule 151 (accessing -> word . accessing .)
    NEQ             reduce using rule 151 (accessing -> word . accessing .)
    GE              reduce using rule 151 (accessing -> word . accessing .)
    LE              reduce using rule 151 (accessing -> word . accessing .)
    >               reduce using rule 151 (accessing -> word . accessing .)
    <               reduce using rule 151 (accessing -> word . accessing .)
    +               reduce using rule 151 (accessing -> word . accessing .)
    -               reduce using rule 151 (accessing -> word . accessing .)
    AND             reduce using rule 151 (accessing -> word . accessing .)
    OR              reduce using rule 151 (accessing -> word . accessing .)
    ;               reduce using rule 151 (accessing -> word . accessing .)
    {               reduce using rule 151 (accessing -> word . accessing .)
    ,               reduce using rule 151 (accessing -> word . accessing .)
    ]               reduce using rule 151 (accessing -> word . accessing .)
    )               reduce using rule 151 (accessing -> word . accessing .)
    }               reduce using rule 151 (accessing -> word . accessing .)


state 305

    (142) naming -> ID ( arg_list . )

    )               shift and go to state 335


state 306

    (147) atom -> ( expr ) .

    [               reduce using rule 147 (atom -> ( expr ) .)
    ^               reduce using rule 147 (atom -> ( expr ) .)
    @               reduce using rule 147 (atom -> ( expr ) .)
    *               reduce using rule 147 (atom -> ( expr ) .)
    /               reduce using rule 147 (atom -> ( expr ) .)
    %               reduce using rule 147 (atom -> ( expr ) .)
    INTDIV          reduce using rule 147 (atom -> ( expr ) .)
    EQ              reduce using rule 147 (atom -> ( expr ) .)
    NEQ             reduce using rule 147 (atom -> ( expr ) .)
    GE              reduce using rule 147 (atom -> ( expr ) .)
    LE              reduce using rule 147 (atom -> ( expr ) .)
    >               reduce using rule 147 (atom -> ( expr ) .)
    <               reduce using rule 147 (atom -> ( expr ) .)
    +               reduce using rule 147 (atom -> ( expr ) .)
    -               reduce using rule 147 (atom -> ( expr ) .)
    AND             reduce using rule 147 (atom -> ( expr ) .)
    OR              reduce using rule 147 (atom -> ( expr ) .)
    =               reduce using rule 147 (atom -> ( expr ) .)
    ;               reduce using rule 147 (atom -> ( expr ) .)
    {               reduce using rule 147 (atom -> ( expr ) .)
    ,               reduce using rule 147 (atom -> ( expr ) .)
    ]               reduce using rule 147 (atom -> ( expr ) .)
    )               reduce using rule 147 (atom -> ( expr ) .)
    }               reduce using rule 147 (atom -> ( expr ) .)


state 307

    (76) terrainposn_list -> NUMBER . terrainposn_list
    (76) terrainposn_list -> . NUMBER terrainposn_list
    (77) terrainposn_list -> . epsilon
    (2) epsilon -> .

    NUMBER          shift and go to state 307
    }               reduce using rule 2 (epsilon -> .)

    terrainposn_list               shift and go to state 336
    epsilon                        shift and go to state 309

state 308

    (75) terrainprop -> ID AT { NUMBER terrainposn_list . }

    }               shift and go to state 337


state 309

    (77) terrainposn_list -> epsilon .

    }               reduce using rule 77 (terrainposn_list -> epsilon .)


state 310

    (161) keyarg_list -> keyarg , keyarg_list .

    }               reduce using rule 161 (keyarg_list -> keyarg , keyarg_list .)


state 311

    (163) keyarg -> disjunction = disjunction .

    ,               reduce using rule 163 (keyarg -> disjunction = disjunction .)
    }               reduce using rule 163 (keyarg -> disjunction = disjunction .)


state 312

    (114) disjunction -> conjunction OR conjunction .

    =               reduce using rule 114 (disjunction -> conjunction OR conjunction .)
    ;               reduce using rule 114 (disjunction -> conjunction OR conjunction .)
    {               reduce using rule 114 (disjunction -> conjunction OR conjunction .)
    ,               reduce using rule 114 (disjunction -> conjunction OR conjunction .)
    ]               reduce using rule 114 (disjunction -> conjunction OR conjunction .)
    )               reduce using rule 114 (disjunction -> conjunction OR conjunction .)
    }               reduce using rule 114 (disjunction -> conjunction OR conjunction .)


state 313

    (116) conjunction -> negation AND negation .

    OR              reduce using rule 116 (conjunction -> negation AND negation .)
    =               reduce using rule 116 (conjunction -> negation AND negation .)
    ;               reduce using rule 116 (conjunction -> negation AND negation .)
    {               reduce using rule 116 (conjunction -> negation AND negation .)
    ,               reduce using rule 116 (conjunction -> negation AND negation .)
    ]               reduce using rule 116 (conjunction -> negation AND negation .)
    )               reduce using rule 116 (conjunction -> negation AND negation .)
    }               reduce using rule 116 (conjunction -> negation AND negation .)


state 314

    (120) comparison -> expr EQ expr .
    (127) expr -> expr . + term
    (128) expr -> expr . - term

    AND             reduce using rule 120 (comparison -> expr EQ expr .)
    OR              reduce using rule 120 (comparison -> expr EQ expr .)
    =               reduce using rule 120 (comparison -> expr EQ expr .)
    ;               reduce using rule 120 (comparison -> expr EQ expr .)
    {               reduce using rule 120 (comparison -> expr EQ expr .)
    ,               reduce using rule 120 (comparison -> expr EQ expr .)
    ]               reduce using rule 120 (comparison -> expr EQ expr .)
    )               reduce using rule 120 (comparison -> expr EQ expr .)
    }               reduce using rule 120 (comparison -> expr EQ expr .)
    +               shift and go to state 287
    -               shift and go to state 288


state 315

    (121) comparison -> expr NEQ expr .
    (127) expr -> expr . + term
    (128) expr -> expr . - term

    AND             reduce using rule 121 (comparison -> expr NEQ expr .)
    OR              reduce using rule 121 (comparison -> expr NEQ expr .)
    =               reduce using rule 121 (comparison -> expr NEQ expr .)
    ;               reduce using rule 121 (comparison -> expr NEQ expr .)
    {               reduce using rule 121 (comparison -> expr NEQ expr .)
    ,               reduce using rule 121 (comparison -> expr NEQ expr .)
    ]               reduce using rule 121 (comparison -> expr NEQ expr .)
    )               reduce using rule 121 (comparison -> expr NEQ expr .)
    }               reduce using rule 121 (comparison -> expr NEQ expr .)
    +               shift and go to state 287
    -               shift and go to state 288


state 316

    (122) comparison -> expr GE expr .
    (127) expr -> expr . + term
    (128) expr -> expr . - term

    AND             reduce using rule 122 (comparison -> expr GE expr .)
    OR              reduce using rule 122 (comparison -> expr GE expr .)
    =               reduce using rule 122 (comparison -> expr GE expr .)
    ;               reduce using rule 122 (comparison -> expr GE expr .)
    {               reduce using rule 122 (comparison -> expr GE expr .)
    ,               reduce using rule 122 (comparison -> expr GE expr .)
    ]               reduce using rule 122 (comparison -> expr GE expr .)
    )               reduce using rule 122 (comparison -> expr GE expr .)
    }               reduce using rule 122 (comparison -> expr GE expr .)
    +               shift and go to state 287
    -               shift and go to state 288


state 317

    (123) comparison -> expr LE expr .
    (127) expr -> expr . + term
    (128) expr -> expr . - term

    AND             reduce using rule 123 (comparison -> expr LE expr .)
    OR              reduce using rule 123 (comparison -> expr LE expr .)
    =               reduce using rule 123 (comparison -> expr LE expr .)
    ;               reduce using rule 123 (comparison -> expr LE expr .)
    {               reduce using rule 123 (comparison -> expr LE expr .)
    ,               reduce using rule 123 (comparison -> expr LE expr .)
    ]               reduce using rule 123 (comparison -> expr LE expr .)
    )               reduce using rule 123 (comparison -> expr LE expr .)
    }               reduce using rule 123 (comparison -> expr LE expr .)
    +               shift and go to state 287
    -               shift and go to state 288


state 318

    (124) comparison -> expr > expr .
    (127) expr -> expr . + term
    (128) expr -> expr . - term

    AND             reduce using rule 124 (comparison -> expr > expr .)
    OR              reduce using rule 124 (comparison -> expr > expr .)
    =               reduce using rule 124 (comparison -> expr > expr .)
    ;               reduce using rule 124 (comparison -> expr > expr .)
    {               reduce using rule 124 (comparison -> expr > expr .)
    ,               reduce using rule 124 (comparison -> expr > expr .)
    ]               reduce using rule 124 (comparison -> expr > expr .)
    )               reduce using rule 124 (comparison -> expr > expr .)
    }               reduce using rule 124 (comparison -> expr > expr .)
    +               shift and go to state 287
    -               shift and go to state 288


state 319

    (125) comparison -> expr < expr .
    (127) expr -> expr . + term
    (128) expr -> expr . - term

    AND             reduce using rule 125 (comparison -> expr < expr .)
    OR              reduce using rule 125 (comparison -> expr < expr .)
    =               reduce using rule 125 (comparison -> expr < expr .)
    ;               reduce using rule 125 (comparison -> expr < expr .)
    {               reduce using rule 125 (comparison -> expr < expr .)
    ,               reduce using rule 125 (comparison -> expr < expr .)
    ]               reduce using rule 125 (comparison -> expr < expr .)
    )               reduce using rule 125 (comparison -> expr < expr .)
    }               reduce using rule 125 (comparison -> expr < expr .)
    +               shift and go to state 287
    -               shift and go to state 288


state 320

    (127) expr -> expr + term .
    (130) term -> term . * factor
    (131) term -> term . / factor
    (132) term -> term . % factor
    (133) term -> term . INTDIV factor

    EQ              reduce using rule 127 (expr -> expr + term .)
    NEQ             reduce using rule 127 (expr -> expr + term .)
    GE              reduce using rule 127 (expr -> expr + term .)
    LE              reduce using rule 127 (expr -> expr + term .)
    >               reduce using rule 127 (expr -> expr + term .)
    <               reduce using rule 127 (expr -> expr + term .)
    +               reduce using rule 127 (expr -> expr + term .)
    -               reduce using rule 127 (expr -> expr + term .)
    AND             reduce using rule 127 (expr -> expr + term .)
    OR              reduce using rule 127 (expr -> expr + term .)
    =               reduce using rule 127 (expr -> expr + term .)
    ;               reduce using rule 127 (expr -> expr + term .)
    {               reduce using rule 127 (expr -> expr + term .)
    ,               reduce using rule 127 (expr -> expr + term .)
    ]               reduce using rule 127 (expr -> expr + term .)
    )               reduce using rule 127 (expr -> expr + term .)
    }               reduce using rule 127 (expr -> expr + term .)
    *               shift and go to state 289
    /               shift and go to state 290
    %               shift and go to state 291
    INTDIV          shift and go to state 292


state 321

    (128) expr -> expr - term .
    (130) term -> term . * factor
    (131) term -> term . / factor
    (132) term -> term . % factor
    (133) term -> term . INTDIV factor

    EQ              reduce using rule 128 (expr -> expr - term .)
    NEQ             reduce using rule 128 (expr -> expr - term .)
    GE              reduce using rule 128 (expr -> expr - term .)
    LE              reduce using rule 128 (expr -> expr - term .)
    >               reduce using rule 128 (expr -> expr - term .)
    <               reduce using rule 128 (expr -> expr - term .)
    +               reduce using rule 128 (expr -> expr - term .)
    -               reduce using rule 128 (expr -> expr - term .)
    AND             reduce using rule 128 (expr -> expr - term .)
    OR              reduce using rule 128 (expr -> expr - term .)
    =               reduce using rule 128 (expr -> expr - term .)
    ;               reduce using rule 128 (expr -> expr - term .)
    {               reduce using rule 128 (expr -> expr - term .)
    ,               reduce using rule 128 (expr -> expr - term .)
    ]               reduce using rule 128 (expr -> expr - term .)
    )               reduce using rule 128 (expr -> expr - term .)
    }               reduce using rule 128 (expr -> expr - term .)
    *               shift and go to state 289
    /               shift and go to state 290
    %               shift and go to state 291
    INTDIV          shift and go to state 292


state 322

    (130) term -> term * factor .

    *               reduce using rule 130 (term -> term * factor .)
    /               reduce using rule 130 (term -> term * factor .)
    %               reduce using rule 130 (term -> term * factor .)
    INTDIV          reduce using rule 130 (term -> term * factor .)
    EQ              reduce using rule 130 (term -> term * factor .)
    NEQ             reduce using rule 130 (term -> term * factor .)
    GE              reduce using rule 130 (term -> term * factor .)
    LE              reduce using rule 130 (term -> term * factor .)
    >               reduce using rule 130 (term -> term * factor .)
    <               reduce using rule 130 (term -> term * factor .)
    +               reduce using rule 130 (term -> term * factor .)
    -               reduce using rule 130 (term -> term * factor .)
    AND             reduce using rule 130 (term -> term * factor .)
    OR              reduce using rule 130 (term -> term * factor .)
    =               reduce using rule 130 (term -> term * factor .)
    ;               reduce using rule 130 (term -> term * factor .)
    {               reduce using rule 130 (term -> term * factor .)
    ,               reduce using rule 130 (term -> term * factor .)
    ]               reduce using rule 130 (term -> term * factor .)
    )               reduce using rule 130 (term -> term * factor .)
    }               reduce using rule 130 (term -> term * factor .)


state 323

    (131) term -> term / factor .

    *               reduce using rule 131 (term -> term / factor .)
    /               reduce using rule 131 (term -> term / factor .)
    %               reduce using rule 131 (term -> term / factor .)
    INTDIV          reduce using rule 131 (term -> term / factor .)
    EQ              reduce using rule 131 (term -> term / factor .)
    NEQ             reduce using rule 131 (term -> term / factor .)
    GE              reduce using rule 131 (term -> term / factor .)
    LE              reduce using rule 131 (term -> term / factor .)
    >               reduce using rule 131 (term -> term / factor .)
    <               reduce using rule 131 (term -> term / factor .)
    +               reduce using rule 131 (term -> term / factor .)
    -               reduce using rule 131 (term -> term / factor .)
    AND             reduce using rule 131 (term -> term / factor .)
    OR              reduce using rule 131 (term -> term / factor .)
    =               reduce using rule 131 (term -> term / factor .)
    ;               reduce using rule 131 (term -> term / factor .)
    {               reduce using rule 131 (term -> term / factor .)
    ,               reduce using rule 131 (term -> term / factor .)
    ]               reduce using rule 131 (term -> term / factor .)
    )               reduce using rule 131 (term -> term / factor .)
    }               reduce using rule 131 (term -> term / factor .)


state 324

    (132) term -> term % factor .

    *               reduce using rule 132 (term -> term % factor .)
    /               reduce using rule 132 (term -> term % factor .)
    %               reduce using rule 132 (term -> term % factor .)
    INTDIV          reduce using rule 132 (term -> term % factor .)
    EQ              reduce using rule 132 (term -> term % factor .)
    NEQ             reduce using rule 132 (term -> term % factor .)
    GE              reduce using rule 132 (term -> term % factor .)
    LE              reduce using rule 132 (term -> term % factor .)
    >               reduce using rule 132 (term -> term % factor .)
    <               reduce using rule 132 (term -> term % factor .)
    +               reduce using rule 132 (term -> term % factor .)
    -               reduce using rule 132 (term -> term % factor .)
    AND             reduce using rule 132 (term -> term % factor .)
    OR              reduce using rule 132 (term -> term % factor .)
    =               reduce using rule 132 (term -> term % factor .)
    ;               reduce using rule 132 (term -> term % factor .)
    {               reduce using rule 132 (term -> term % factor .)
    ,               reduce using rule 132 (term -> term % factor .)
    ]               reduce using rule 132 (term -> term % factor .)
    )               reduce using rule 132 (term -> term % factor .)
    }               reduce using rule 132 (term -> term % factor .)


state 325

    (133) term -> term INTDIV factor .

    *               reduce using rule 133 (term -> term INTDIV factor .)
    /               reduce using rule 133 (term -> term INTDIV factor .)
    %               reduce using rule 133 (term -> term INTDIV factor .)
    INTDIV          reduce using rule 133 (term -> term INTDIV factor .)
    EQ              reduce using rule 133 (term -> term INTDIV factor .)
    NEQ             reduce using rule 133 (term -> term INTDIV factor .)
    GE              reduce using rule 133 (term -> term INTDIV factor .)
    LE              reduce using rule 133 (term -> term INTDIV factor .)
    >               reduce using rule 133 (term -> term INTDIV factor .)
    <               reduce using rule 133 (term -> term INTDIV factor .)
    +               reduce using rule 133 (term -> term INTDIV factor .)
    -               reduce using rule 133 (term -> term INTDIV factor .)
    AND             reduce using rule 133 (term -> term INTDIV factor .)
    OR              reduce using rule 133 (term -> term INTDIV factor .)
    =               reduce using rule 133 (term -> term INTDIV factor .)
    ;               reduce using rule 133 (term -> term INTDIV factor .)
    {               reduce using rule 133 (term -> term INTDIV factor .)
    ,               reduce using rule 133 (term -> term INTDIV factor .)
    ]               reduce using rule 133 (term -> term INTDIV factor .)
    )               reduce using rule 133 (term -> term INTDIV factor .)
    }               reduce using rule 133 (term -> term INTDIV factor .)


state 326

    (137) power -> atom ^ factor .

    *               reduce using rule 137 (power -> atom ^ factor .)
    /               reduce using rule 137 (power -> atom ^ factor .)
    %               reduce using rule 137 (power -> atom ^ factor .)
    INTDIV          reduce using rule 137 (power -> atom ^ factor .)
    EQ              reduce using rule 137 (power -> atom ^ factor .)
    NEQ             reduce using rule 137 (power -> atom ^ factor .)
    GE              reduce using rule 137 (power -> atom ^ factor .)
    LE              reduce using rule 137 (power -> atom ^ factor .)
    >               reduce using rule 137 (power -> atom ^ factor .)
    <               reduce using rule 137 (power -> atom ^ factor .)
    +               reduce using rule 137 (power -> atom ^ factor .)
    -               reduce using rule 137 (power -> atom ^ factor .)
    AND             reduce using rule 137 (power -> atom ^ factor .)
    OR              reduce using rule 137 (power -> atom ^ factor .)
    =               reduce using rule 137 (power -> atom ^ factor .)
    ;               reduce using rule 137 (power -> atom ^ factor .)
    {               reduce using rule 137 (power -> atom ^ factor .)
    ,               reduce using rule 137 (power -> atom ^ factor .)
    ]               reduce using rule 137 (power -> atom ^ factor .)
    )               reduce using rule 137 (power -> atom ^ factor .)
    }               reduce using rule 137 (power -> atom ^ factor .)


state 327

    (138) power -> atom @ factor .

    *               reduce using rule 138 (power -> atom @ factor .)
    /               reduce using rule 138 (power -> atom @ factor .)
    %               reduce using rule 138 (power -> atom @ factor .)
    INTDIV          reduce using rule 138 (power -> atom @ factor .)
    EQ              reduce using rule 138 (power -> atom @ factor .)
    NEQ             reduce using rule 138 (power -> atom @ factor .)
    GE              reduce using rule 138 (power -> atom @ factor .)
    LE              reduce using rule 138 (power -> atom @ factor .)
    >               reduce using rule 138 (power -> atom @ factor .)
    <               reduce using rule 138 (power -> atom @ factor .)
    +               reduce using rule 138 (power -> atom @ factor .)
    -               reduce using rule 138 (power -> atom @ factor .)
    AND             reduce using rule 138 (power -> atom @ factor .)
    OR              reduce using rule 138 (power -> atom @ factor .)
    =               reduce using rule 138 (power -> atom @ factor .)
    ;               reduce using rule 138 (power -> atom @ factor .)
    {               reduce using rule 138 (power -> atom @ factor .)
    ,               reduce using rule 138 (power -> atom @ factor .)
    ]               reduce using rule 138 (power -> atom @ factor .)
    )               reduce using rule 138 (power -> atom @ factor .)
    }               reduce using rule 138 (power -> atom @ factor .)


state 328

    (140) naming -> naming [ disjunction . ]

    ]               shift and go to state 338


state 329

    (103) if_stmt -> IF disjunction { stmt_list . } else_stmt

    }               shift and go to state 339


state 330

    (102) index_stmt -> naming [ disjunction ] . = disjunction
    (140) naming -> naming [ disjunction ] .

    =               shift and go to state 340
    [               reduce using rule 140 (naming -> naming [ disjunction ] .)


state 331

    (158) arg_list -> disjunction , arg_list .

    ]               reduce using rule 158 (arg_list -> disjunction , arg_list .)
    )               reduce using rule 158 (arg_list -> disjunction , arg_list .)


state 332

    (107) loop_stmt -> LOOP loop_init , loop_condition . , loop_set { stmt_list }

    ,               shift and go to state 341


state 333

    (112) loop_condition -> disjunction .

    ,               reduce using rule 112 (loop_condition -> disjunction .)


state 334

    (113) loop_condition -> epsilon .

    ,               reduce using rule 113 (loop_condition -> epsilon .)


state 335

    (142) naming -> ID ( arg_list ) .

    [               reduce using rule 142 (naming -> ID ( arg_list ) .)
    *               reduce using rule 142 (naming -> ID ( arg_list ) .)
    /               reduce using rule 142 (naming -> ID ( arg_list ) .)
    %               reduce using rule 142 (naming -> ID ( arg_list ) .)
    INTDIV          reduce using rule 142 (naming -> ID ( arg_list ) .)
    EQ              reduce using rule 142 (naming -> ID ( arg_list ) .)
    NEQ             reduce using rule 142 (naming -> ID ( arg_list ) .)
    GE              reduce using rule 142 (naming -> ID ( arg_list ) .)
    LE              reduce using rule 142 (naming -> ID ( arg_list ) .)
    >               reduce using rule 142 (naming -> ID ( arg_list ) .)
    <               reduce using rule 142 (naming -> ID ( arg_list ) .)
    +               reduce using rule 142 (naming -> ID ( arg_list ) .)
    -               reduce using rule 142 (naming -> ID ( arg_list ) .)
    AND             reduce using rule 142 (naming -> ID ( arg_list ) .)
    OR              reduce using rule 142 (naming -> ID ( arg_list ) .)
    =               reduce using rule 142 (naming -> ID ( arg_list ) .)
    ;               reduce using rule 142 (naming -> ID ( arg_list ) .)
    {               reduce using rule 142 (naming -> ID ( arg_list ) .)
    ,               reduce using rule 142 (naming -> ID ( arg_list ) .)
    ]               reduce using rule 142 (naming -> ID ( arg_list ) .)
    )               reduce using rule 142 (naming -> ID ( arg_list ) .)
    }               reduce using rule 142 (naming -> ID ( arg_list ) .)


state 336

    (76) terrainposn_list -> NUMBER terrainposn_list .

    }               reduce using rule 76 (terrainposn_list -> NUMBER terrainposn_list .)


state 337

    (75) terrainprop -> ID AT { NUMBER terrainposn_list } .

    ID              reduce using rule 75 (terrainprop -> ID AT { NUMBER terrainposn_list } .)
    DEFAULT         reduce using rule 75 (terrainprop -> ID AT { NUMBER terrainposn_list } .)
    }               reduce using rule 75 (terrainprop -> ID AT { NUMBER terrainposn_list } .)


state 338

    (140) naming -> naming [ disjunction ] .

    [               reduce using rule 140 (naming -> naming [ disjunction ] .)
    *               reduce using rule 140 (naming -> naming [ disjunction ] .)
    /               reduce using rule 140 (naming -> naming [ disjunction ] .)
    %               reduce using rule 140 (naming -> naming [ disjunction ] .)
    INTDIV          reduce using rule 140 (naming -> naming [ disjunction ] .)
    EQ              reduce using rule 140 (naming -> naming [ disjunction ] .)
    NEQ             reduce using rule 140 (naming -> naming [ disjunction ] .)
    GE              reduce using rule 140 (naming -> naming [ disjunction ] .)
    LE              reduce using rule 140 (naming -> naming [ disjunction ] .)
    >               reduce using rule 140 (naming -> naming [ disjunction ] .)
    <               reduce using rule 140 (naming -> naming [ disjunction ] .)
    +               reduce using rule 140 (naming -> naming [ disjunction ] .)
    -               reduce using rule 140 (naming -> naming [ disjunction ] .)
    AND             reduce using rule 140 (naming -> naming [ disjunction ] .)
    OR              reduce using rule 140 (naming -> naming [ disjunction ] .)
    =               reduce using rule 140 (naming -> naming [ disjunction ] .)
    ;               reduce using rule 140 (naming -> naming [ disjunction ] .)
    {               reduce using rule 140 (naming -> naming [ disjunction ] .)
    ,               reduce using rule 140 (naming -> naming [ disjunction ] .)
    ]               reduce using rule 140 (naming -> naming [ disjunction ] .)
    )               reduce using rule 140 (naming -> naming [ disjunction ] .)
    }               reduce using rule 140 (naming -> naming [ disjunction ] .)


state 339

    (103) if_stmt -> IF disjunction { stmt_list } . else_stmt
    (104) else_stmt -> . ELSE if_stmt
    (105) else_stmt -> . ELSE { stmt_list }
    (106) else_stmt -> . epsilon
    (2) epsilon -> .

    ELSE            shift and go to state 343
    CONTINUE        reduce using rule 2 (epsilon -> .)
    BREAK           reduce using rule 2 (epsilon -> .)
    RETURN          reduce using rule 2 (epsilon -> .)
    IF              reduce using rule 2 (epsilon -> .)
    LOOP            reduce using rule 2 (epsilon -> .)
    ID              reduce using rule 2 (epsilon -> .)
    ORGANISM        reduce using rule 2 (epsilon -> .)
    SIMULATION      reduce using rule 2 (epsilon -> .)
    NUMBER          reduce using rule 2 (epsilon -> .)
    STRING          reduce using rule 2 (epsilon -> .)
    (               reduce using rule 2 (epsilon -> .)
    [               reduce using rule 2 (epsilon -> .)
    {               reduce using rule 2 (epsilon -> .)
    TRUE            reduce using rule 2 (epsilon -> .)
    FALSE           reduce using rule 2 (epsilon -> .)
    }               reduce using rule 2 (epsilon -> .)

    else_stmt                      shift and go to state 342
    epsilon                        shift and go to state 344

state 340

    (102) index_stmt -> naming [ disjunction ] = . disjunction
    (114) disjunction -> . conjunction OR conjunction
    (115) disjunction -> . conjunction
    (116) conjunction -> . negation AND negation
    (117) conjunction -> . negation
    (118) negation -> . NOT comparison
    (119) negation -> . comparison
    (120) comparison -> . expr EQ expr
    (121) comparison -> . expr NEQ expr
    (122) comparison -> . expr GE expr
    (123) comparison -> . expr LE expr
    (124) comparison -> . expr > expr
    (125) comparison -> . expr < expr
    (126) comparison -> . expr
    (127) expr -> . expr + term
    (128) expr -> . expr - term
    (129) expr -> . term
    (130) term -> . term * factor
    (131) term -> . term / factor
    (132) term -> . term % factor
    (133) term -> . term INTDIV factor
    (134) term -> . factor
    (135) factor -> . - factor
    (136) factor -> . power
    (137) power -> . atom ^ factor
    (138) power -> . atom @ factor
    (139) power -> . naming
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (155) bool -> . TRUE
    (156) bool -> . FALSE
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    NOT             shift and go to state 238
    -               shift and go to state 242
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    ID              shift and go to state 215
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    naming                         shift and go to state 246
    disjunction                    shift and go to state 345
    conjunction                    shift and go to state 236
    negation                       shift and go to state 237
    comparison                     shift and go to state 239
    expr                           shift and go to state 240
    term                           shift and go to state 241
    factor                         shift and go to state 243
    power                          shift and go to state 244
    atom                           shift and go to state 245
    bool                           shift and go to state 221
    accessing                      shift and go to state 247
    word                           shift and go to state 214

state 341

    (107) loop_stmt -> LOOP loop_init , loop_condition , . loop_set { stmt_list }
    (110) loop_set -> . var_stmt
    (111) loop_set -> . epsilon
    (101) var_stmt -> . accessing = disjunction
    (2) epsilon -> .
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION

    {               reduce using rule 2 (epsilon -> .)
    ID              shift and go to state 266
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197

    loop_set                       shift and go to state 346
    var_stmt                       shift and go to state 347
    epsilon                        shift and go to state 348
    accessing                      shift and go to state 265
    word                           shift and go to state 214

state 342

    (103) if_stmt -> IF disjunction { stmt_list } else_stmt .

    CONTINUE        reduce using rule 103 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    BREAK           reduce using rule 103 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    RETURN          reduce using rule 103 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    IF              reduce using rule 103 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    LOOP            reduce using rule 103 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    ID              reduce using rule 103 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    ORGANISM        reduce using rule 103 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    SIMULATION      reduce using rule 103 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    NUMBER          reduce using rule 103 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    STRING          reduce using rule 103 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    (               reduce using rule 103 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    [               reduce using rule 103 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    {               reduce using rule 103 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    TRUE            reduce using rule 103 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    FALSE           reduce using rule 103 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    }               reduce using rule 103 (if_stmt -> IF disjunction { stmt_list } else_stmt .)


state 343

    (104) else_stmt -> ELSE . if_stmt
    (105) else_stmt -> ELSE . { stmt_list }
    (103) if_stmt -> . IF disjunction { stmt_list } else_stmt

    {               shift and go to state 350
    IF              shift and go to state 209

    if_stmt                        shift and go to state 349

state 344

    (106) else_stmt -> epsilon .

    CONTINUE        reduce using rule 106 (else_stmt -> epsilon .)
    BREAK           reduce using rule 106 (else_stmt -> epsilon .)
    RETURN          reduce using rule 106 (else_stmt -> epsilon .)
    IF              reduce using rule 106 (else_stmt -> epsilon .)
    LOOP            reduce using rule 106 (else_stmt -> epsilon .)
    ID              reduce using rule 106 (else_stmt -> epsilon .)
    ORGANISM        reduce using rule 106 (else_stmt -> epsilon .)
    SIMULATION      reduce using rule 106 (else_stmt -> epsilon .)
    NUMBER          reduce using rule 106 (else_stmt -> epsilon .)
    STRING          reduce using rule 106 (else_stmt -> epsilon .)
    (               reduce using rule 106 (else_stmt -> epsilon .)
    [               reduce using rule 106 (else_stmt -> epsilon .)
    {               reduce using rule 106 (else_stmt -> epsilon .)
    TRUE            reduce using rule 106 (else_stmt -> epsilon .)
    FALSE           reduce using rule 106 (else_stmt -> epsilon .)
    }               reduce using rule 106 (else_stmt -> epsilon .)


state 345

    (102) index_stmt -> naming [ disjunction ] = disjunction .

    ;               reduce using rule 102 (index_stmt -> naming [ disjunction ] = disjunction .)


state 346

    (107) loop_stmt -> LOOP loop_init , loop_condition , loop_set . { stmt_list }

    {               shift and go to state 351


state 347

    (110) loop_set -> var_stmt .

    {               reduce using rule 110 (loop_set -> var_stmt .)


state 348

    (111) loop_set -> epsilon .

    {               reduce using rule 111 (loop_set -> epsilon .)


state 349

    (104) else_stmt -> ELSE if_stmt .

    CONTINUE        reduce using rule 104 (else_stmt -> ELSE if_stmt .)
    BREAK           reduce using rule 104 (else_stmt -> ELSE if_stmt .)
    RETURN          reduce using rule 104 (else_stmt -> ELSE if_stmt .)
    IF              reduce using rule 104 (else_stmt -> ELSE if_stmt .)
    LOOP            reduce using rule 104 (else_stmt -> ELSE if_stmt .)
    ID              reduce using rule 104 (else_stmt -> ELSE if_stmt .)
    ORGANISM        reduce using rule 104 (else_stmt -> ELSE if_stmt .)
    SIMULATION      reduce using rule 104 (else_stmt -> ELSE if_stmt .)
    NUMBER          reduce using rule 104 (else_stmt -> ELSE if_stmt .)
    STRING          reduce using rule 104 (else_stmt -> ELSE if_stmt .)
    (               reduce using rule 104 (else_stmt -> ELSE if_stmt .)
    [               reduce using rule 104 (else_stmt -> ELSE if_stmt .)
    {               reduce using rule 104 (else_stmt -> ELSE if_stmt .)
    TRUE            reduce using rule 104 (else_stmt -> ELSE if_stmt .)
    FALSE           reduce using rule 104 (else_stmt -> ELSE if_stmt .)
    }               reduce using rule 104 (else_stmt -> ELSE if_stmt .)


state 350

    (105) else_stmt -> ELSE { . stmt_list }
    (91) stmt_list -> . stmt stmt_list
    (92) stmt_list -> . epsilon
    (93) stmt -> . if_stmt
    (94) stmt -> . var_stmt ;
    (95) stmt -> . index_stmt ;
    (96) stmt -> . loop_stmt
    (97) stmt -> . CONTINUE ;
    (98) stmt -> . BREAK ;
    (99) stmt -> . RETURN disjunction ;
    (100) stmt -> . RETURN ;
    (2) epsilon -> .
    (103) if_stmt -> . IF disjunction { stmt_list } else_stmt
    (101) var_stmt -> . accessing = disjunction
    (102) index_stmt -> . naming [ disjunction ] = disjunction
    (107) loop_stmt -> . LOOP loop_init , loop_condition , loop_set { stmt_list }
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (155) bool -> . TRUE
    (156) bool -> . FALSE

    CONTINUE        shift and go to state 206
    BREAK           shift and go to state 207
    RETURN          shift and go to state 208
    }               reduce using rule 2 (epsilon -> .)
    IF              shift and go to state 209
    LOOP            shift and go to state 213
    ID              shift and go to state 215
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103

    stmt_list                      shift and go to state 352
    stmt                           shift and go to state 200
    epsilon                        shift and go to state 201
    if_stmt                        shift and go to state 202
    var_stmt                       shift and go to state 203
    index_stmt                     shift and go to state 204
    loop_stmt                      shift and go to state 205
    accessing                      shift and go to state 210
    naming                         shift and go to state 211
    word                           shift and go to state 214
    atom                           shift and go to state 217
    bool                           shift and go to state 221

state 351

    (107) loop_stmt -> LOOP loop_init , loop_condition , loop_set { . stmt_list }
    (91) stmt_list -> . stmt stmt_list
    (92) stmt_list -> . epsilon
    (93) stmt -> . if_stmt
    (94) stmt -> . var_stmt ;
    (95) stmt -> . index_stmt ;
    (96) stmt -> . loop_stmt
    (97) stmt -> . CONTINUE ;
    (98) stmt -> . BREAK ;
    (99) stmt -> . RETURN disjunction ;
    (100) stmt -> . RETURN ;
    (2) epsilon -> .
    (103) if_stmt -> . IF disjunction { stmt_list } else_stmt
    (101) var_stmt -> . accessing = disjunction
    (102) index_stmt -> . naming [ disjunction ] = disjunction
    (107) loop_stmt -> . LOOP loop_init , loop_condition , loop_set { stmt_list }
    (150) accessing -> . word
    (151) accessing -> . word . accessing
    (140) naming -> . naming [ disjunction ]
    (141) naming -> . accessing
    (142) naming -> . ID ( arg_list )
    (143) naming -> . atom
    (152) word -> . ID
    (153) word -> . ORGANISM
    (154) word -> . SIMULATION
    (144) atom -> . NUMBER
    (145) atom -> . STRING
    (146) atom -> . bool
    (147) atom -> . ( expr )
    (148) atom -> . [ arg_list ]
    (149) atom -> . { keyarg_list }
    (155) bool -> . TRUE
    (156) bool -> . FALSE

    CONTINUE        shift and go to state 206
    BREAK           shift and go to state 207
    RETURN          shift and go to state 208
    }               reduce using rule 2 (epsilon -> .)
    IF              shift and go to state 209
    LOOP            shift and go to state 213
    ID              shift and go to state 215
    ORGANISM        shift and go to state 218
    SIMULATION      shift and go to state 197
    NUMBER          shift and go to state 219
    STRING          shift and go to state 220
    (               shift and go to state 216
    [               shift and go to state 212
    {               shift and go to state 198
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103

    stmt_list                      shift and go to state 353
    stmt                           shift and go to state 200
    epsilon                        shift and go to state 201
    if_stmt                        shift and go to state 202
    var_stmt                       shift and go to state 203
    index_stmt                     shift and go to state 204
    loop_stmt                      shift and go to state 205
    accessing                      shift and go to state 210
    naming                         shift and go to state 211
    word                           shift and go to state 214
    atom                           shift and go to state 217
    bool                           shift and go to state 221

state 352

    (105) else_stmt -> ELSE { stmt_list . }

    }               shift and go to state 354


state 353

    (107) loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list . }

    }               shift and go to state 355


state 354

    (105) else_stmt -> ELSE { stmt_list } .

    CONTINUE        reduce using rule 105 (else_stmt -> ELSE { stmt_list } .)
    BREAK           reduce using rule 105 (else_stmt -> ELSE { stmt_list } .)
    RETURN          reduce using rule 105 (else_stmt -> ELSE { stmt_list } .)
    IF              reduce using rule 105 (else_stmt -> ELSE { stmt_list } .)
    LOOP            reduce using rule 105 (else_stmt -> ELSE { stmt_list } .)
    ID              reduce using rule 105 (else_stmt -> ELSE { stmt_list } .)
    ORGANISM        reduce using rule 105 (else_stmt -> ELSE { stmt_list } .)
    SIMULATION      reduce using rule 105 (else_stmt -> ELSE { stmt_list } .)
    NUMBER          reduce using rule 105 (else_stmt -> ELSE { stmt_list } .)
    STRING          reduce using rule 105 (else_stmt -> ELSE { stmt_list } .)
    (               reduce using rule 105 (else_stmt -> ELSE { stmt_list } .)
    [               reduce using rule 105 (else_stmt -> ELSE { stmt_list } .)
    {               reduce using rule 105 (else_stmt -> ELSE { stmt_list } .)
    TRUE            reduce using rule 105 (else_stmt -> ELSE { stmt_list } .)
    FALSE           reduce using rule 105 (else_stmt -> ELSE { stmt_list } .)
    }               reduce using rule 105 (else_stmt -> ELSE { stmt_list } .)


state 355

    (107) loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .

    CONTINUE        reduce using rule 107 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    BREAK           reduce using rule 107 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    RETURN          reduce using rule 107 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    IF              reduce using rule 107 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    LOOP            reduce using rule 107 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    ID              reduce using rule 107 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    ORGANISM        reduce using rule 107 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    SIMULATION      reduce using rule 107 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    NUMBER          reduce using rule 107 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    STRING          reduce using rule 107 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    (               reduce using rule 107 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    [               reduce using rule 107 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    {               reduce using rule 107 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    TRUE            reduce using rule 107 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    FALSE           reduce using rule 107 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    }               reduce using rule 107 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)

