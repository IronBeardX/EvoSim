Created by PLY (http://www.dabeaz.com/ply)

Unused terminals:

    newline

Grammar

Rule 0     S' -> test
Rule 1     program -> gene_stmt_list dna_stmt_list behavior_stmt_list entity_org_stmt_list world_stmt sim_stmt
Rule 2     epsilon -> <empty>
Rule 3     test -> program
Rule 4     gene_stmt_list -> gene_stmt gene_stmt_list
Rule 5     gene_stmt_list -> epsilon
Rule 6     gene_stmt -> GENE phygene_stmt
Rule 7     gene_stmt -> GENE percpgene
Rule 8     gene_stmt -> GENE actgene_stmt
Rule 9     percpgene -> SMELLING
Rule 10    percpgene -> VISION
Rule 11    actgene_stmt -> actgene ID { COST NUMBER }
Rule 12    actgene -> MOVE
Rule 13    actgene -> EAT
Rule 14    actgene -> REPRODUCE
Rule 15    actgene -> ATTACK
Rule 16    actgene -> DEFEND
Rule 17    actgene -> PICK
Rule 18    actgene -> SWIM
Rule 19    phygene_stmt -> phygene ID { phygeneprop phygeneprop }
Rule 20    phygene -> HEALTH
Rule 21    phygene -> HUNGER
Rule 22    phygene -> LEGS
Rule 23    phygene -> EYES
Rule 24    phygene -> ARMS
Rule 25    phygene -> HORNS
Rule 26    phygene -> SMELL
Rule 27    phygene -> FINS
Rule 28    phygene -> NOSE
Rule 29    phygene -> MOUTH
Rule 30    phygeneprop -> VALUE NUMBER IN { NUMBER NUMBER }
Rule 31    phygeneprop -> MUTATION { mutationprop mutationprop }
Rule 32    mutationprop -> CHANCE NUMBER
Rule 33    mutationprop -> STEP NUMBER
Rule 34    dna_stmt_list -> dna_stmt dna_stmt_list
Rule 35    dna_stmt_list -> epsilon
Rule 36    dna_stmt -> DNA ID { dna_elem_list }
Rule 37    dna_elem_list -> dna_elem dna_elem_list
Rule 38    dna_elem_list -> epsilon
Rule 39    dna_elem -> ID
Rule 40    dna_elem -> SMELLING
Rule 41    dna_elem -> VISION
Rule 42    dna_elem -> DNA ID
Rule 43    behavior_stmt_list -> behavior_stmt behavior_stmt_list
Rule 44    behavior_stmt_list -> epsilon
Rule 45    behavior_stmt -> BEHAVIOR ID { func_stmt_list decide_stmt }
Rule 46    behavior_stmt -> BEHAVIOR ID
Rule 47    decide_stmt -> DECIDE ORGANISM TIME { stmt_list }
Rule 48    entity_org_stmt_list -> entity_stmt entity_org_stmt_list
Rule 49    entity_org_stmt_list -> organism_stmt entity_org_stmt_list
Rule 50    entity_org_stmt_list -> epsilon
Rule 51    entity_stmt -> ENTITY { entityprop entityprop entityprop }
Rule 52    entityprop -> COEXISTENCE bool
Rule 53    entityprop -> REPR ID
Rule 54    entityprop -> AT { position position_list }
Rule 55    organism_stmt -> ORGANISM { orgprop orgprop orgprop orgprop }
Rule 56    orgprop -> DNA ID
Rule 57    orgprop -> BEHAVIOR ID
Rule 58    orgprop -> REPR ID
Rule 59    orgprop -> AT { position position_list }
Rule 60    position_list -> position position_list
Rule 61    position_list -> epsilon
Rule 62    position -> ( NUMBER NUMBER )
Rule 63    world_stmt -> WORLD { worldprop worldprop }
Rule 64    worldprop -> SIZE worldsize
Rule 65    worldprop -> TERRAIN worldterrain
Rule 66    worldsize -> INFINITE { worldsizeprop worldsizeprop }
Rule 67    worldsize -> { worldsizeprop worldsizeprop }
Rule 68    worldsizeprop -> WIDTH NUMBER
Rule 69    worldsizeprop -> HEIGHT NUMBER
Rule 70    worldterrain -> { terrainprop_list }
Rule 71    terrainprop_list -> terrainprop terrainprop_list
Rule 72    terrainprop_list -> epsilon
Rule 73    terrainprop -> ID
Rule 74    terrainprop -> DEFAULT ID
Rule 75    terrainprop -> ID AT { NUMBER terrainposn_list }
Rule 76    terrainposn_list -> NUMBER terrainposn_list
Rule 77    terrainposn_list -> epsilon
Rule 78    sim_stmt -> SIMULATION { simprop simprop simprop simprop simprop }
Rule 79    simprop -> EPISODES NUMBER
Rule 80    simprop -> MAX_ROUNDS NUMBER
Rule 81    simprop -> ACTIONS_TIME NUMBER
Rule 82    simprop -> STOP SIMULATION { stmt_list }
Rule 83    simprop -> AVAILABLE_COMMANDS { command_list }
Rule 84    command_list -> ID command_list
Rule 85    command_list -> epsilon
Rule 86    func_stmt_list -> func_stmt func_stmt_list
Rule 87    func_stmt_list -> epsilon
Rule 88    func_stmt -> FUNC ID = param_list { stmt_list }
Rule 89    param_list -> ID param_list
Rule 90    param_list -> epsilon
Rule 91    stmt_list -> stmt stmt_list
Rule 92    stmt_list -> epsilon
Rule 93    stmt -> if_stmt
Rule 94    stmt -> var_stmt ;
Rule 95    stmt -> index_stmt ;
Rule 96    stmt -> disjunction ;
Rule 97    stmt -> loop_stmt
Rule 98    stmt -> CONTINUE ;
Rule 99    stmt -> BREAK ;
Rule 100   stmt -> RETURN disjunction ;
Rule 101   stmt -> RETURN ;
Rule 102   var_stmt -> accessing = disjunction
Rule 103   index_stmt -> naming [ disjunction ] = disjunction
Rule 104   if_stmt -> IF disjunction { stmt_list } else_stmt
Rule 105   else_stmt -> ELSE if_stmt
Rule 106   else_stmt -> ELSE { stmt_list }
Rule 107   else_stmt -> epsilon
Rule 108   loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list }
Rule 109   loop_init -> var_stmt
Rule 110   loop_init -> epsilon
Rule 111   loop_set -> var_stmt
Rule 112   loop_set -> epsilon
Rule 113   loop_condition -> disjunction
Rule 114   loop_condition -> epsilon
Rule 115   disjunction -> conjunction OR conjunction
Rule 116   disjunction -> conjunction
Rule 117   conjunction -> negation AND negation
Rule 118   conjunction -> negation
Rule 119   negation -> NOT comparison
Rule 120   negation -> comparison
Rule 121   comparison -> expr EQ expr
Rule 122   comparison -> expr NEQ expr
Rule 123   comparison -> expr GE expr
Rule 124   comparison -> expr LE expr
Rule 125   comparison -> expr > expr
Rule 126   comparison -> expr < expr
Rule 127   comparison -> expr
Rule 128   expr -> expr + term
Rule 129   expr -> expr - term
Rule 130   expr -> term
Rule 131   term -> term * factor
Rule 132   term -> term / factor
Rule 133   term -> term % factor
Rule 134   term -> term INTDIV factor
Rule 135   term -> factor
Rule 136   factor -> - factor
Rule 137   factor -> power
Rule 138   power -> atom ^ factor
Rule 139   power -> atom @ factor
Rule 140   power -> naming
Rule 141   naming -> naming [ disjunction ]
Rule 142   naming -> accessing
Rule 143   naming -> KEYS ( naming )
Rule 144   naming -> ID ( arg_list )
Rule 145   naming -> atom
Rule 146   atom -> NUMBER
Rule 147   atom -> STRING
Rule 148   atom -> bool
Rule 149   atom -> ( expr )
Rule 150   atom -> [ arg_list ]
Rule 151   atom -> { keyarg_list }
Rule 152   accessing -> word
Rule 153   accessing -> word . accessing
Rule 154   word -> ID
Rule 155   word -> ORGANISM
Rule 156   word -> SIMULATION
Rule 157   word -> WORLD
Rule 158   bool -> TRUE
Rule 159   bool -> FALSE
Rule 160   arg_list -> disjunction
Rule 161   arg_list -> disjunction , arg_list
Rule 162   arg_list -> epsilon
Rule 163   keyarg_list -> keyarg
Rule 164   keyarg_list -> keyarg , keyarg_list
Rule 165   keyarg_list -> epsilon
Rule 166   keyarg -> disjunction = disjunction
Rule 167   test_world -> world_stmt

Terminals, with rules where they appear

%                    : 133
(                    : 62 143 144 149
)                    : 62 143 144 149
*                    : 131
+                    : 128
,                    : 108 108 161 164
-                    : 129 136
.                    : 153
/                    : 132
;                    : 94 95 96 98 99 100 101
<                    : 126
=                    : 88 102 103 166
>                    : 125
@                    : 139
ACTIONS_TIME         : 81
AND                  : 117
ARMS                 : 24
AT                   : 54 59 75
ATTACK               : 15
AVAILABLE_COMMANDS   : 83
BEHAVIOR             : 45 46 57
BREAK                : 99
CHANCE               : 32
COEXISTENCE          : 52
CONTINUE             : 98
COST                 : 11
DECIDE               : 47
DEFAULT              : 74
DEFEND               : 16
DNA                  : 36 42 56
EAT                  : 13
ELSE                 : 105 106
ENTITY               : 51
EPISODES             : 79
EQ                   : 121
EYES                 : 23
FALSE                : 159
FINS                 : 27
FUNC                 : 88
GE                   : 123
GENE                 : 6 7 8
HEALTH               : 20
HEIGHT               : 69
HORNS                : 25
HUNGER               : 21
ID                   : 11 19 36 39 42 45 46 53 56 57 58 73 74 75 84 88 89 144 154
IF                   : 104
IN                   : 30
INFINITE             : 66
INTDIV               : 134
KEYS                 : 143
LE                   : 124
LEGS                 : 22
LOOP                 : 108
MAX_ROUNDS           : 80
MOUTH                : 29
MOVE                 : 12
MUTATION             : 31
NEQ                  : 122
NOSE                 : 28
NOT                  : 119
NUMBER               : 11 30 30 30 32 33 62 62 68 69 75 76 79 80 81 146
OR                   : 115
ORGANISM             : 47 55 155
PICK                 : 17
REPR                 : 53 58
REPRODUCE            : 14
RETURN               : 100 101
SIMULATION           : 78 82 156
SIZE                 : 64
SMELL                : 26
SMELLING             : 9 40
STEP                 : 33
STOP                 : 82
STRING               : 147
SWIM                 : 18
TERRAIN              : 65
TIME                 : 47
TRUE                 : 158
VALUE                : 30
VISION               : 10 41
WIDTH                : 68
WORLD                : 63 157
[                    : 103 141 150
]                    : 103 141 150
^                    : 138
error                : 
newline              : 
{                    : 11 19 30 31 36 45 47 51 54 55 59 63 66 67 70 75 78 82 83 88 104 106 108 151
}                    : 11 19 30 31 36 45 47 51 54 55 59 63 66 67 70 75 78 82 83 88 104 106 108 151

Nonterminals, with rules where they appear

accessing            : 102 142 153
actgene              : 11
actgene_stmt         : 8
arg_list             : 144 150 161
atom                 : 138 139 145
behavior_stmt        : 43
behavior_stmt_list   : 1 43
bool                 : 52 148
command_list         : 83 84
comparison           : 119 120
conjunction          : 115 115 116
decide_stmt          : 45
disjunction          : 96 100 102 103 103 104 113 141 160 161 166 166
dna_elem             : 37
dna_elem_list        : 36 37
dna_stmt             : 34
dna_stmt_list        : 1 34
else_stmt            : 104
entity_org_stmt_list : 1 48 49
entity_stmt          : 48
entityprop           : 51 51 51
epsilon              : 5 35 38 44 50 61 72 77 85 87 90 92 107 110 112 114 162 165
expr                 : 121 121 122 122 123 123 124 124 125 125 126 126 127 128 129 149
factor               : 131 132 133 134 135 136 138 139
func_stmt            : 86
func_stmt_list       : 45 86
gene_stmt            : 4
gene_stmt_list       : 1 4
if_stmt              : 93 105
index_stmt           : 95
keyarg               : 163 164
keyarg_list          : 151 164
loop_condition       : 108
loop_init            : 108
loop_set             : 108
loop_stmt            : 97
mutationprop         : 31 31
naming               : 103 140 141 143
negation             : 117 117 118
organism_stmt        : 49
orgprop              : 55 55 55 55
param_list           : 88 89
percpgene            : 7
phygene              : 19
phygene_stmt         : 6
phygeneprop          : 19 19
position             : 54 59 60
position_list        : 54 59 60
power                : 137
program              : 3
sim_stmt             : 1
simprop              : 78 78 78 78 78
stmt                 : 91
stmt_list            : 47 82 88 91 104 106 108
term                 : 128 129 130 131 132 133 134
terrainposn_list     : 75 76
terrainprop          : 71
terrainprop_list     : 70 71
test                 : 0
test_world           : 
var_stmt             : 94 109 111
word                 : 152 153
world_stmt           : 1 167
worldprop            : 63 63
worldsize            : 64
worldsizeprop        : 66 66 67 67
worldterrain         : 65


state 0

    (0) S' -> . test
    (3) test -> . program
    (1) program -> . gene_stmt_list dna_stmt_list behavior_stmt_list entity_org_stmt_list world_stmt sim_stmt
    (4) gene_stmt_list -> . gene_stmt gene_stmt_list
    (5) gene_stmt_list -> . epsilon
    (6) gene_stmt -> . GENE phygene_stmt
    (7) gene_stmt -> . GENE percpgene
    (8) gene_stmt -> . GENE actgene_stmt
    (2) epsilon -> .

    GENE            shift and go to state 6
    DNA             reduce using rule 2 (epsilon -> .)
    BEHAVIOR        reduce using rule 2 (epsilon -> .)
    ENTITY          reduce using rule 2 (epsilon -> .)
    ORGANISM        reduce using rule 2 (epsilon -> .)
    WORLD           reduce using rule 2 (epsilon -> .)

    test                           shift and go to state 1
    program                        shift and go to state 2
    gene_stmt_list                 shift and go to state 3
    gene_stmt                      shift and go to state 4
    epsilon                        shift and go to state 5

state 1

    (0) S' -> test .



state 2

    (3) test -> program .

    $end            reduce using rule 3 (test -> program .)


state 3

    (1) program -> gene_stmt_list . dna_stmt_list behavior_stmt_list entity_org_stmt_list world_stmt sim_stmt
    (34) dna_stmt_list -> . dna_stmt dna_stmt_list
    (35) dna_stmt_list -> . epsilon
    (36) dna_stmt -> . DNA ID { dna_elem_list }
    (2) epsilon -> .

    DNA             shift and go to state 10
    BEHAVIOR        reduce using rule 2 (epsilon -> .)
    ENTITY          reduce using rule 2 (epsilon -> .)
    ORGANISM        reduce using rule 2 (epsilon -> .)
    WORLD           reduce using rule 2 (epsilon -> .)

    dna_stmt_list                  shift and go to state 7
    dna_stmt                       shift and go to state 8
    epsilon                        shift and go to state 9

state 4

    (4) gene_stmt_list -> gene_stmt . gene_stmt_list
    (4) gene_stmt_list -> . gene_stmt gene_stmt_list
    (5) gene_stmt_list -> . epsilon
    (6) gene_stmt -> . GENE phygene_stmt
    (7) gene_stmt -> . GENE percpgene
    (8) gene_stmt -> . GENE actgene_stmt
    (2) epsilon -> .

    GENE            shift and go to state 6
    DNA             reduce using rule 2 (epsilon -> .)
    BEHAVIOR        reduce using rule 2 (epsilon -> .)
    ENTITY          reduce using rule 2 (epsilon -> .)
    ORGANISM        reduce using rule 2 (epsilon -> .)
    WORLD           reduce using rule 2 (epsilon -> .)

    gene_stmt                      shift and go to state 4
    gene_stmt_list                 shift and go to state 11
    epsilon                        shift and go to state 5

state 5

    (5) gene_stmt_list -> epsilon .

    DNA             reduce using rule 5 (gene_stmt_list -> epsilon .)
    BEHAVIOR        reduce using rule 5 (gene_stmt_list -> epsilon .)
    ENTITY          reduce using rule 5 (gene_stmt_list -> epsilon .)
    ORGANISM        reduce using rule 5 (gene_stmt_list -> epsilon .)
    WORLD           reduce using rule 5 (gene_stmt_list -> epsilon .)


state 6

    (6) gene_stmt -> GENE . phygene_stmt
    (7) gene_stmt -> GENE . percpgene
    (8) gene_stmt -> GENE . actgene_stmt
    (19) phygene_stmt -> . phygene ID { phygeneprop phygeneprop }
    (9) percpgene -> . SMELLING
    (10) percpgene -> . VISION
    (11) actgene_stmt -> . actgene ID { COST NUMBER }
    (20) phygene -> . HEALTH
    (21) phygene -> . HUNGER
    (22) phygene -> . LEGS
    (23) phygene -> . EYES
    (24) phygene -> . ARMS
    (25) phygene -> . HORNS
    (26) phygene -> . SMELL
    (27) phygene -> . FINS
    (28) phygene -> . NOSE
    (29) phygene -> . MOUTH
    (12) actgene -> . MOVE
    (13) actgene -> . EAT
    (14) actgene -> . REPRODUCE
    (15) actgene -> . ATTACK
    (16) actgene -> . DEFEND
    (17) actgene -> . PICK
    (18) actgene -> . SWIM

    SMELLING        shift and go to state 16
    VISION          shift and go to state 17
    HEALTH          shift and go to state 19
    HUNGER          shift and go to state 20
    LEGS            shift and go to state 21
    EYES            shift and go to state 22
    ARMS            shift and go to state 23
    HORNS           shift and go to state 24
    SMELL           shift and go to state 25
    FINS            shift and go to state 26
    NOSE            shift and go to state 27
    MOUTH           shift and go to state 28
    MOVE            shift and go to state 29
    EAT             shift and go to state 30
    REPRODUCE       shift and go to state 31
    ATTACK          shift and go to state 32
    DEFEND          shift and go to state 33
    PICK            shift and go to state 34
    SWIM            shift and go to state 35

    phygene_stmt                   shift and go to state 12
    percpgene                      shift and go to state 13
    actgene_stmt                   shift and go to state 14
    phygene                        shift and go to state 15
    actgene                        shift and go to state 18

state 7

    (1) program -> gene_stmt_list dna_stmt_list . behavior_stmt_list entity_org_stmt_list world_stmt sim_stmt
    (43) behavior_stmt_list -> . behavior_stmt behavior_stmt_list
    (44) behavior_stmt_list -> . epsilon
    (45) behavior_stmt -> . BEHAVIOR ID { func_stmt_list decide_stmt }
    (46) behavior_stmt -> . BEHAVIOR ID
    (2) epsilon -> .

    BEHAVIOR        shift and go to state 39
    ENTITY          reduce using rule 2 (epsilon -> .)
    ORGANISM        reduce using rule 2 (epsilon -> .)
    WORLD           reduce using rule 2 (epsilon -> .)

    behavior_stmt_list             shift and go to state 36
    behavior_stmt                  shift and go to state 37
    epsilon                        shift and go to state 38

state 8

    (34) dna_stmt_list -> dna_stmt . dna_stmt_list
    (34) dna_stmt_list -> . dna_stmt dna_stmt_list
    (35) dna_stmt_list -> . epsilon
    (36) dna_stmt -> . DNA ID { dna_elem_list }
    (2) epsilon -> .

    DNA             shift and go to state 10
    BEHAVIOR        reduce using rule 2 (epsilon -> .)
    ENTITY          reduce using rule 2 (epsilon -> .)
    ORGANISM        reduce using rule 2 (epsilon -> .)
    WORLD           reduce using rule 2 (epsilon -> .)

    dna_stmt                       shift and go to state 8
    dna_stmt_list                  shift and go to state 40
    epsilon                        shift and go to state 9

state 9

    (35) dna_stmt_list -> epsilon .

    BEHAVIOR        reduce using rule 35 (dna_stmt_list -> epsilon .)
    ENTITY          reduce using rule 35 (dna_stmt_list -> epsilon .)
    ORGANISM        reduce using rule 35 (dna_stmt_list -> epsilon .)
    WORLD           reduce using rule 35 (dna_stmt_list -> epsilon .)


state 10

    (36) dna_stmt -> DNA . ID { dna_elem_list }

    ID              shift and go to state 41


state 11

    (4) gene_stmt_list -> gene_stmt gene_stmt_list .

    DNA             reduce using rule 4 (gene_stmt_list -> gene_stmt gene_stmt_list .)
    BEHAVIOR        reduce using rule 4 (gene_stmt_list -> gene_stmt gene_stmt_list .)
    ENTITY          reduce using rule 4 (gene_stmt_list -> gene_stmt gene_stmt_list .)
    ORGANISM        reduce using rule 4 (gene_stmt_list -> gene_stmt gene_stmt_list .)
    WORLD           reduce using rule 4 (gene_stmt_list -> gene_stmt gene_stmt_list .)


state 12

    (6) gene_stmt -> GENE phygene_stmt .

    GENE            reduce using rule 6 (gene_stmt -> GENE phygene_stmt .)
    DNA             reduce using rule 6 (gene_stmt -> GENE phygene_stmt .)
    BEHAVIOR        reduce using rule 6 (gene_stmt -> GENE phygene_stmt .)
    ENTITY          reduce using rule 6 (gene_stmt -> GENE phygene_stmt .)
    ORGANISM        reduce using rule 6 (gene_stmt -> GENE phygene_stmt .)
    WORLD           reduce using rule 6 (gene_stmt -> GENE phygene_stmt .)


state 13

    (7) gene_stmt -> GENE percpgene .

    GENE            reduce using rule 7 (gene_stmt -> GENE percpgene .)
    DNA             reduce using rule 7 (gene_stmt -> GENE percpgene .)
    BEHAVIOR        reduce using rule 7 (gene_stmt -> GENE percpgene .)
    ENTITY          reduce using rule 7 (gene_stmt -> GENE percpgene .)
    ORGANISM        reduce using rule 7 (gene_stmt -> GENE percpgene .)
    WORLD           reduce using rule 7 (gene_stmt -> GENE percpgene .)


state 14

    (8) gene_stmt -> GENE actgene_stmt .

    GENE            reduce using rule 8 (gene_stmt -> GENE actgene_stmt .)
    DNA             reduce using rule 8 (gene_stmt -> GENE actgene_stmt .)
    BEHAVIOR        reduce using rule 8 (gene_stmt -> GENE actgene_stmt .)
    ENTITY          reduce using rule 8 (gene_stmt -> GENE actgene_stmt .)
    ORGANISM        reduce using rule 8 (gene_stmt -> GENE actgene_stmt .)
    WORLD           reduce using rule 8 (gene_stmt -> GENE actgene_stmt .)


state 15

    (19) phygene_stmt -> phygene . ID { phygeneprop phygeneprop }

    ID              shift and go to state 42


state 16

    (9) percpgene -> SMELLING .

    GENE            reduce using rule 9 (percpgene -> SMELLING .)
    DNA             reduce using rule 9 (percpgene -> SMELLING .)
    BEHAVIOR        reduce using rule 9 (percpgene -> SMELLING .)
    ENTITY          reduce using rule 9 (percpgene -> SMELLING .)
    ORGANISM        reduce using rule 9 (percpgene -> SMELLING .)
    WORLD           reduce using rule 9 (percpgene -> SMELLING .)


state 17

    (10) percpgene -> VISION .

    GENE            reduce using rule 10 (percpgene -> VISION .)
    DNA             reduce using rule 10 (percpgene -> VISION .)
    BEHAVIOR        reduce using rule 10 (percpgene -> VISION .)
    ENTITY          reduce using rule 10 (percpgene -> VISION .)
    ORGANISM        reduce using rule 10 (percpgene -> VISION .)
    WORLD           reduce using rule 10 (percpgene -> VISION .)


state 18

    (11) actgene_stmt -> actgene . ID { COST NUMBER }

    ID              shift and go to state 43


state 19

    (20) phygene -> HEALTH .

    ID              reduce using rule 20 (phygene -> HEALTH .)


state 20

    (21) phygene -> HUNGER .

    ID              reduce using rule 21 (phygene -> HUNGER .)


state 21

    (22) phygene -> LEGS .

    ID              reduce using rule 22 (phygene -> LEGS .)


state 22

    (23) phygene -> EYES .

    ID              reduce using rule 23 (phygene -> EYES .)


state 23

    (24) phygene -> ARMS .

    ID              reduce using rule 24 (phygene -> ARMS .)


state 24

    (25) phygene -> HORNS .

    ID              reduce using rule 25 (phygene -> HORNS .)


state 25

    (26) phygene -> SMELL .

    ID              reduce using rule 26 (phygene -> SMELL .)


state 26

    (27) phygene -> FINS .

    ID              reduce using rule 27 (phygene -> FINS .)


state 27

    (28) phygene -> NOSE .

    ID              reduce using rule 28 (phygene -> NOSE .)


state 28

    (29) phygene -> MOUTH .

    ID              reduce using rule 29 (phygene -> MOUTH .)


state 29

    (12) actgene -> MOVE .

    ID              reduce using rule 12 (actgene -> MOVE .)


state 30

    (13) actgene -> EAT .

    ID              reduce using rule 13 (actgene -> EAT .)


state 31

    (14) actgene -> REPRODUCE .

    ID              reduce using rule 14 (actgene -> REPRODUCE .)


state 32

    (15) actgene -> ATTACK .

    ID              reduce using rule 15 (actgene -> ATTACK .)


state 33

    (16) actgene -> DEFEND .

    ID              reduce using rule 16 (actgene -> DEFEND .)


state 34

    (17) actgene -> PICK .

    ID              reduce using rule 17 (actgene -> PICK .)


state 35

    (18) actgene -> SWIM .

    ID              reduce using rule 18 (actgene -> SWIM .)


state 36

    (1) program -> gene_stmt_list dna_stmt_list behavior_stmt_list . entity_org_stmt_list world_stmt sim_stmt
    (48) entity_org_stmt_list -> . entity_stmt entity_org_stmt_list
    (49) entity_org_stmt_list -> . organism_stmt entity_org_stmt_list
    (50) entity_org_stmt_list -> . epsilon
    (51) entity_stmt -> . ENTITY { entityprop entityprop entityprop }
    (55) organism_stmt -> . ORGANISM { orgprop orgprop orgprop orgprop }
    (2) epsilon -> .

    ENTITY          shift and go to state 48
    ORGANISM        shift and go to state 49
    WORLD           reduce using rule 2 (epsilon -> .)

    entity_org_stmt_list           shift and go to state 44
    entity_stmt                    shift and go to state 45
    organism_stmt                  shift and go to state 46
    epsilon                        shift and go to state 47

state 37

    (43) behavior_stmt_list -> behavior_stmt . behavior_stmt_list
    (43) behavior_stmt_list -> . behavior_stmt behavior_stmt_list
    (44) behavior_stmt_list -> . epsilon
    (45) behavior_stmt -> . BEHAVIOR ID { func_stmt_list decide_stmt }
    (46) behavior_stmt -> . BEHAVIOR ID
    (2) epsilon -> .

    BEHAVIOR        shift and go to state 39
    ENTITY          reduce using rule 2 (epsilon -> .)
    ORGANISM        reduce using rule 2 (epsilon -> .)
    WORLD           reduce using rule 2 (epsilon -> .)

    behavior_stmt                  shift and go to state 37
    behavior_stmt_list             shift and go to state 50
    epsilon                        shift and go to state 38

state 38

    (44) behavior_stmt_list -> epsilon .

    ENTITY          reduce using rule 44 (behavior_stmt_list -> epsilon .)
    ORGANISM        reduce using rule 44 (behavior_stmt_list -> epsilon .)
    WORLD           reduce using rule 44 (behavior_stmt_list -> epsilon .)


state 39

    (45) behavior_stmt -> BEHAVIOR . ID { func_stmt_list decide_stmt }
    (46) behavior_stmt -> BEHAVIOR . ID

    ID              shift and go to state 51


state 40

    (34) dna_stmt_list -> dna_stmt dna_stmt_list .

    BEHAVIOR        reduce using rule 34 (dna_stmt_list -> dna_stmt dna_stmt_list .)
    ENTITY          reduce using rule 34 (dna_stmt_list -> dna_stmt dna_stmt_list .)
    ORGANISM        reduce using rule 34 (dna_stmt_list -> dna_stmt dna_stmt_list .)
    WORLD           reduce using rule 34 (dna_stmt_list -> dna_stmt dna_stmt_list .)


state 41

    (36) dna_stmt -> DNA ID . { dna_elem_list }

    {               shift and go to state 52


state 42

    (19) phygene_stmt -> phygene ID . { phygeneprop phygeneprop }

    {               shift and go to state 53


state 43

    (11) actgene_stmt -> actgene ID . { COST NUMBER }

    {               shift and go to state 54


state 44

    (1) program -> gene_stmt_list dna_stmt_list behavior_stmt_list entity_org_stmt_list . world_stmt sim_stmt
    (63) world_stmt -> . WORLD { worldprop worldprop }

    WORLD           shift and go to state 56

    world_stmt                     shift and go to state 55

state 45

    (48) entity_org_stmt_list -> entity_stmt . entity_org_stmt_list
    (48) entity_org_stmt_list -> . entity_stmt entity_org_stmt_list
    (49) entity_org_stmt_list -> . organism_stmt entity_org_stmt_list
    (50) entity_org_stmt_list -> . epsilon
    (51) entity_stmt -> . ENTITY { entityprop entityprop entityprop }
    (55) organism_stmt -> . ORGANISM { orgprop orgprop orgprop orgprop }
    (2) epsilon -> .

    ENTITY          shift and go to state 48
    ORGANISM        shift and go to state 49
    WORLD           reduce using rule 2 (epsilon -> .)

    entity_stmt                    shift and go to state 45
    entity_org_stmt_list           shift and go to state 57
    organism_stmt                  shift and go to state 46
    epsilon                        shift and go to state 47

state 46

    (49) entity_org_stmt_list -> organism_stmt . entity_org_stmt_list
    (48) entity_org_stmt_list -> . entity_stmt entity_org_stmt_list
    (49) entity_org_stmt_list -> . organism_stmt entity_org_stmt_list
    (50) entity_org_stmt_list -> . epsilon
    (51) entity_stmt -> . ENTITY { entityprop entityprop entityprop }
    (55) organism_stmt -> . ORGANISM { orgprop orgprop orgprop orgprop }
    (2) epsilon -> .

    ENTITY          shift and go to state 48
    ORGANISM        shift and go to state 49
    WORLD           reduce using rule 2 (epsilon -> .)

    organism_stmt                  shift and go to state 46
    entity_org_stmt_list           shift and go to state 58
    entity_stmt                    shift and go to state 45
    epsilon                        shift and go to state 47

state 47

    (50) entity_org_stmt_list -> epsilon .

    WORLD           reduce using rule 50 (entity_org_stmt_list -> epsilon .)


state 48

    (51) entity_stmt -> ENTITY . { entityprop entityprop entityprop }

    {               shift and go to state 59


state 49

    (55) organism_stmt -> ORGANISM . { orgprop orgprop orgprop orgprop }

    {               shift and go to state 60


state 50

    (43) behavior_stmt_list -> behavior_stmt behavior_stmt_list .

    ENTITY          reduce using rule 43 (behavior_stmt_list -> behavior_stmt behavior_stmt_list .)
    ORGANISM        reduce using rule 43 (behavior_stmt_list -> behavior_stmt behavior_stmt_list .)
    WORLD           reduce using rule 43 (behavior_stmt_list -> behavior_stmt behavior_stmt_list .)


state 51

    (45) behavior_stmt -> BEHAVIOR ID . { func_stmt_list decide_stmt }
    (46) behavior_stmt -> BEHAVIOR ID .

    {               shift and go to state 61
    BEHAVIOR        reduce using rule 46 (behavior_stmt -> BEHAVIOR ID .)
    ENTITY          reduce using rule 46 (behavior_stmt -> BEHAVIOR ID .)
    ORGANISM        reduce using rule 46 (behavior_stmt -> BEHAVIOR ID .)
    WORLD           reduce using rule 46 (behavior_stmt -> BEHAVIOR ID .)


state 52

    (36) dna_stmt -> DNA ID { . dna_elem_list }
    (37) dna_elem_list -> . dna_elem dna_elem_list
    (38) dna_elem_list -> . epsilon
    (39) dna_elem -> . ID
    (40) dna_elem -> . SMELLING
    (41) dna_elem -> . VISION
    (42) dna_elem -> . DNA ID
    (2) epsilon -> .

    ID              shift and go to state 63
    SMELLING        shift and go to state 67
    VISION          shift and go to state 68
    DNA             shift and go to state 62
    }               reduce using rule 2 (epsilon -> .)

    dna_elem_list                  shift and go to state 64
    dna_elem                       shift and go to state 65
    epsilon                        shift and go to state 66

state 53

    (19) phygene_stmt -> phygene ID { . phygeneprop phygeneprop }
    (30) phygeneprop -> . VALUE NUMBER IN { NUMBER NUMBER }
    (31) phygeneprop -> . MUTATION { mutationprop mutationprop }

    VALUE           shift and go to state 70
    MUTATION        shift and go to state 71

    phygeneprop                    shift and go to state 69

state 54

    (11) actgene_stmt -> actgene ID { . COST NUMBER }

    COST            shift and go to state 72


state 55

    (1) program -> gene_stmt_list dna_stmt_list behavior_stmt_list entity_org_stmt_list world_stmt . sim_stmt
    (78) sim_stmt -> . SIMULATION { simprop simprop simprop simprop simprop }

    SIMULATION      shift and go to state 74

    sim_stmt                       shift and go to state 73

state 56

    (63) world_stmt -> WORLD . { worldprop worldprop }

    {               shift and go to state 75


state 57

    (48) entity_org_stmt_list -> entity_stmt entity_org_stmt_list .

    WORLD           reduce using rule 48 (entity_org_stmt_list -> entity_stmt entity_org_stmt_list .)


state 58

    (49) entity_org_stmt_list -> organism_stmt entity_org_stmt_list .

    WORLD           reduce using rule 49 (entity_org_stmt_list -> organism_stmt entity_org_stmt_list .)


state 59

    (51) entity_stmt -> ENTITY { . entityprop entityprop entityprop }
    (52) entityprop -> . COEXISTENCE bool
    (53) entityprop -> . REPR ID
    (54) entityprop -> . AT { position position_list }

    COEXISTENCE     shift and go to state 77
    REPR            shift and go to state 78
    AT              shift and go to state 79

    entityprop                     shift and go to state 76

state 60

    (55) organism_stmt -> ORGANISM { . orgprop orgprop orgprop orgprop }
    (56) orgprop -> . DNA ID
    (57) orgprop -> . BEHAVIOR ID
    (58) orgprop -> . REPR ID
    (59) orgprop -> . AT { position position_list }

    DNA             shift and go to state 81
    BEHAVIOR        shift and go to state 82
    REPR            shift and go to state 83
    AT              shift and go to state 84

    orgprop                        shift and go to state 80

state 61

    (45) behavior_stmt -> BEHAVIOR ID { . func_stmt_list decide_stmt }
    (86) func_stmt_list -> . func_stmt func_stmt_list
    (87) func_stmt_list -> . epsilon
    (88) func_stmt -> . FUNC ID = param_list { stmt_list }
    (2) epsilon -> .

    FUNC            shift and go to state 88
    DECIDE          reduce using rule 2 (epsilon -> .)

    func_stmt_list                 shift and go to state 85
    func_stmt                      shift and go to state 86
    epsilon                        shift and go to state 87

state 62

    (42) dna_elem -> DNA . ID

    ID              shift and go to state 89


state 63

    (39) dna_elem -> ID .

    ID              reduce using rule 39 (dna_elem -> ID .)
    SMELLING        reduce using rule 39 (dna_elem -> ID .)
    VISION          reduce using rule 39 (dna_elem -> ID .)
    DNA             reduce using rule 39 (dna_elem -> ID .)
    }               reduce using rule 39 (dna_elem -> ID .)


state 64

    (36) dna_stmt -> DNA ID { dna_elem_list . }

    }               shift and go to state 90


state 65

    (37) dna_elem_list -> dna_elem . dna_elem_list
    (37) dna_elem_list -> . dna_elem dna_elem_list
    (38) dna_elem_list -> . epsilon
    (39) dna_elem -> . ID
    (40) dna_elem -> . SMELLING
    (41) dna_elem -> . VISION
    (42) dna_elem -> . DNA ID
    (2) epsilon -> .

    ID              shift and go to state 63
    SMELLING        shift and go to state 67
    VISION          shift and go to state 68
    DNA             shift and go to state 62
    }               reduce using rule 2 (epsilon -> .)

    dna_elem                       shift and go to state 65
    dna_elem_list                  shift and go to state 91
    epsilon                        shift and go to state 66

state 66

    (38) dna_elem_list -> epsilon .

    }               reduce using rule 38 (dna_elem_list -> epsilon .)


state 67

    (40) dna_elem -> SMELLING .

    ID              reduce using rule 40 (dna_elem -> SMELLING .)
    SMELLING        reduce using rule 40 (dna_elem -> SMELLING .)
    VISION          reduce using rule 40 (dna_elem -> SMELLING .)
    DNA             reduce using rule 40 (dna_elem -> SMELLING .)
    }               reduce using rule 40 (dna_elem -> SMELLING .)


state 68

    (41) dna_elem -> VISION .

    ID              reduce using rule 41 (dna_elem -> VISION .)
    SMELLING        reduce using rule 41 (dna_elem -> VISION .)
    VISION          reduce using rule 41 (dna_elem -> VISION .)
    DNA             reduce using rule 41 (dna_elem -> VISION .)
    }               reduce using rule 41 (dna_elem -> VISION .)


state 69

    (19) phygene_stmt -> phygene ID { phygeneprop . phygeneprop }
    (30) phygeneprop -> . VALUE NUMBER IN { NUMBER NUMBER }
    (31) phygeneprop -> . MUTATION { mutationprop mutationprop }

    VALUE           shift and go to state 70
    MUTATION        shift and go to state 71

    phygeneprop                    shift and go to state 92

state 70

    (30) phygeneprop -> VALUE . NUMBER IN { NUMBER NUMBER }

    NUMBER          shift and go to state 93


state 71

    (31) phygeneprop -> MUTATION . { mutationprop mutationprop }

    {               shift and go to state 94


state 72

    (11) actgene_stmt -> actgene ID { COST . NUMBER }

    NUMBER          shift and go to state 95


state 73

    (1) program -> gene_stmt_list dna_stmt_list behavior_stmt_list entity_org_stmt_list world_stmt sim_stmt .

    $end            reduce using rule 1 (program -> gene_stmt_list dna_stmt_list behavior_stmt_list entity_org_stmt_list world_stmt sim_stmt .)


state 74

    (78) sim_stmt -> SIMULATION . { simprop simprop simprop simprop simprop }

    {               shift and go to state 96


state 75

    (63) world_stmt -> WORLD { . worldprop worldprop }
    (64) worldprop -> . SIZE worldsize
    (65) worldprop -> . TERRAIN worldterrain

    SIZE            shift and go to state 98
    TERRAIN         shift and go to state 99

    worldprop                      shift and go to state 97

state 76

    (51) entity_stmt -> ENTITY { entityprop . entityprop entityprop }
    (52) entityprop -> . COEXISTENCE bool
    (53) entityprop -> . REPR ID
    (54) entityprop -> . AT { position position_list }

    COEXISTENCE     shift and go to state 77
    REPR            shift and go to state 78
    AT              shift and go to state 79

    entityprop                     shift and go to state 100

state 77

    (52) entityprop -> COEXISTENCE . bool
    (158) bool -> . TRUE
    (159) bool -> . FALSE

    TRUE            shift and go to state 102
    FALSE           shift and go to state 103

    bool                           shift and go to state 101

state 78

    (53) entityprop -> REPR . ID

    ID              shift and go to state 104


state 79

    (54) entityprop -> AT . { position position_list }

    {               shift and go to state 105


state 80

    (55) organism_stmt -> ORGANISM { orgprop . orgprop orgprop orgprop }
    (56) orgprop -> . DNA ID
    (57) orgprop -> . BEHAVIOR ID
    (58) orgprop -> . REPR ID
    (59) orgprop -> . AT { position position_list }

    DNA             shift and go to state 81
    BEHAVIOR        shift and go to state 82
    REPR            shift and go to state 83
    AT              shift and go to state 84

    orgprop                        shift and go to state 106

state 81

    (56) orgprop -> DNA . ID

    ID              shift and go to state 107


state 82

    (57) orgprop -> BEHAVIOR . ID

    ID              shift and go to state 108


state 83

    (58) orgprop -> REPR . ID

    ID              shift and go to state 109


state 84

    (59) orgprop -> AT . { position position_list }

    {               shift and go to state 110


state 85

    (45) behavior_stmt -> BEHAVIOR ID { func_stmt_list . decide_stmt }
    (47) decide_stmt -> . DECIDE ORGANISM TIME { stmt_list }

    DECIDE          shift and go to state 112

    decide_stmt                    shift and go to state 111

state 86

    (86) func_stmt_list -> func_stmt . func_stmt_list
    (86) func_stmt_list -> . func_stmt func_stmt_list
    (87) func_stmt_list -> . epsilon
    (88) func_stmt -> . FUNC ID = param_list { stmt_list }
    (2) epsilon -> .

    FUNC            shift and go to state 88
    DECIDE          reduce using rule 2 (epsilon -> .)

    func_stmt                      shift and go to state 86
    func_stmt_list                 shift and go to state 113
    epsilon                        shift and go to state 87

state 87

    (87) func_stmt_list -> epsilon .

    DECIDE          reduce using rule 87 (func_stmt_list -> epsilon .)


state 88

    (88) func_stmt -> FUNC . ID = param_list { stmt_list }

    ID              shift and go to state 114


state 89

    (42) dna_elem -> DNA ID .

    ID              reduce using rule 42 (dna_elem -> DNA ID .)
    SMELLING        reduce using rule 42 (dna_elem -> DNA ID .)
    VISION          reduce using rule 42 (dna_elem -> DNA ID .)
    DNA             reduce using rule 42 (dna_elem -> DNA ID .)
    }               reduce using rule 42 (dna_elem -> DNA ID .)


state 90

    (36) dna_stmt -> DNA ID { dna_elem_list } .

    DNA             reduce using rule 36 (dna_stmt -> DNA ID { dna_elem_list } .)
    BEHAVIOR        reduce using rule 36 (dna_stmt -> DNA ID { dna_elem_list } .)
    ENTITY          reduce using rule 36 (dna_stmt -> DNA ID { dna_elem_list } .)
    ORGANISM        reduce using rule 36 (dna_stmt -> DNA ID { dna_elem_list } .)
    WORLD           reduce using rule 36 (dna_stmt -> DNA ID { dna_elem_list } .)


state 91

    (37) dna_elem_list -> dna_elem dna_elem_list .

    }               reduce using rule 37 (dna_elem_list -> dna_elem dna_elem_list .)


state 92

    (19) phygene_stmt -> phygene ID { phygeneprop phygeneprop . }

    }               shift and go to state 115


state 93

    (30) phygeneprop -> VALUE NUMBER . IN { NUMBER NUMBER }

    IN              shift and go to state 116


state 94

    (31) phygeneprop -> MUTATION { . mutationprop mutationprop }
    (32) mutationprop -> . CHANCE NUMBER
    (33) mutationprop -> . STEP NUMBER

    CHANCE          shift and go to state 118
    STEP            shift and go to state 119

    mutationprop                   shift and go to state 117

state 95

    (11) actgene_stmt -> actgene ID { COST NUMBER . }

    }               shift and go to state 120


state 96

    (78) sim_stmt -> SIMULATION { . simprop simprop simprop simprop simprop }
    (79) simprop -> . EPISODES NUMBER
    (80) simprop -> . MAX_ROUNDS NUMBER
    (81) simprop -> . ACTIONS_TIME NUMBER
    (82) simprop -> . STOP SIMULATION { stmt_list }
    (83) simprop -> . AVAILABLE_COMMANDS { command_list }

    EPISODES        shift and go to state 122
    MAX_ROUNDS      shift and go to state 123
    ACTIONS_TIME    shift and go to state 124
    STOP            shift and go to state 125
    AVAILABLE_COMMANDS shift and go to state 126

    simprop                        shift and go to state 121

state 97

    (63) world_stmt -> WORLD { worldprop . worldprop }
    (64) worldprop -> . SIZE worldsize
    (65) worldprop -> . TERRAIN worldterrain

    SIZE            shift and go to state 98
    TERRAIN         shift and go to state 99

    worldprop                      shift and go to state 127

state 98

    (64) worldprop -> SIZE . worldsize
    (66) worldsize -> . INFINITE { worldsizeprop worldsizeprop }
    (67) worldsize -> . { worldsizeprop worldsizeprop }

    INFINITE        shift and go to state 129
    {               shift and go to state 130

    worldsize                      shift and go to state 128

state 99

    (65) worldprop -> TERRAIN . worldterrain
    (70) worldterrain -> . { terrainprop_list }

    {               shift and go to state 132

    worldterrain                   shift and go to state 131

state 100

    (51) entity_stmt -> ENTITY { entityprop entityprop . entityprop }
    (52) entityprop -> . COEXISTENCE bool
    (53) entityprop -> . REPR ID
    (54) entityprop -> . AT { position position_list }

    COEXISTENCE     shift and go to state 77
    REPR            shift and go to state 78
    AT              shift and go to state 79

    entityprop                     shift and go to state 133

state 101

    (52) entityprop -> COEXISTENCE bool .

    COEXISTENCE     reduce using rule 52 (entityprop -> COEXISTENCE bool .)
    REPR            reduce using rule 52 (entityprop -> COEXISTENCE bool .)
    AT              reduce using rule 52 (entityprop -> COEXISTENCE bool .)
    }               reduce using rule 52 (entityprop -> COEXISTENCE bool .)


state 102

    (158) bool -> TRUE .

    COEXISTENCE     reduce using rule 158 (bool -> TRUE .)
    REPR            reduce using rule 158 (bool -> TRUE .)
    AT              reduce using rule 158 (bool -> TRUE .)
    }               reduce using rule 158 (bool -> TRUE .)
    ^               reduce using rule 158 (bool -> TRUE .)
    @               reduce using rule 158 (bool -> TRUE .)
    [               reduce using rule 158 (bool -> TRUE .)
    *               reduce using rule 158 (bool -> TRUE .)
    /               reduce using rule 158 (bool -> TRUE .)
    %               reduce using rule 158 (bool -> TRUE .)
    INTDIV          reduce using rule 158 (bool -> TRUE .)
    EQ              reduce using rule 158 (bool -> TRUE .)
    NEQ             reduce using rule 158 (bool -> TRUE .)
    GE              reduce using rule 158 (bool -> TRUE .)
    LE              reduce using rule 158 (bool -> TRUE .)
    >               reduce using rule 158 (bool -> TRUE .)
    <               reduce using rule 158 (bool -> TRUE .)
    +               reduce using rule 158 (bool -> TRUE .)
    -               reduce using rule 158 (bool -> TRUE .)
    AND             reduce using rule 158 (bool -> TRUE .)
    OR              reduce using rule 158 (bool -> TRUE .)
    ;               reduce using rule 158 (bool -> TRUE .)
    =               reduce using rule 158 (bool -> TRUE .)
    {               reduce using rule 158 (bool -> TRUE .)
    ,               reduce using rule 158 (bool -> TRUE .)
    ]               reduce using rule 158 (bool -> TRUE .)
    )               reduce using rule 158 (bool -> TRUE .)


state 103

    (159) bool -> FALSE .

    COEXISTENCE     reduce using rule 159 (bool -> FALSE .)
    REPR            reduce using rule 159 (bool -> FALSE .)
    AT              reduce using rule 159 (bool -> FALSE .)
    }               reduce using rule 159 (bool -> FALSE .)
    ^               reduce using rule 159 (bool -> FALSE .)
    @               reduce using rule 159 (bool -> FALSE .)
    [               reduce using rule 159 (bool -> FALSE .)
    *               reduce using rule 159 (bool -> FALSE .)
    /               reduce using rule 159 (bool -> FALSE .)
    %               reduce using rule 159 (bool -> FALSE .)
    INTDIV          reduce using rule 159 (bool -> FALSE .)
    EQ              reduce using rule 159 (bool -> FALSE .)
    NEQ             reduce using rule 159 (bool -> FALSE .)
    GE              reduce using rule 159 (bool -> FALSE .)
    LE              reduce using rule 159 (bool -> FALSE .)
    >               reduce using rule 159 (bool -> FALSE .)
    <               reduce using rule 159 (bool -> FALSE .)
    +               reduce using rule 159 (bool -> FALSE .)
    -               reduce using rule 159 (bool -> FALSE .)
    AND             reduce using rule 159 (bool -> FALSE .)
    OR              reduce using rule 159 (bool -> FALSE .)
    ;               reduce using rule 159 (bool -> FALSE .)
    =               reduce using rule 159 (bool -> FALSE .)
    {               reduce using rule 159 (bool -> FALSE .)
    ,               reduce using rule 159 (bool -> FALSE .)
    ]               reduce using rule 159 (bool -> FALSE .)
    )               reduce using rule 159 (bool -> FALSE .)


state 104

    (53) entityprop -> REPR ID .

    COEXISTENCE     reduce using rule 53 (entityprop -> REPR ID .)
    REPR            reduce using rule 53 (entityprop -> REPR ID .)
    AT              reduce using rule 53 (entityprop -> REPR ID .)
    }               reduce using rule 53 (entityprop -> REPR ID .)


state 105

    (54) entityprop -> AT { . position position_list }
    (62) position -> . ( NUMBER NUMBER )

    (               shift and go to state 135

    position                       shift and go to state 134

state 106

    (55) organism_stmt -> ORGANISM { orgprop orgprop . orgprop orgprop }
    (56) orgprop -> . DNA ID
    (57) orgprop -> . BEHAVIOR ID
    (58) orgprop -> . REPR ID
    (59) orgprop -> . AT { position position_list }

    DNA             shift and go to state 81
    BEHAVIOR        shift and go to state 82
    REPR            shift and go to state 83
    AT              shift and go to state 84

    orgprop                        shift and go to state 136

state 107

    (56) orgprop -> DNA ID .

    DNA             reduce using rule 56 (orgprop -> DNA ID .)
    BEHAVIOR        reduce using rule 56 (orgprop -> DNA ID .)
    REPR            reduce using rule 56 (orgprop -> DNA ID .)
    AT              reduce using rule 56 (orgprop -> DNA ID .)
    }               reduce using rule 56 (orgprop -> DNA ID .)


state 108

    (57) orgprop -> BEHAVIOR ID .

    DNA             reduce using rule 57 (orgprop -> BEHAVIOR ID .)
    BEHAVIOR        reduce using rule 57 (orgprop -> BEHAVIOR ID .)
    REPR            reduce using rule 57 (orgprop -> BEHAVIOR ID .)
    AT              reduce using rule 57 (orgprop -> BEHAVIOR ID .)
    }               reduce using rule 57 (orgprop -> BEHAVIOR ID .)


state 109

    (58) orgprop -> REPR ID .

    DNA             reduce using rule 58 (orgprop -> REPR ID .)
    BEHAVIOR        reduce using rule 58 (orgprop -> REPR ID .)
    REPR            reduce using rule 58 (orgprop -> REPR ID .)
    AT              reduce using rule 58 (orgprop -> REPR ID .)
    }               reduce using rule 58 (orgprop -> REPR ID .)


state 110

    (59) orgprop -> AT { . position position_list }
    (62) position -> . ( NUMBER NUMBER )

    (               shift and go to state 135

    position                       shift and go to state 137

state 111

    (45) behavior_stmt -> BEHAVIOR ID { func_stmt_list decide_stmt . }

    }               shift and go to state 138


state 112

    (47) decide_stmt -> DECIDE . ORGANISM TIME { stmt_list }

    ORGANISM        shift and go to state 139


state 113

    (86) func_stmt_list -> func_stmt func_stmt_list .

    DECIDE          reduce using rule 86 (func_stmt_list -> func_stmt func_stmt_list .)


state 114

    (88) func_stmt -> FUNC ID . = param_list { stmt_list }

    =               shift and go to state 140


state 115

    (19) phygene_stmt -> phygene ID { phygeneprop phygeneprop } .

    GENE            reduce using rule 19 (phygene_stmt -> phygene ID { phygeneprop phygeneprop } .)
    DNA             reduce using rule 19 (phygene_stmt -> phygene ID { phygeneprop phygeneprop } .)
    BEHAVIOR        reduce using rule 19 (phygene_stmt -> phygene ID { phygeneprop phygeneprop } .)
    ENTITY          reduce using rule 19 (phygene_stmt -> phygene ID { phygeneprop phygeneprop } .)
    ORGANISM        reduce using rule 19 (phygene_stmt -> phygene ID { phygeneprop phygeneprop } .)
    WORLD           reduce using rule 19 (phygene_stmt -> phygene ID { phygeneprop phygeneprop } .)


state 116

    (30) phygeneprop -> VALUE NUMBER IN . { NUMBER NUMBER }

    {               shift and go to state 141


state 117

    (31) phygeneprop -> MUTATION { mutationprop . mutationprop }
    (32) mutationprop -> . CHANCE NUMBER
    (33) mutationprop -> . STEP NUMBER

    CHANCE          shift and go to state 118
    STEP            shift and go to state 119

    mutationprop                   shift and go to state 142

state 118

    (32) mutationprop -> CHANCE . NUMBER

    NUMBER          shift and go to state 143


state 119

    (33) mutationprop -> STEP . NUMBER

    NUMBER          shift and go to state 144


state 120

    (11) actgene_stmt -> actgene ID { COST NUMBER } .

    GENE            reduce using rule 11 (actgene_stmt -> actgene ID { COST NUMBER } .)
    DNA             reduce using rule 11 (actgene_stmt -> actgene ID { COST NUMBER } .)
    BEHAVIOR        reduce using rule 11 (actgene_stmt -> actgene ID { COST NUMBER } .)
    ENTITY          reduce using rule 11 (actgene_stmt -> actgene ID { COST NUMBER } .)
    ORGANISM        reduce using rule 11 (actgene_stmt -> actgene ID { COST NUMBER } .)
    WORLD           reduce using rule 11 (actgene_stmt -> actgene ID { COST NUMBER } .)


state 121

    (78) sim_stmt -> SIMULATION { simprop . simprop simprop simprop simprop }
    (79) simprop -> . EPISODES NUMBER
    (80) simprop -> . MAX_ROUNDS NUMBER
    (81) simprop -> . ACTIONS_TIME NUMBER
    (82) simprop -> . STOP SIMULATION { stmt_list }
    (83) simprop -> . AVAILABLE_COMMANDS { command_list }

    EPISODES        shift and go to state 122
    MAX_ROUNDS      shift and go to state 123
    ACTIONS_TIME    shift and go to state 124
    STOP            shift and go to state 125
    AVAILABLE_COMMANDS shift and go to state 126

    simprop                        shift and go to state 145

state 122

    (79) simprop -> EPISODES . NUMBER

    NUMBER          shift and go to state 146


state 123

    (80) simprop -> MAX_ROUNDS . NUMBER

    NUMBER          shift and go to state 147


state 124

    (81) simprop -> ACTIONS_TIME . NUMBER

    NUMBER          shift and go to state 148


state 125

    (82) simprop -> STOP . SIMULATION { stmt_list }

    SIMULATION      shift and go to state 149


state 126

    (83) simprop -> AVAILABLE_COMMANDS . { command_list }

    {               shift and go to state 150


state 127

    (63) world_stmt -> WORLD { worldprop worldprop . }

    }               shift and go to state 151


state 128

    (64) worldprop -> SIZE worldsize .

    SIZE            reduce using rule 64 (worldprop -> SIZE worldsize .)
    TERRAIN         reduce using rule 64 (worldprop -> SIZE worldsize .)
    }               reduce using rule 64 (worldprop -> SIZE worldsize .)


state 129

    (66) worldsize -> INFINITE . { worldsizeprop worldsizeprop }

    {               shift and go to state 152


state 130

    (67) worldsize -> { . worldsizeprop worldsizeprop }
    (68) worldsizeprop -> . WIDTH NUMBER
    (69) worldsizeprop -> . HEIGHT NUMBER

    WIDTH           shift and go to state 154
    HEIGHT          shift and go to state 155

    worldsizeprop                  shift and go to state 153

state 131

    (65) worldprop -> TERRAIN worldterrain .

    SIZE            reduce using rule 65 (worldprop -> TERRAIN worldterrain .)
    TERRAIN         reduce using rule 65 (worldprop -> TERRAIN worldterrain .)
    }               reduce using rule 65 (worldprop -> TERRAIN worldterrain .)


state 132

    (70) worldterrain -> { . terrainprop_list }
    (71) terrainprop_list -> . terrainprop terrainprop_list
    (72) terrainprop_list -> . epsilon
    (73) terrainprop -> . ID
    (74) terrainprop -> . DEFAULT ID
    (75) terrainprop -> . ID AT { NUMBER terrainposn_list }
    (2) epsilon -> .

    ID              shift and go to state 159
    DEFAULT         shift and go to state 160
    }               reduce using rule 2 (epsilon -> .)

    terrainprop_list               shift and go to state 156
    terrainprop                    shift and go to state 157
    epsilon                        shift and go to state 158

state 133

    (51) entity_stmt -> ENTITY { entityprop entityprop entityprop . }

    }               shift and go to state 161


state 134

    (54) entityprop -> AT { position . position_list }
    (60) position_list -> . position position_list
    (61) position_list -> . epsilon
    (62) position -> . ( NUMBER NUMBER )
    (2) epsilon -> .

    (               shift and go to state 135
    }               reduce using rule 2 (epsilon -> .)

    position                       shift and go to state 162
    position_list                  shift and go to state 163
    epsilon                        shift and go to state 164

state 135

    (62) position -> ( . NUMBER NUMBER )

    NUMBER          shift and go to state 165


state 136

    (55) organism_stmt -> ORGANISM { orgprop orgprop orgprop . orgprop }
    (56) orgprop -> . DNA ID
    (57) orgprop -> . BEHAVIOR ID
    (58) orgprop -> . REPR ID
    (59) orgprop -> . AT { position position_list }

    DNA             shift and go to state 81
    BEHAVIOR        shift and go to state 82
    REPR            shift and go to state 83
    AT              shift and go to state 84

    orgprop                        shift and go to state 166

state 137

    (59) orgprop -> AT { position . position_list }
    (60) position_list -> . position position_list
    (61) position_list -> . epsilon
    (62) position -> . ( NUMBER NUMBER )
    (2) epsilon -> .

    (               shift and go to state 135
    }               reduce using rule 2 (epsilon -> .)

    position                       shift and go to state 162
    position_list                  shift and go to state 167
    epsilon                        shift and go to state 164

state 138

    (45) behavior_stmt -> BEHAVIOR ID { func_stmt_list decide_stmt } .

    BEHAVIOR        reduce using rule 45 (behavior_stmt -> BEHAVIOR ID { func_stmt_list decide_stmt } .)
    ENTITY          reduce using rule 45 (behavior_stmt -> BEHAVIOR ID { func_stmt_list decide_stmt } .)
    ORGANISM        reduce using rule 45 (behavior_stmt -> BEHAVIOR ID { func_stmt_list decide_stmt } .)
    WORLD           reduce using rule 45 (behavior_stmt -> BEHAVIOR ID { func_stmt_list decide_stmt } .)


state 139

    (47) decide_stmt -> DECIDE ORGANISM . TIME { stmt_list }

    TIME            shift and go to state 168


state 140

    (88) func_stmt -> FUNC ID = . param_list { stmt_list }
    (89) param_list -> . ID param_list
    (90) param_list -> . epsilon
    (2) epsilon -> .

    ID              shift and go to state 169
    {               reduce using rule 2 (epsilon -> .)

    param_list                     shift and go to state 170
    epsilon                        shift and go to state 171

state 141

    (30) phygeneprop -> VALUE NUMBER IN { . NUMBER NUMBER }

    NUMBER          shift and go to state 172


state 142

    (31) phygeneprop -> MUTATION { mutationprop mutationprop . }

    }               shift and go to state 173


state 143

    (32) mutationprop -> CHANCE NUMBER .

    CHANCE          reduce using rule 32 (mutationprop -> CHANCE NUMBER .)
    STEP            reduce using rule 32 (mutationprop -> CHANCE NUMBER .)
    }               reduce using rule 32 (mutationprop -> CHANCE NUMBER .)


state 144

    (33) mutationprop -> STEP NUMBER .

    CHANCE          reduce using rule 33 (mutationprop -> STEP NUMBER .)
    STEP            reduce using rule 33 (mutationprop -> STEP NUMBER .)
    }               reduce using rule 33 (mutationprop -> STEP NUMBER .)


state 145

    (78) sim_stmt -> SIMULATION { simprop simprop . simprop simprop simprop }
    (79) simprop -> . EPISODES NUMBER
    (80) simprop -> . MAX_ROUNDS NUMBER
    (81) simprop -> . ACTIONS_TIME NUMBER
    (82) simprop -> . STOP SIMULATION { stmt_list }
    (83) simprop -> . AVAILABLE_COMMANDS { command_list }

    EPISODES        shift and go to state 122
    MAX_ROUNDS      shift and go to state 123
    ACTIONS_TIME    shift and go to state 124
    STOP            shift and go to state 125
    AVAILABLE_COMMANDS shift and go to state 126

    simprop                        shift and go to state 174

state 146

    (79) simprop -> EPISODES NUMBER .

    EPISODES        reduce using rule 79 (simprop -> EPISODES NUMBER .)
    MAX_ROUNDS      reduce using rule 79 (simprop -> EPISODES NUMBER .)
    ACTIONS_TIME    reduce using rule 79 (simprop -> EPISODES NUMBER .)
    STOP            reduce using rule 79 (simprop -> EPISODES NUMBER .)
    AVAILABLE_COMMANDS reduce using rule 79 (simprop -> EPISODES NUMBER .)
    }               reduce using rule 79 (simprop -> EPISODES NUMBER .)


state 147

    (80) simprop -> MAX_ROUNDS NUMBER .

    EPISODES        reduce using rule 80 (simprop -> MAX_ROUNDS NUMBER .)
    MAX_ROUNDS      reduce using rule 80 (simprop -> MAX_ROUNDS NUMBER .)
    ACTIONS_TIME    reduce using rule 80 (simprop -> MAX_ROUNDS NUMBER .)
    STOP            reduce using rule 80 (simprop -> MAX_ROUNDS NUMBER .)
    AVAILABLE_COMMANDS reduce using rule 80 (simprop -> MAX_ROUNDS NUMBER .)
    }               reduce using rule 80 (simprop -> MAX_ROUNDS NUMBER .)


state 148

    (81) simprop -> ACTIONS_TIME NUMBER .

    EPISODES        reduce using rule 81 (simprop -> ACTIONS_TIME NUMBER .)
    MAX_ROUNDS      reduce using rule 81 (simprop -> ACTIONS_TIME NUMBER .)
    ACTIONS_TIME    reduce using rule 81 (simprop -> ACTIONS_TIME NUMBER .)
    STOP            reduce using rule 81 (simprop -> ACTIONS_TIME NUMBER .)
    AVAILABLE_COMMANDS reduce using rule 81 (simprop -> ACTIONS_TIME NUMBER .)
    }               reduce using rule 81 (simprop -> ACTIONS_TIME NUMBER .)


state 149

    (82) simprop -> STOP SIMULATION . { stmt_list }

    {               shift and go to state 175


state 150

    (83) simprop -> AVAILABLE_COMMANDS { . command_list }
    (84) command_list -> . ID command_list
    (85) command_list -> . epsilon
    (2) epsilon -> .

    ID              shift and go to state 177
    }               reduce using rule 2 (epsilon -> .)

    command_list                   shift and go to state 176
    epsilon                        shift and go to state 178

state 151

    (63) world_stmt -> WORLD { worldprop worldprop } .

    SIMULATION      reduce using rule 63 (world_stmt -> WORLD { worldprop worldprop } .)


state 152

    (66) worldsize -> INFINITE { . worldsizeprop worldsizeprop }
    (68) worldsizeprop -> . WIDTH NUMBER
    (69) worldsizeprop -> . HEIGHT NUMBER

    WIDTH           shift and go to state 154
    HEIGHT          shift and go to state 155

    worldsizeprop                  shift and go to state 179

state 153

    (67) worldsize -> { worldsizeprop . worldsizeprop }
    (68) worldsizeprop -> . WIDTH NUMBER
    (69) worldsizeprop -> . HEIGHT NUMBER

    WIDTH           shift and go to state 154
    HEIGHT          shift and go to state 155

    worldsizeprop                  shift and go to state 180

state 154

    (68) worldsizeprop -> WIDTH . NUMBER

    NUMBER          shift and go to state 181


state 155

    (69) worldsizeprop -> HEIGHT . NUMBER

    NUMBER          shift and go to state 182


state 156

    (70) worldterrain -> { terrainprop_list . }

    }               shift and go to state 183


state 157

    (71) terrainprop_list -> terrainprop . terrainprop_list
    (71) terrainprop_list -> . terrainprop terrainprop_list
    (72) terrainprop_list -> . epsilon
    (73) terrainprop -> . ID
    (74) terrainprop -> . DEFAULT ID
    (75) terrainprop -> . ID AT { NUMBER terrainposn_list }
    (2) epsilon -> .

    ID              shift and go to state 159
    DEFAULT         shift and go to state 160
    }               reduce using rule 2 (epsilon -> .)

    terrainprop                    shift and go to state 157
    terrainprop_list               shift and go to state 184
    epsilon                        shift and go to state 158

state 158

    (72) terrainprop_list -> epsilon .

    }               reduce using rule 72 (terrainprop_list -> epsilon .)


state 159

    (73) terrainprop -> ID .
    (75) terrainprop -> ID . AT { NUMBER terrainposn_list }

    ID              reduce using rule 73 (terrainprop -> ID .)
    DEFAULT         reduce using rule 73 (terrainprop -> ID .)
    }               reduce using rule 73 (terrainprop -> ID .)
    AT              shift and go to state 185


state 160

    (74) terrainprop -> DEFAULT . ID

    ID              shift and go to state 186


state 161

    (51) entity_stmt -> ENTITY { entityprop entityprop entityprop } .

    ENTITY          reduce using rule 51 (entity_stmt -> ENTITY { entityprop entityprop entityprop } .)
    ORGANISM        reduce using rule 51 (entity_stmt -> ENTITY { entityprop entityprop entityprop } .)
    WORLD           reduce using rule 51 (entity_stmt -> ENTITY { entityprop entityprop entityprop } .)


state 162

    (60) position_list -> position . position_list
    (60) position_list -> . position position_list
    (61) position_list -> . epsilon
    (62) position -> . ( NUMBER NUMBER )
    (2) epsilon -> .

    (               shift and go to state 135
    }               reduce using rule 2 (epsilon -> .)

    position                       shift and go to state 162
    position_list                  shift and go to state 187
    epsilon                        shift and go to state 164

state 163

    (54) entityprop -> AT { position position_list . }

    }               shift and go to state 188


state 164

    (61) position_list -> epsilon .

    }               reduce using rule 61 (position_list -> epsilon .)


state 165

    (62) position -> ( NUMBER . NUMBER )

    NUMBER          shift and go to state 189


state 166

    (55) organism_stmt -> ORGANISM { orgprop orgprop orgprop orgprop . }

    }               shift and go to state 190


state 167

    (59) orgprop -> AT { position position_list . }

    }               shift and go to state 191


state 168

    (47) decide_stmt -> DECIDE ORGANISM TIME . { stmt_list }

    {               shift and go to state 192


state 169

    (89) param_list -> ID . param_list
    (89) param_list -> . ID param_list
    (90) param_list -> . epsilon
    (2) epsilon -> .

    ID              shift and go to state 169
    {               reduce using rule 2 (epsilon -> .)

    param_list                     shift and go to state 193
    epsilon                        shift and go to state 171

state 170

    (88) func_stmt -> FUNC ID = param_list . { stmt_list }

    {               shift and go to state 194


state 171

    (90) param_list -> epsilon .

    {               reduce using rule 90 (param_list -> epsilon .)


state 172

    (30) phygeneprop -> VALUE NUMBER IN { NUMBER . NUMBER }

    NUMBER          shift and go to state 195


state 173

    (31) phygeneprop -> MUTATION { mutationprop mutationprop } .

    VALUE           reduce using rule 31 (phygeneprop -> MUTATION { mutationprop mutationprop } .)
    MUTATION        reduce using rule 31 (phygeneprop -> MUTATION { mutationprop mutationprop } .)
    }               reduce using rule 31 (phygeneprop -> MUTATION { mutationprop mutationprop } .)


state 174

    (78) sim_stmt -> SIMULATION { simprop simprop simprop . simprop simprop }
    (79) simprop -> . EPISODES NUMBER
    (80) simprop -> . MAX_ROUNDS NUMBER
    (81) simprop -> . ACTIONS_TIME NUMBER
    (82) simprop -> . STOP SIMULATION { stmt_list }
    (83) simprop -> . AVAILABLE_COMMANDS { command_list }

    EPISODES        shift and go to state 122
    MAX_ROUNDS      shift and go to state 123
    ACTIONS_TIME    shift and go to state 124
    STOP            shift and go to state 125
    AVAILABLE_COMMANDS shift and go to state 126

    simprop                        shift and go to state 196

state 175

    (82) simprop -> STOP SIMULATION { . stmt_list }
    (91) stmt_list -> . stmt stmt_list
    (92) stmt_list -> . epsilon
    (93) stmt -> . if_stmt
    (94) stmt -> . var_stmt ;
    (95) stmt -> . index_stmt ;
    (96) stmt -> . disjunction ;
    (97) stmt -> . loop_stmt
    (98) stmt -> . CONTINUE ;
    (99) stmt -> . BREAK ;
    (100) stmt -> . RETURN disjunction ;
    (101) stmt -> . RETURN ;
    (2) epsilon -> .
    (104) if_stmt -> . IF disjunction { stmt_list } else_stmt
    (102) var_stmt -> . accessing = disjunction
    (103) index_stmt -> . naming [ disjunction ] = disjunction
    (115) disjunction -> . conjunction OR conjunction
    (116) disjunction -> . conjunction
    (108) loop_stmt -> . LOOP loop_init , loop_condition , loop_set { stmt_list }
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (117) conjunction -> . negation AND negation
    (118) conjunction -> . negation
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (119) negation -> . NOT comparison
    (120) negation -> . comparison
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (121) comparison -> . expr EQ expr
    (122) comparison -> . expr NEQ expr
    (123) comparison -> . expr GE expr
    (124) comparison -> . expr LE expr
    (125) comparison -> . expr > expr
    (126) comparison -> . expr < expr
    (127) comparison -> . expr
    (128) expr -> . expr + term
    (129) expr -> . expr - term
    (130) expr -> . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming

    CONTINUE        shift and go to state 207
    BREAK           shift and go to state 208
    RETURN          shift and go to state 209
    }               reduce using rule 2 (epsilon -> .)
    IF              shift and go to state 210
    LOOP            shift and go to state 215
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    NOT             shift and go to state 228
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    -               shift and go to state 231

    stmt_list                      shift and go to state 199
    stmt                           shift and go to state 200
    epsilon                        shift and go to state 201
    if_stmt                        shift and go to state 202
    var_stmt                       shift and go to state 203
    index_stmt                     shift and go to state 204
    disjunction                    shift and go to state 205
    loop_stmt                      shift and go to state 206
    accessing                      shift and go to state 211
    naming                         shift and go to state 212
    conjunction                    shift and go to state 214
    word                           shift and go to state 216
    atom                           shift and go to state 220
    negation                       shift and go to state 221
    bool                           shift and go to state 226
    expr                           shift and go to state 227
    comparison                     shift and go to state 229
    term                           shift and go to state 230
    factor                         shift and go to state 232
    power                          shift and go to state 233

state 176

    (83) simprop -> AVAILABLE_COMMANDS { command_list . }

    }               shift and go to state 234


state 177

    (84) command_list -> ID . command_list
    (84) command_list -> . ID command_list
    (85) command_list -> . epsilon
    (2) epsilon -> .

    ID              shift and go to state 177
    }               reduce using rule 2 (epsilon -> .)

    command_list                   shift and go to state 235
    epsilon                        shift and go to state 178

state 178

    (85) command_list -> epsilon .

    }               reduce using rule 85 (command_list -> epsilon .)


state 179

    (66) worldsize -> INFINITE { worldsizeprop . worldsizeprop }
    (68) worldsizeprop -> . WIDTH NUMBER
    (69) worldsizeprop -> . HEIGHT NUMBER

    WIDTH           shift and go to state 154
    HEIGHT          shift and go to state 155

    worldsizeprop                  shift and go to state 236

state 180

    (67) worldsize -> { worldsizeprop worldsizeprop . }

    }               shift and go to state 237


state 181

    (68) worldsizeprop -> WIDTH NUMBER .

    WIDTH           reduce using rule 68 (worldsizeprop -> WIDTH NUMBER .)
    HEIGHT          reduce using rule 68 (worldsizeprop -> WIDTH NUMBER .)
    }               reduce using rule 68 (worldsizeprop -> WIDTH NUMBER .)


state 182

    (69) worldsizeprop -> HEIGHT NUMBER .

    WIDTH           reduce using rule 69 (worldsizeprop -> HEIGHT NUMBER .)
    HEIGHT          reduce using rule 69 (worldsizeprop -> HEIGHT NUMBER .)
    }               reduce using rule 69 (worldsizeprop -> HEIGHT NUMBER .)


state 183

    (70) worldterrain -> { terrainprop_list } .

    SIZE            reduce using rule 70 (worldterrain -> { terrainprop_list } .)
    TERRAIN         reduce using rule 70 (worldterrain -> { terrainprop_list } .)
    }               reduce using rule 70 (worldterrain -> { terrainprop_list } .)


state 184

    (71) terrainprop_list -> terrainprop terrainprop_list .

    }               reduce using rule 71 (terrainprop_list -> terrainprop terrainprop_list .)


state 185

    (75) terrainprop -> ID AT . { NUMBER terrainposn_list }

    {               shift and go to state 238


state 186

    (74) terrainprop -> DEFAULT ID .

    ID              reduce using rule 74 (terrainprop -> DEFAULT ID .)
    DEFAULT         reduce using rule 74 (terrainprop -> DEFAULT ID .)
    }               reduce using rule 74 (terrainprop -> DEFAULT ID .)


state 187

    (60) position_list -> position position_list .

    }               reduce using rule 60 (position_list -> position position_list .)


state 188

    (54) entityprop -> AT { position position_list } .

    COEXISTENCE     reduce using rule 54 (entityprop -> AT { position position_list } .)
    REPR            reduce using rule 54 (entityprop -> AT { position position_list } .)
    AT              reduce using rule 54 (entityprop -> AT { position position_list } .)
    }               reduce using rule 54 (entityprop -> AT { position position_list } .)


state 189

    (62) position -> ( NUMBER NUMBER . )

    )               shift and go to state 239


state 190

    (55) organism_stmt -> ORGANISM { orgprop orgprop orgprop orgprop } .

    ENTITY          reduce using rule 55 (organism_stmt -> ORGANISM { orgprop orgprop orgprop orgprop } .)
    ORGANISM        reduce using rule 55 (organism_stmt -> ORGANISM { orgprop orgprop orgprop orgprop } .)
    WORLD           reduce using rule 55 (organism_stmt -> ORGANISM { orgprop orgprop orgprop orgprop } .)


state 191

    (59) orgprop -> AT { position position_list } .

    DNA             reduce using rule 59 (orgprop -> AT { position position_list } .)
    BEHAVIOR        reduce using rule 59 (orgprop -> AT { position position_list } .)
    REPR            reduce using rule 59 (orgprop -> AT { position position_list } .)
    AT              reduce using rule 59 (orgprop -> AT { position position_list } .)
    }               reduce using rule 59 (orgprop -> AT { position position_list } .)


state 192

    (47) decide_stmt -> DECIDE ORGANISM TIME { . stmt_list }
    (91) stmt_list -> . stmt stmt_list
    (92) stmt_list -> . epsilon
    (93) stmt -> . if_stmt
    (94) stmt -> . var_stmt ;
    (95) stmt -> . index_stmt ;
    (96) stmt -> . disjunction ;
    (97) stmt -> . loop_stmt
    (98) stmt -> . CONTINUE ;
    (99) stmt -> . BREAK ;
    (100) stmt -> . RETURN disjunction ;
    (101) stmt -> . RETURN ;
    (2) epsilon -> .
    (104) if_stmt -> . IF disjunction { stmt_list } else_stmt
    (102) var_stmt -> . accessing = disjunction
    (103) index_stmt -> . naming [ disjunction ] = disjunction
    (115) disjunction -> . conjunction OR conjunction
    (116) disjunction -> . conjunction
    (108) loop_stmt -> . LOOP loop_init , loop_condition , loop_set { stmt_list }
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (117) conjunction -> . negation AND negation
    (118) conjunction -> . negation
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (119) negation -> . NOT comparison
    (120) negation -> . comparison
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (121) comparison -> . expr EQ expr
    (122) comparison -> . expr NEQ expr
    (123) comparison -> . expr GE expr
    (124) comparison -> . expr LE expr
    (125) comparison -> . expr > expr
    (126) comparison -> . expr < expr
    (127) comparison -> . expr
    (128) expr -> . expr + term
    (129) expr -> . expr - term
    (130) expr -> . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming

    CONTINUE        shift and go to state 207
    BREAK           shift and go to state 208
    RETURN          shift and go to state 209
    }               reduce using rule 2 (epsilon -> .)
    IF              shift and go to state 210
    LOOP            shift and go to state 215
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    NOT             shift and go to state 228
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    -               shift and go to state 231

    stmt_list                      shift and go to state 240
    stmt                           shift and go to state 200
    epsilon                        shift and go to state 201
    if_stmt                        shift and go to state 202
    var_stmt                       shift and go to state 203
    index_stmt                     shift and go to state 204
    disjunction                    shift and go to state 205
    loop_stmt                      shift and go to state 206
    accessing                      shift and go to state 211
    naming                         shift and go to state 212
    conjunction                    shift and go to state 214
    word                           shift and go to state 216
    atom                           shift and go to state 220
    negation                       shift and go to state 221
    bool                           shift and go to state 226
    expr                           shift and go to state 227
    comparison                     shift and go to state 229
    term                           shift and go to state 230
    factor                         shift and go to state 232
    power                          shift and go to state 233

state 193

    (89) param_list -> ID param_list .

    {               reduce using rule 89 (param_list -> ID param_list .)


state 194

    (88) func_stmt -> FUNC ID = param_list { . stmt_list }
    (91) stmt_list -> . stmt stmt_list
    (92) stmt_list -> . epsilon
    (93) stmt -> . if_stmt
    (94) stmt -> . var_stmt ;
    (95) stmt -> . index_stmt ;
    (96) stmt -> . disjunction ;
    (97) stmt -> . loop_stmt
    (98) stmt -> . CONTINUE ;
    (99) stmt -> . BREAK ;
    (100) stmt -> . RETURN disjunction ;
    (101) stmt -> . RETURN ;
    (2) epsilon -> .
    (104) if_stmt -> . IF disjunction { stmt_list } else_stmt
    (102) var_stmt -> . accessing = disjunction
    (103) index_stmt -> . naming [ disjunction ] = disjunction
    (115) disjunction -> . conjunction OR conjunction
    (116) disjunction -> . conjunction
    (108) loop_stmt -> . LOOP loop_init , loop_condition , loop_set { stmt_list }
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (117) conjunction -> . negation AND negation
    (118) conjunction -> . negation
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (119) negation -> . NOT comparison
    (120) negation -> . comparison
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (121) comparison -> . expr EQ expr
    (122) comparison -> . expr NEQ expr
    (123) comparison -> . expr GE expr
    (124) comparison -> . expr LE expr
    (125) comparison -> . expr > expr
    (126) comparison -> . expr < expr
    (127) comparison -> . expr
    (128) expr -> . expr + term
    (129) expr -> . expr - term
    (130) expr -> . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming

    CONTINUE        shift and go to state 207
    BREAK           shift and go to state 208
    RETURN          shift and go to state 209
    }               reduce using rule 2 (epsilon -> .)
    IF              shift and go to state 210
    LOOP            shift and go to state 215
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    NOT             shift and go to state 228
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    -               shift and go to state 231

    stmt_list                      shift and go to state 241
    stmt                           shift and go to state 200
    epsilon                        shift and go to state 201
    if_stmt                        shift and go to state 202
    var_stmt                       shift and go to state 203
    index_stmt                     shift and go to state 204
    disjunction                    shift and go to state 205
    loop_stmt                      shift and go to state 206
    accessing                      shift and go to state 211
    naming                         shift and go to state 212
    conjunction                    shift and go to state 214
    word                           shift and go to state 216
    atom                           shift and go to state 220
    negation                       shift and go to state 221
    bool                           shift and go to state 226
    expr                           shift and go to state 227
    comparison                     shift and go to state 229
    term                           shift and go to state 230
    factor                         shift and go to state 232
    power                          shift and go to state 233

state 195

    (30) phygeneprop -> VALUE NUMBER IN { NUMBER NUMBER . }

    }               shift and go to state 242


state 196

    (78) sim_stmt -> SIMULATION { simprop simprop simprop simprop . simprop }
    (79) simprop -> . EPISODES NUMBER
    (80) simprop -> . MAX_ROUNDS NUMBER
    (81) simprop -> . ACTIONS_TIME NUMBER
    (82) simprop -> . STOP SIMULATION { stmt_list }
    (83) simprop -> . AVAILABLE_COMMANDS { command_list }

    EPISODES        shift and go to state 122
    MAX_ROUNDS      shift and go to state 123
    ACTIONS_TIME    shift and go to state 124
    STOP            shift and go to state 125
    AVAILABLE_COMMANDS shift and go to state 126

    simprop                        shift and go to state 243

state 197

    (156) word -> SIMULATION .

    .               reduce using rule 156 (word -> SIMULATION .)
    =               reduce using rule 156 (word -> SIMULATION .)
    [               reduce using rule 156 (word -> SIMULATION .)
    *               reduce using rule 156 (word -> SIMULATION .)
    /               reduce using rule 156 (word -> SIMULATION .)
    %               reduce using rule 156 (word -> SIMULATION .)
    INTDIV          reduce using rule 156 (word -> SIMULATION .)
    EQ              reduce using rule 156 (word -> SIMULATION .)
    NEQ             reduce using rule 156 (word -> SIMULATION .)
    GE              reduce using rule 156 (word -> SIMULATION .)
    LE              reduce using rule 156 (word -> SIMULATION .)
    >               reduce using rule 156 (word -> SIMULATION .)
    <               reduce using rule 156 (word -> SIMULATION .)
    +               reduce using rule 156 (word -> SIMULATION .)
    -               reduce using rule 156 (word -> SIMULATION .)
    AND             reduce using rule 156 (word -> SIMULATION .)
    OR              reduce using rule 156 (word -> SIMULATION .)
    ;               reduce using rule 156 (word -> SIMULATION .)
    {               reduce using rule 156 (word -> SIMULATION .)
    ,               reduce using rule 156 (word -> SIMULATION .)
    ]               reduce using rule 156 (word -> SIMULATION .)
    )               reduce using rule 156 (word -> SIMULATION .)
    }               reduce using rule 156 (word -> SIMULATION .)


state 198

    (151) atom -> { . keyarg_list }
    (163) keyarg_list -> . keyarg
    (164) keyarg_list -> . keyarg , keyarg_list
    (165) keyarg_list -> . epsilon
    (166) keyarg -> . disjunction = disjunction
    (2) epsilon -> .
    (115) disjunction -> . conjunction OR conjunction
    (116) disjunction -> . conjunction
    (117) conjunction -> . negation AND negation
    (118) conjunction -> . negation
    (119) negation -> . NOT comparison
    (120) negation -> . comparison
    (121) comparison -> . expr EQ expr
    (122) comparison -> . expr NEQ expr
    (123) comparison -> . expr GE expr
    (124) comparison -> . expr LE expr
    (125) comparison -> . expr > expr
    (126) comparison -> . expr < expr
    (127) comparison -> . expr
    (128) expr -> . expr + term
    (129) expr -> . expr - term
    (130) expr -> . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    }               reduce using rule 2 (epsilon -> .)
    NOT             shift and go to state 228
    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    keyarg_list                    shift and go to state 244
    keyarg                         shift and go to state 245
    epsilon                        shift and go to state 246
    disjunction                    shift and go to state 247
    conjunction                    shift and go to state 214
    negation                       shift and go to state 221
    comparison                     shift and go to state 229
    expr                           shift and go to state 227
    term                           shift and go to state 230
    factor                         shift and go to state 232
    power                          shift and go to state 233
    atom                           shift and go to state 248
    naming                         shift and go to state 249
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 199

    (82) simprop -> STOP SIMULATION { stmt_list . }

    }               shift and go to state 251


state 200

    (91) stmt_list -> stmt . stmt_list
    (91) stmt_list -> . stmt stmt_list
    (92) stmt_list -> . epsilon
    (93) stmt -> . if_stmt
    (94) stmt -> . var_stmt ;
    (95) stmt -> . index_stmt ;
    (96) stmt -> . disjunction ;
    (97) stmt -> . loop_stmt
    (98) stmt -> . CONTINUE ;
    (99) stmt -> . BREAK ;
    (100) stmt -> . RETURN disjunction ;
    (101) stmt -> . RETURN ;
    (2) epsilon -> .
    (104) if_stmt -> . IF disjunction { stmt_list } else_stmt
    (102) var_stmt -> . accessing = disjunction
    (103) index_stmt -> . naming [ disjunction ] = disjunction
    (115) disjunction -> . conjunction OR conjunction
    (116) disjunction -> . conjunction
    (108) loop_stmt -> . LOOP loop_init , loop_condition , loop_set { stmt_list }
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (117) conjunction -> . negation AND negation
    (118) conjunction -> . negation
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (119) negation -> . NOT comparison
    (120) negation -> . comparison
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (121) comparison -> . expr EQ expr
    (122) comparison -> . expr NEQ expr
    (123) comparison -> . expr GE expr
    (124) comparison -> . expr LE expr
    (125) comparison -> . expr > expr
    (126) comparison -> . expr < expr
    (127) comparison -> . expr
    (128) expr -> . expr + term
    (129) expr -> . expr - term
    (130) expr -> . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming

    CONTINUE        shift and go to state 207
    BREAK           shift and go to state 208
    RETURN          shift and go to state 209
    }               reduce using rule 2 (epsilon -> .)
    IF              shift and go to state 210
    LOOP            shift and go to state 215
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    NOT             shift and go to state 228
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    -               shift and go to state 231

    stmt                           shift and go to state 200
    stmt_list                      shift and go to state 252
    epsilon                        shift and go to state 201
    if_stmt                        shift and go to state 202
    var_stmt                       shift and go to state 203
    index_stmt                     shift and go to state 204
    disjunction                    shift and go to state 205
    loop_stmt                      shift and go to state 206
    accessing                      shift and go to state 211
    naming                         shift and go to state 212
    conjunction                    shift and go to state 214
    word                           shift and go to state 216
    atom                           shift and go to state 220
    negation                       shift and go to state 221
    bool                           shift and go to state 226
    expr                           shift and go to state 227
    comparison                     shift and go to state 229
    term                           shift and go to state 230
    factor                         shift and go to state 232
    power                          shift and go to state 233

state 201

    (92) stmt_list -> epsilon .

    }               reduce using rule 92 (stmt_list -> epsilon .)


state 202

    (93) stmt -> if_stmt .

    CONTINUE        reduce using rule 93 (stmt -> if_stmt .)
    BREAK           reduce using rule 93 (stmt -> if_stmt .)
    RETURN          reduce using rule 93 (stmt -> if_stmt .)
    IF              reduce using rule 93 (stmt -> if_stmt .)
    LOOP            reduce using rule 93 (stmt -> if_stmt .)
    KEYS            reduce using rule 93 (stmt -> if_stmt .)
    ID              reduce using rule 93 (stmt -> if_stmt .)
    ORGANISM        reduce using rule 93 (stmt -> if_stmt .)
    SIMULATION      reduce using rule 93 (stmt -> if_stmt .)
    WORLD           reduce using rule 93 (stmt -> if_stmt .)
    NUMBER          reduce using rule 93 (stmt -> if_stmt .)
    STRING          reduce using rule 93 (stmt -> if_stmt .)
    (               reduce using rule 93 (stmt -> if_stmt .)
    [               reduce using rule 93 (stmt -> if_stmt .)
    {               reduce using rule 93 (stmt -> if_stmt .)
    NOT             reduce using rule 93 (stmt -> if_stmt .)
    TRUE            reduce using rule 93 (stmt -> if_stmt .)
    FALSE           reduce using rule 93 (stmt -> if_stmt .)
    -               reduce using rule 93 (stmt -> if_stmt .)
    }               reduce using rule 93 (stmt -> if_stmt .)


state 203

    (94) stmt -> var_stmt . ;

    ;               shift and go to state 253


state 204

    (95) stmt -> index_stmt . ;

    ;               shift and go to state 254


state 205

    (96) stmt -> disjunction . ;

    ;               shift and go to state 255


state 206

    (97) stmt -> loop_stmt .

    CONTINUE        reduce using rule 97 (stmt -> loop_stmt .)
    BREAK           reduce using rule 97 (stmt -> loop_stmt .)
    RETURN          reduce using rule 97 (stmt -> loop_stmt .)
    IF              reduce using rule 97 (stmt -> loop_stmt .)
    LOOP            reduce using rule 97 (stmt -> loop_stmt .)
    KEYS            reduce using rule 97 (stmt -> loop_stmt .)
    ID              reduce using rule 97 (stmt -> loop_stmt .)
    ORGANISM        reduce using rule 97 (stmt -> loop_stmt .)
    SIMULATION      reduce using rule 97 (stmt -> loop_stmt .)
    WORLD           reduce using rule 97 (stmt -> loop_stmt .)
    NUMBER          reduce using rule 97 (stmt -> loop_stmt .)
    STRING          reduce using rule 97 (stmt -> loop_stmt .)
    (               reduce using rule 97 (stmt -> loop_stmt .)
    [               reduce using rule 97 (stmt -> loop_stmt .)
    {               reduce using rule 97 (stmt -> loop_stmt .)
    NOT             reduce using rule 97 (stmt -> loop_stmt .)
    TRUE            reduce using rule 97 (stmt -> loop_stmt .)
    FALSE           reduce using rule 97 (stmt -> loop_stmt .)
    -               reduce using rule 97 (stmt -> loop_stmt .)
    }               reduce using rule 97 (stmt -> loop_stmt .)


state 207

    (98) stmt -> CONTINUE . ;

    ;               shift and go to state 256


state 208

    (99) stmt -> BREAK . ;

    ;               shift and go to state 257


state 209

    (100) stmt -> RETURN . disjunction ;
    (101) stmt -> RETURN . ;
    (115) disjunction -> . conjunction OR conjunction
    (116) disjunction -> . conjunction
    (117) conjunction -> . negation AND negation
    (118) conjunction -> . negation
    (119) negation -> . NOT comparison
    (120) negation -> . comparison
    (121) comparison -> . expr EQ expr
    (122) comparison -> . expr NEQ expr
    (123) comparison -> . expr GE expr
    (124) comparison -> . expr LE expr
    (125) comparison -> . expr > expr
    (126) comparison -> . expr < expr
    (127) comparison -> . expr
    (128) expr -> . expr + term
    (129) expr -> . expr - term
    (130) expr -> . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    ;               shift and go to state 259
    NOT             shift and go to state 228
    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    disjunction                    shift and go to state 258
    conjunction                    shift and go to state 214
    negation                       shift and go to state 221
    comparison                     shift and go to state 229
    expr                           shift and go to state 227
    term                           shift and go to state 230
    factor                         shift and go to state 232
    power                          shift and go to state 233
    atom                           shift and go to state 248
    naming                         shift and go to state 249
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 210

    (104) if_stmt -> IF . disjunction { stmt_list } else_stmt
    (115) disjunction -> . conjunction OR conjunction
    (116) disjunction -> . conjunction
    (117) conjunction -> . negation AND negation
    (118) conjunction -> . negation
    (119) negation -> . NOT comparison
    (120) negation -> . comparison
    (121) comparison -> . expr EQ expr
    (122) comparison -> . expr NEQ expr
    (123) comparison -> . expr GE expr
    (124) comparison -> . expr LE expr
    (125) comparison -> . expr > expr
    (126) comparison -> . expr < expr
    (127) comparison -> . expr
    (128) expr -> . expr + term
    (129) expr -> . expr - term
    (130) expr -> . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    NOT             shift and go to state 228
    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    disjunction                    shift and go to state 260
    conjunction                    shift and go to state 214
    negation                       shift and go to state 221
    comparison                     shift and go to state 229
    expr                           shift and go to state 227
    term                           shift and go to state 230
    factor                         shift and go to state 232
    power                          shift and go to state 233
    atom                           shift and go to state 248
    naming                         shift and go to state 249
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 211

    (102) var_stmt -> accessing . = disjunction
    (142) naming -> accessing .

    =               shift and go to state 261
    [               reduce using rule 142 (naming -> accessing .)
    *               reduce using rule 142 (naming -> accessing .)
    /               reduce using rule 142 (naming -> accessing .)
    %               reduce using rule 142 (naming -> accessing .)
    INTDIV          reduce using rule 142 (naming -> accessing .)
    EQ              reduce using rule 142 (naming -> accessing .)
    NEQ             reduce using rule 142 (naming -> accessing .)
    GE              reduce using rule 142 (naming -> accessing .)
    LE              reduce using rule 142 (naming -> accessing .)
    >               reduce using rule 142 (naming -> accessing .)
    <               reduce using rule 142 (naming -> accessing .)
    +               reduce using rule 142 (naming -> accessing .)
    -               reduce using rule 142 (naming -> accessing .)
    AND             reduce using rule 142 (naming -> accessing .)
    OR              reduce using rule 142 (naming -> accessing .)
    ;               reduce using rule 142 (naming -> accessing .)


state 212

    (103) index_stmt -> naming . [ disjunction ] = disjunction
    (141) naming -> naming . [ disjunction ]
    (140) power -> naming .

    [               shift and go to state 262
    *               reduce using rule 140 (power -> naming .)
    /               reduce using rule 140 (power -> naming .)
    %               reduce using rule 140 (power -> naming .)
    INTDIV          reduce using rule 140 (power -> naming .)
    EQ              reduce using rule 140 (power -> naming .)
    NEQ             reduce using rule 140 (power -> naming .)
    GE              reduce using rule 140 (power -> naming .)
    LE              reduce using rule 140 (power -> naming .)
    >               reduce using rule 140 (power -> naming .)
    <               reduce using rule 140 (power -> naming .)
    +               reduce using rule 140 (power -> naming .)
    -               reduce using rule 140 (power -> naming .)
    AND             reduce using rule 140 (power -> naming .)
    OR              reduce using rule 140 (power -> naming .)
    ;               reduce using rule 140 (power -> naming .)


state 213

    (150) atom -> [ . arg_list ]
    (160) arg_list -> . disjunction
    (161) arg_list -> . disjunction , arg_list
    (162) arg_list -> . epsilon
    (115) disjunction -> . conjunction OR conjunction
    (116) disjunction -> . conjunction
    (2) epsilon -> .
    (117) conjunction -> . negation AND negation
    (118) conjunction -> . negation
    (119) negation -> . NOT comparison
    (120) negation -> . comparison
    (121) comparison -> . expr EQ expr
    (122) comparison -> . expr NEQ expr
    (123) comparison -> . expr GE expr
    (124) comparison -> . expr LE expr
    (125) comparison -> . expr > expr
    (126) comparison -> . expr < expr
    (127) comparison -> . expr
    (128) expr -> . expr + term
    (129) expr -> . expr - term
    (130) expr -> . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    ]               reduce using rule 2 (epsilon -> .)
    NOT             shift and go to state 228
    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    arg_list                       shift and go to state 263
    disjunction                    shift and go to state 264
    epsilon                        shift and go to state 265
    conjunction                    shift and go to state 214
    negation                       shift and go to state 221
    comparison                     shift and go to state 229
    expr                           shift and go to state 227
    term                           shift and go to state 230
    factor                         shift and go to state 232
    power                          shift and go to state 233
    atom                           shift and go to state 248
    naming                         shift and go to state 249
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 214

    (115) disjunction -> conjunction . OR conjunction
    (116) disjunction -> conjunction .

    OR              shift and go to state 266
    ;               reduce using rule 116 (disjunction -> conjunction .)
    =               reduce using rule 116 (disjunction -> conjunction .)
    {               reduce using rule 116 (disjunction -> conjunction .)
    ,               reduce using rule 116 (disjunction -> conjunction .)
    ]               reduce using rule 116 (disjunction -> conjunction .)
    )               reduce using rule 116 (disjunction -> conjunction .)
    }               reduce using rule 116 (disjunction -> conjunction .)


state 215

    (108) loop_stmt -> LOOP . loop_init , loop_condition , loop_set { stmt_list }
    (109) loop_init -> . var_stmt
    (110) loop_init -> . epsilon
    (102) var_stmt -> . accessing = disjunction
    (2) epsilon -> .
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    ,               reduce using rule 2 (epsilon -> .)
    ID              shift and go to state 271
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    loop_init                      shift and go to state 267
    var_stmt                       shift and go to state 268
    epsilon                        shift and go to state 269
    accessing                      shift and go to state 270
    word                           shift and go to state 216

state 216

    (152) accessing -> word .
    (153) accessing -> word . . accessing

    =               reduce using rule 152 (accessing -> word .)
    [               reduce using rule 152 (accessing -> word .)
    *               reduce using rule 152 (accessing -> word .)
    /               reduce using rule 152 (accessing -> word .)
    %               reduce using rule 152 (accessing -> word .)
    INTDIV          reduce using rule 152 (accessing -> word .)
    EQ              reduce using rule 152 (accessing -> word .)
    NEQ             reduce using rule 152 (accessing -> word .)
    GE              reduce using rule 152 (accessing -> word .)
    LE              reduce using rule 152 (accessing -> word .)
    >               reduce using rule 152 (accessing -> word .)
    <               reduce using rule 152 (accessing -> word .)
    +               reduce using rule 152 (accessing -> word .)
    -               reduce using rule 152 (accessing -> word .)
    AND             reduce using rule 152 (accessing -> word .)
    OR              reduce using rule 152 (accessing -> word .)
    ;               reduce using rule 152 (accessing -> word .)
    {               reduce using rule 152 (accessing -> word .)
    ,               reduce using rule 152 (accessing -> word .)
    ]               reduce using rule 152 (accessing -> word .)
    )               reduce using rule 152 (accessing -> word .)
    }               reduce using rule 152 (accessing -> word .)
    .               shift and go to state 272


state 217

    (143) naming -> KEYS . ( naming )

    (               shift and go to state 273


state 218

    (149) atom -> ( . expr )
    (128) expr -> . expr + term
    (129) expr -> . expr - term
    (130) expr -> . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    expr                           shift and go to state 274
    term                           shift and go to state 230
    factor                         shift and go to state 232
    power                          shift and go to state 233
    atom                           shift and go to state 248
    naming                         shift and go to state 249
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 219

    (144) naming -> ID . ( arg_list )
    (154) word -> ID .

    (               shift and go to state 275
    .               reduce using rule 154 (word -> ID .)
    =               reduce using rule 154 (word -> ID .)
    [               reduce using rule 154 (word -> ID .)
    *               reduce using rule 154 (word -> ID .)
    /               reduce using rule 154 (word -> ID .)
    %               reduce using rule 154 (word -> ID .)
    INTDIV          reduce using rule 154 (word -> ID .)
    EQ              reduce using rule 154 (word -> ID .)
    NEQ             reduce using rule 154 (word -> ID .)
    GE              reduce using rule 154 (word -> ID .)
    LE              reduce using rule 154 (word -> ID .)
    >               reduce using rule 154 (word -> ID .)
    <               reduce using rule 154 (word -> ID .)
    +               reduce using rule 154 (word -> ID .)
    -               reduce using rule 154 (word -> ID .)
    AND             reduce using rule 154 (word -> ID .)
    OR              reduce using rule 154 (word -> ID .)
    ;               reduce using rule 154 (word -> ID .)
    {               reduce using rule 154 (word -> ID .)
    ,               reduce using rule 154 (word -> ID .)
    ]               reduce using rule 154 (word -> ID .)
    )               reduce using rule 154 (word -> ID .)
    }               reduce using rule 154 (word -> ID .)


state 220

    (145) naming -> atom .
    (138) power -> atom . ^ factor
    (139) power -> atom . @ factor

    [               reduce using rule 145 (naming -> atom .)
    *               reduce using rule 145 (naming -> atom .)
    /               reduce using rule 145 (naming -> atom .)
    %               reduce using rule 145 (naming -> atom .)
    INTDIV          reduce using rule 145 (naming -> atom .)
    EQ              reduce using rule 145 (naming -> atom .)
    NEQ             reduce using rule 145 (naming -> atom .)
    GE              reduce using rule 145 (naming -> atom .)
    LE              reduce using rule 145 (naming -> atom .)
    >               reduce using rule 145 (naming -> atom .)
    <               reduce using rule 145 (naming -> atom .)
    +               reduce using rule 145 (naming -> atom .)
    -               reduce using rule 145 (naming -> atom .)
    AND             reduce using rule 145 (naming -> atom .)
    OR              reduce using rule 145 (naming -> atom .)
    ;               reduce using rule 145 (naming -> atom .)
    ^               shift and go to state 276
    @               shift and go to state 277


state 221

    (117) conjunction -> negation . AND negation
    (118) conjunction -> negation .

    AND             shift and go to state 278
    OR              reduce using rule 118 (conjunction -> negation .)
    ;               reduce using rule 118 (conjunction -> negation .)
    =               reduce using rule 118 (conjunction -> negation .)
    {               reduce using rule 118 (conjunction -> negation .)
    ,               reduce using rule 118 (conjunction -> negation .)
    ]               reduce using rule 118 (conjunction -> negation .)
    )               reduce using rule 118 (conjunction -> negation .)
    }               reduce using rule 118 (conjunction -> negation .)


state 222

    (155) word -> ORGANISM .

    .               reduce using rule 155 (word -> ORGANISM .)
    =               reduce using rule 155 (word -> ORGANISM .)
    [               reduce using rule 155 (word -> ORGANISM .)
    *               reduce using rule 155 (word -> ORGANISM .)
    /               reduce using rule 155 (word -> ORGANISM .)
    %               reduce using rule 155 (word -> ORGANISM .)
    INTDIV          reduce using rule 155 (word -> ORGANISM .)
    EQ              reduce using rule 155 (word -> ORGANISM .)
    NEQ             reduce using rule 155 (word -> ORGANISM .)
    GE              reduce using rule 155 (word -> ORGANISM .)
    LE              reduce using rule 155 (word -> ORGANISM .)
    >               reduce using rule 155 (word -> ORGANISM .)
    <               reduce using rule 155 (word -> ORGANISM .)
    +               reduce using rule 155 (word -> ORGANISM .)
    -               reduce using rule 155 (word -> ORGANISM .)
    AND             reduce using rule 155 (word -> ORGANISM .)
    OR              reduce using rule 155 (word -> ORGANISM .)
    ;               reduce using rule 155 (word -> ORGANISM .)
    {               reduce using rule 155 (word -> ORGANISM .)
    ,               reduce using rule 155 (word -> ORGANISM .)
    ]               reduce using rule 155 (word -> ORGANISM .)
    )               reduce using rule 155 (word -> ORGANISM .)
    }               reduce using rule 155 (word -> ORGANISM .)


state 223

    (157) word -> WORLD .

    .               reduce using rule 157 (word -> WORLD .)
    =               reduce using rule 157 (word -> WORLD .)
    [               reduce using rule 157 (word -> WORLD .)
    *               reduce using rule 157 (word -> WORLD .)
    /               reduce using rule 157 (word -> WORLD .)
    %               reduce using rule 157 (word -> WORLD .)
    INTDIV          reduce using rule 157 (word -> WORLD .)
    EQ              reduce using rule 157 (word -> WORLD .)
    NEQ             reduce using rule 157 (word -> WORLD .)
    GE              reduce using rule 157 (word -> WORLD .)
    LE              reduce using rule 157 (word -> WORLD .)
    >               reduce using rule 157 (word -> WORLD .)
    <               reduce using rule 157 (word -> WORLD .)
    +               reduce using rule 157 (word -> WORLD .)
    -               reduce using rule 157 (word -> WORLD .)
    AND             reduce using rule 157 (word -> WORLD .)
    OR              reduce using rule 157 (word -> WORLD .)
    ;               reduce using rule 157 (word -> WORLD .)
    {               reduce using rule 157 (word -> WORLD .)
    ,               reduce using rule 157 (word -> WORLD .)
    ]               reduce using rule 157 (word -> WORLD .)
    )               reduce using rule 157 (word -> WORLD .)
    }               reduce using rule 157 (word -> WORLD .)


state 224

    (146) atom -> NUMBER .

    ^               reduce using rule 146 (atom -> NUMBER .)
    @               reduce using rule 146 (atom -> NUMBER .)
    [               reduce using rule 146 (atom -> NUMBER .)
    *               reduce using rule 146 (atom -> NUMBER .)
    /               reduce using rule 146 (atom -> NUMBER .)
    %               reduce using rule 146 (atom -> NUMBER .)
    INTDIV          reduce using rule 146 (atom -> NUMBER .)
    EQ              reduce using rule 146 (atom -> NUMBER .)
    NEQ             reduce using rule 146 (atom -> NUMBER .)
    GE              reduce using rule 146 (atom -> NUMBER .)
    LE              reduce using rule 146 (atom -> NUMBER .)
    >               reduce using rule 146 (atom -> NUMBER .)
    <               reduce using rule 146 (atom -> NUMBER .)
    +               reduce using rule 146 (atom -> NUMBER .)
    -               reduce using rule 146 (atom -> NUMBER .)
    AND             reduce using rule 146 (atom -> NUMBER .)
    OR              reduce using rule 146 (atom -> NUMBER .)
    ;               reduce using rule 146 (atom -> NUMBER .)
    =               reduce using rule 146 (atom -> NUMBER .)
    {               reduce using rule 146 (atom -> NUMBER .)
    ,               reduce using rule 146 (atom -> NUMBER .)
    ]               reduce using rule 146 (atom -> NUMBER .)
    )               reduce using rule 146 (atom -> NUMBER .)
    }               reduce using rule 146 (atom -> NUMBER .)


state 225

    (147) atom -> STRING .

    ^               reduce using rule 147 (atom -> STRING .)
    @               reduce using rule 147 (atom -> STRING .)
    [               reduce using rule 147 (atom -> STRING .)
    *               reduce using rule 147 (atom -> STRING .)
    /               reduce using rule 147 (atom -> STRING .)
    %               reduce using rule 147 (atom -> STRING .)
    INTDIV          reduce using rule 147 (atom -> STRING .)
    EQ              reduce using rule 147 (atom -> STRING .)
    NEQ             reduce using rule 147 (atom -> STRING .)
    GE              reduce using rule 147 (atom -> STRING .)
    LE              reduce using rule 147 (atom -> STRING .)
    >               reduce using rule 147 (atom -> STRING .)
    <               reduce using rule 147 (atom -> STRING .)
    +               reduce using rule 147 (atom -> STRING .)
    -               reduce using rule 147 (atom -> STRING .)
    AND             reduce using rule 147 (atom -> STRING .)
    OR              reduce using rule 147 (atom -> STRING .)
    ;               reduce using rule 147 (atom -> STRING .)
    =               reduce using rule 147 (atom -> STRING .)
    {               reduce using rule 147 (atom -> STRING .)
    ,               reduce using rule 147 (atom -> STRING .)
    ]               reduce using rule 147 (atom -> STRING .)
    )               reduce using rule 147 (atom -> STRING .)
    }               reduce using rule 147 (atom -> STRING .)


state 226

    (148) atom -> bool .

    ^               reduce using rule 148 (atom -> bool .)
    @               reduce using rule 148 (atom -> bool .)
    [               reduce using rule 148 (atom -> bool .)
    *               reduce using rule 148 (atom -> bool .)
    /               reduce using rule 148 (atom -> bool .)
    %               reduce using rule 148 (atom -> bool .)
    INTDIV          reduce using rule 148 (atom -> bool .)
    EQ              reduce using rule 148 (atom -> bool .)
    NEQ             reduce using rule 148 (atom -> bool .)
    GE              reduce using rule 148 (atom -> bool .)
    LE              reduce using rule 148 (atom -> bool .)
    >               reduce using rule 148 (atom -> bool .)
    <               reduce using rule 148 (atom -> bool .)
    +               reduce using rule 148 (atom -> bool .)
    -               reduce using rule 148 (atom -> bool .)
    AND             reduce using rule 148 (atom -> bool .)
    OR              reduce using rule 148 (atom -> bool .)
    ;               reduce using rule 148 (atom -> bool .)
    =               reduce using rule 148 (atom -> bool .)
    {               reduce using rule 148 (atom -> bool .)
    ,               reduce using rule 148 (atom -> bool .)
    ]               reduce using rule 148 (atom -> bool .)
    )               reduce using rule 148 (atom -> bool .)
    }               reduce using rule 148 (atom -> bool .)


state 227

    (121) comparison -> expr . EQ expr
    (122) comparison -> expr . NEQ expr
    (123) comparison -> expr . GE expr
    (124) comparison -> expr . LE expr
    (125) comparison -> expr . > expr
    (126) comparison -> expr . < expr
    (127) comparison -> expr .
    (128) expr -> expr . + term
    (129) expr -> expr . - term

    EQ              shift and go to state 279
    NEQ             shift and go to state 280
    GE              shift and go to state 281
    LE              shift and go to state 282
    >               shift and go to state 283
    <               shift and go to state 284
    AND             reduce using rule 127 (comparison -> expr .)
    OR              reduce using rule 127 (comparison -> expr .)
    ;               reduce using rule 127 (comparison -> expr .)
    =               reduce using rule 127 (comparison -> expr .)
    {               reduce using rule 127 (comparison -> expr .)
    ,               reduce using rule 127 (comparison -> expr .)
    ]               reduce using rule 127 (comparison -> expr .)
    )               reduce using rule 127 (comparison -> expr .)
    }               reduce using rule 127 (comparison -> expr .)
    +               shift and go to state 285
    -               shift and go to state 286


state 228

    (119) negation -> NOT . comparison
    (121) comparison -> . expr EQ expr
    (122) comparison -> . expr NEQ expr
    (123) comparison -> . expr GE expr
    (124) comparison -> . expr LE expr
    (125) comparison -> . expr > expr
    (126) comparison -> . expr < expr
    (127) comparison -> . expr
    (128) expr -> . expr + term
    (129) expr -> . expr - term
    (130) expr -> . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    comparison                     shift and go to state 287
    expr                           shift and go to state 227
    term                           shift and go to state 230
    factor                         shift and go to state 232
    power                          shift and go to state 233
    atom                           shift and go to state 248
    naming                         shift and go to state 249
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 229

    (120) negation -> comparison .

    AND             reduce using rule 120 (negation -> comparison .)
    OR              reduce using rule 120 (negation -> comparison .)
    ;               reduce using rule 120 (negation -> comparison .)
    =               reduce using rule 120 (negation -> comparison .)
    {               reduce using rule 120 (negation -> comparison .)
    ,               reduce using rule 120 (negation -> comparison .)
    ]               reduce using rule 120 (negation -> comparison .)
    )               reduce using rule 120 (negation -> comparison .)
    }               reduce using rule 120 (negation -> comparison .)


state 230

    (130) expr -> term .
    (131) term -> term . * factor
    (132) term -> term . / factor
    (133) term -> term . % factor
    (134) term -> term . INTDIV factor

    EQ              reduce using rule 130 (expr -> term .)
    NEQ             reduce using rule 130 (expr -> term .)
    GE              reduce using rule 130 (expr -> term .)
    LE              reduce using rule 130 (expr -> term .)
    >               reduce using rule 130 (expr -> term .)
    <               reduce using rule 130 (expr -> term .)
    +               reduce using rule 130 (expr -> term .)
    -               reduce using rule 130 (expr -> term .)
    AND             reduce using rule 130 (expr -> term .)
    OR              reduce using rule 130 (expr -> term .)
    ;               reduce using rule 130 (expr -> term .)
    =               reduce using rule 130 (expr -> term .)
    {               reduce using rule 130 (expr -> term .)
    ,               reduce using rule 130 (expr -> term .)
    ]               reduce using rule 130 (expr -> term .)
    )               reduce using rule 130 (expr -> term .)
    }               reduce using rule 130 (expr -> term .)
    *               shift and go to state 288
    /               shift and go to state 289
    %               shift and go to state 290
    INTDIV          shift and go to state 291


state 231

    (136) factor -> - . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    factor                         shift and go to state 292
    power                          shift and go to state 233
    atom                           shift and go to state 248
    naming                         shift and go to state 249
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 232

    (135) term -> factor .

    *               reduce using rule 135 (term -> factor .)
    /               reduce using rule 135 (term -> factor .)
    %               reduce using rule 135 (term -> factor .)
    INTDIV          reduce using rule 135 (term -> factor .)
    EQ              reduce using rule 135 (term -> factor .)
    NEQ             reduce using rule 135 (term -> factor .)
    GE              reduce using rule 135 (term -> factor .)
    LE              reduce using rule 135 (term -> factor .)
    >               reduce using rule 135 (term -> factor .)
    <               reduce using rule 135 (term -> factor .)
    +               reduce using rule 135 (term -> factor .)
    -               reduce using rule 135 (term -> factor .)
    AND             reduce using rule 135 (term -> factor .)
    OR              reduce using rule 135 (term -> factor .)
    ;               reduce using rule 135 (term -> factor .)
    =               reduce using rule 135 (term -> factor .)
    {               reduce using rule 135 (term -> factor .)
    ,               reduce using rule 135 (term -> factor .)
    ]               reduce using rule 135 (term -> factor .)
    )               reduce using rule 135 (term -> factor .)
    }               reduce using rule 135 (term -> factor .)


state 233

    (137) factor -> power .

    *               reduce using rule 137 (factor -> power .)
    /               reduce using rule 137 (factor -> power .)
    %               reduce using rule 137 (factor -> power .)
    INTDIV          reduce using rule 137 (factor -> power .)
    EQ              reduce using rule 137 (factor -> power .)
    NEQ             reduce using rule 137 (factor -> power .)
    GE              reduce using rule 137 (factor -> power .)
    LE              reduce using rule 137 (factor -> power .)
    >               reduce using rule 137 (factor -> power .)
    <               reduce using rule 137 (factor -> power .)
    +               reduce using rule 137 (factor -> power .)
    -               reduce using rule 137 (factor -> power .)
    AND             reduce using rule 137 (factor -> power .)
    OR              reduce using rule 137 (factor -> power .)
    ;               reduce using rule 137 (factor -> power .)
    =               reduce using rule 137 (factor -> power .)
    {               reduce using rule 137 (factor -> power .)
    ,               reduce using rule 137 (factor -> power .)
    ]               reduce using rule 137 (factor -> power .)
    )               reduce using rule 137 (factor -> power .)
    }               reduce using rule 137 (factor -> power .)


state 234

    (83) simprop -> AVAILABLE_COMMANDS { command_list } .

    EPISODES        reduce using rule 83 (simprop -> AVAILABLE_COMMANDS { command_list } .)
    MAX_ROUNDS      reduce using rule 83 (simprop -> AVAILABLE_COMMANDS { command_list } .)
    ACTIONS_TIME    reduce using rule 83 (simprop -> AVAILABLE_COMMANDS { command_list } .)
    STOP            reduce using rule 83 (simprop -> AVAILABLE_COMMANDS { command_list } .)
    AVAILABLE_COMMANDS reduce using rule 83 (simprop -> AVAILABLE_COMMANDS { command_list } .)
    }               reduce using rule 83 (simprop -> AVAILABLE_COMMANDS { command_list } .)


state 235

    (84) command_list -> ID command_list .

    }               reduce using rule 84 (command_list -> ID command_list .)


state 236

    (66) worldsize -> INFINITE { worldsizeprop worldsizeprop . }

    }               shift and go to state 293


state 237

    (67) worldsize -> { worldsizeprop worldsizeprop } .

    SIZE            reduce using rule 67 (worldsize -> { worldsizeprop worldsizeprop } .)
    TERRAIN         reduce using rule 67 (worldsize -> { worldsizeprop worldsizeprop } .)
    }               reduce using rule 67 (worldsize -> { worldsizeprop worldsizeprop } .)


state 238

    (75) terrainprop -> ID AT { . NUMBER terrainposn_list }

    NUMBER          shift and go to state 294


state 239

    (62) position -> ( NUMBER NUMBER ) .

    (               reduce using rule 62 (position -> ( NUMBER NUMBER ) .)
    }               reduce using rule 62 (position -> ( NUMBER NUMBER ) .)


state 240

    (47) decide_stmt -> DECIDE ORGANISM TIME { stmt_list . }

    }               shift and go to state 295


state 241

    (88) func_stmt -> FUNC ID = param_list { stmt_list . }

    }               shift and go to state 296


state 242

    (30) phygeneprop -> VALUE NUMBER IN { NUMBER NUMBER } .

    VALUE           reduce using rule 30 (phygeneprop -> VALUE NUMBER IN { NUMBER NUMBER } .)
    MUTATION        reduce using rule 30 (phygeneprop -> VALUE NUMBER IN { NUMBER NUMBER } .)
    }               reduce using rule 30 (phygeneprop -> VALUE NUMBER IN { NUMBER NUMBER } .)


state 243

    (78) sim_stmt -> SIMULATION { simprop simprop simprop simprop simprop . }

    }               shift and go to state 297


state 244

    (151) atom -> { keyarg_list . }

    }               shift and go to state 298


state 245

    (163) keyarg_list -> keyarg .
    (164) keyarg_list -> keyarg . , keyarg_list

    }               reduce using rule 163 (keyarg_list -> keyarg .)
    ,               shift and go to state 299


state 246

    (165) keyarg_list -> epsilon .

    }               reduce using rule 165 (keyarg_list -> epsilon .)


state 247

    (166) keyarg -> disjunction . = disjunction

    =               shift and go to state 300


state 248

    (138) power -> atom . ^ factor
    (139) power -> atom . @ factor
    (145) naming -> atom .

    ^               shift and go to state 276
    @               shift and go to state 277
    [               reduce using rule 145 (naming -> atom .)
    *               reduce using rule 145 (naming -> atom .)
    /               reduce using rule 145 (naming -> atom .)
    %               reduce using rule 145 (naming -> atom .)
    INTDIV          reduce using rule 145 (naming -> atom .)
    EQ              reduce using rule 145 (naming -> atom .)
    NEQ             reduce using rule 145 (naming -> atom .)
    GE              reduce using rule 145 (naming -> atom .)
    LE              reduce using rule 145 (naming -> atom .)
    >               reduce using rule 145 (naming -> atom .)
    <               reduce using rule 145 (naming -> atom .)
    +               reduce using rule 145 (naming -> atom .)
    -               reduce using rule 145 (naming -> atom .)
    AND             reduce using rule 145 (naming -> atom .)
    OR              reduce using rule 145 (naming -> atom .)
    =               reduce using rule 145 (naming -> atom .)
    ;               reduce using rule 145 (naming -> atom .)
    {               reduce using rule 145 (naming -> atom .)
    ,               reduce using rule 145 (naming -> atom .)
    ]               reduce using rule 145 (naming -> atom .)
    )               reduce using rule 145 (naming -> atom .)
    }               reduce using rule 145 (naming -> atom .)


state 249

    (140) power -> naming .
    (141) naming -> naming . [ disjunction ]

    *               reduce using rule 140 (power -> naming .)
    /               reduce using rule 140 (power -> naming .)
    %               reduce using rule 140 (power -> naming .)
    INTDIV          reduce using rule 140 (power -> naming .)
    EQ              reduce using rule 140 (power -> naming .)
    NEQ             reduce using rule 140 (power -> naming .)
    GE              reduce using rule 140 (power -> naming .)
    LE              reduce using rule 140 (power -> naming .)
    >               reduce using rule 140 (power -> naming .)
    <               reduce using rule 140 (power -> naming .)
    +               reduce using rule 140 (power -> naming .)
    -               reduce using rule 140 (power -> naming .)
    AND             reduce using rule 140 (power -> naming .)
    OR              reduce using rule 140 (power -> naming .)
    =               reduce using rule 140 (power -> naming .)
    ;               reduce using rule 140 (power -> naming .)
    {               reduce using rule 140 (power -> naming .)
    ,               reduce using rule 140 (power -> naming .)
    ]               reduce using rule 140 (power -> naming .)
    )               reduce using rule 140 (power -> naming .)
    }               reduce using rule 140 (power -> naming .)
    [               shift and go to state 301


state 250

    (142) naming -> accessing .

    [               reduce using rule 142 (naming -> accessing .)
    *               reduce using rule 142 (naming -> accessing .)
    /               reduce using rule 142 (naming -> accessing .)
    %               reduce using rule 142 (naming -> accessing .)
    INTDIV          reduce using rule 142 (naming -> accessing .)
    EQ              reduce using rule 142 (naming -> accessing .)
    NEQ             reduce using rule 142 (naming -> accessing .)
    GE              reduce using rule 142 (naming -> accessing .)
    LE              reduce using rule 142 (naming -> accessing .)
    >               reduce using rule 142 (naming -> accessing .)
    <               reduce using rule 142 (naming -> accessing .)
    +               reduce using rule 142 (naming -> accessing .)
    -               reduce using rule 142 (naming -> accessing .)
    AND             reduce using rule 142 (naming -> accessing .)
    OR              reduce using rule 142 (naming -> accessing .)
    =               reduce using rule 142 (naming -> accessing .)
    ;               reduce using rule 142 (naming -> accessing .)
    {               reduce using rule 142 (naming -> accessing .)
    ,               reduce using rule 142 (naming -> accessing .)
    ]               reduce using rule 142 (naming -> accessing .)
    )               reduce using rule 142 (naming -> accessing .)
    }               reduce using rule 142 (naming -> accessing .)


state 251

    (82) simprop -> STOP SIMULATION { stmt_list } .

    EPISODES        reduce using rule 82 (simprop -> STOP SIMULATION { stmt_list } .)
    MAX_ROUNDS      reduce using rule 82 (simprop -> STOP SIMULATION { stmt_list } .)
    ACTIONS_TIME    reduce using rule 82 (simprop -> STOP SIMULATION { stmt_list } .)
    STOP            reduce using rule 82 (simprop -> STOP SIMULATION { stmt_list } .)
    AVAILABLE_COMMANDS reduce using rule 82 (simprop -> STOP SIMULATION { stmt_list } .)
    }               reduce using rule 82 (simprop -> STOP SIMULATION { stmt_list } .)


state 252

    (91) stmt_list -> stmt stmt_list .

    }               reduce using rule 91 (stmt_list -> stmt stmt_list .)


state 253

    (94) stmt -> var_stmt ; .

    CONTINUE        reduce using rule 94 (stmt -> var_stmt ; .)
    BREAK           reduce using rule 94 (stmt -> var_stmt ; .)
    RETURN          reduce using rule 94 (stmt -> var_stmt ; .)
    IF              reduce using rule 94 (stmt -> var_stmt ; .)
    LOOP            reduce using rule 94 (stmt -> var_stmt ; .)
    KEYS            reduce using rule 94 (stmt -> var_stmt ; .)
    ID              reduce using rule 94 (stmt -> var_stmt ; .)
    ORGANISM        reduce using rule 94 (stmt -> var_stmt ; .)
    SIMULATION      reduce using rule 94 (stmt -> var_stmt ; .)
    WORLD           reduce using rule 94 (stmt -> var_stmt ; .)
    NUMBER          reduce using rule 94 (stmt -> var_stmt ; .)
    STRING          reduce using rule 94 (stmt -> var_stmt ; .)
    (               reduce using rule 94 (stmt -> var_stmt ; .)
    [               reduce using rule 94 (stmt -> var_stmt ; .)
    {               reduce using rule 94 (stmt -> var_stmt ; .)
    NOT             reduce using rule 94 (stmt -> var_stmt ; .)
    TRUE            reduce using rule 94 (stmt -> var_stmt ; .)
    FALSE           reduce using rule 94 (stmt -> var_stmt ; .)
    -               reduce using rule 94 (stmt -> var_stmt ; .)
    }               reduce using rule 94 (stmt -> var_stmt ; .)


state 254

    (95) stmt -> index_stmt ; .

    CONTINUE        reduce using rule 95 (stmt -> index_stmt ; .)
    BREAK           reduce using rule 95 (stmt -> index_stmt ; .)
    RETURN          reduce using rule 95 (stmt -> index_stmt ; .)
    IF              reduce using rule 95 (stmt -> index_stmt ; .)
    LOOP            reduce using rule 95 (stmt -> index_stmt ; .)
    KEYS            reduce using rule 95 (stmt -> index_stmt ; .)
    ID              reduce using rule 95 (stmt -> index_stmt ; .)
    ORGANISM        reduce using rule 95 (stmt -> index_stmt ; .)
    SIMULATION      reduce using rule 95 (stmt -> index_stmt ; .)
    WORLD           reduce using rule 95 (stmt -> index_stmt ; .)
    NUMBER          reduce using rule 95 (stmt -> index_stmt ; .)
    STRING          reduce using rule 95 (stmt -> index_stmt ; .)
    (               reduce using rule 95 (stmt -> index_stmt ; .)
    [               reduce using rule 95 (stmt -> index_stmt ; .)
    {               reduce using rule 95 (stmt -> index_stmt ; .)
    NOT             reduce using rule 95 (stmt -> index_stmt ; .)
    TRUE            reduce using rule 95 (stmt -> index_stmt ; .)
    FALSE           reduce using rule 95 (stmt -> index_stmt ; .)
    -               reduce using rule 95 (stmt -> index_stmt ; .)
    }               reduce using rule 95 (stmt -> index_stmt ; .)


state 255

    (96) stmt -> disjunction ; .

    CONTINUE        reduce using rule 96 (stmt -> disjunction ; .)
    BREAK           reduce using rule 96 (stmt -> disjunction ; .)
    RETURN          reduce using rule 96 (stmt -> disjunction ; .)
    IF              reduce using rule 96 (stmt -> disjunction ; .)
    LOOP            reduce using rule 96 (stmt -> disjunction ; .)
    KEYS            reduce using rule 96 (stmt -> disjunction ; .)
    ID              reduce using rule 96 (stmt -> disjunction ; .)
    ORGANISM        reduce using rule 96 (stmt -> disjunction ; .)
    SIMULATION      reduce using rule 96 (stmt -> disjunction ; .)
    WORLD           reduce using rule 96 (stmt -> disjunction ; .)
    NUMBER          reduce using rule 96 (stmt -> disjunction ; .)
    STRING          reduce using rule 96 (stmt -> disjunction ; .)
    (               reduce using rule 96 (stmt -> disjunction ; .)
    [               reduce using rule 96 (stmt -> disjunction ; .)
    {               reduce using rule 96 (stmt -> disjunction ; .)
    NOT             reduce using rule 96 (stmt -> disjunction ; .)
    TRUE            reduce using rule 96 (stmt -> disjunction ; .)
    FALSE           reduce using rule 96 (stmt -> disjunction ; .)
    -               reduce using rule 96 (stmt -> disjunction ; .)
    }               reduce using rule 96 (stmt -> disjunction ; .)


state 256

    (98) stmt -> CONTINUE ; .

    CONTINUE        reduce using rule 98 (stmt -> CONTINUE ; .)
    BREAK           reduce using rule 98 (stmt -> CONTINUE ; .)
    RETURN          reduce using rule 98 (stmt -> CONTINUE ; .)
    IF              reduce using rule 98 (stmt -> CONTINUE ; .)
    LOOP            reduce using rule 98 (stmt -> CONTINUE ; .)
    KEYS            reduce using rule 98 (stmt -> CONTINUE ; .)
    ID              reduce using rule 98 (stmt -> CONTINUE ; .)
    ORGANISM        reduce using rule 98 (stmt -> CONTINUE ; .)
    SIMULATION      reduce using rule 98 (stmt -> CONTINUE ; .)
    WORLD           reduce using rule 98 (stmt -> CONTINUE ; .)
    NUMBER          reduce using rule 98 (stmt -> CONTINUE ; .)
    STRING          reduce using rule 98 (stmt -> CONTINUE ; .)
    (               reduce using rule 98 (stmt -> CONTINUE ; .)
    [               reduce using rule 98 (stmt -> CONTINUE ; .)
    {               reduce using rule 98 (stmt -> CONTINUE ; .)
    NOT             reduce using rule 98 (stmt -> CONTINUE ; .)
    TRUE            reduce using rule 98 (stmt -> CONTINUE ; .)
    FALSE           reduce using rule 98 (stmt -> CONTINUE ; .)
    -               reduce using rule 98 (stmt -> CONTINUE ; .)
    }               reduce using rule 98 (stmt -> CONTINUE ; .)


state 257

    (99) stmt -> BREAK ; .

    CONTINUE        reduce using rule 99 (stmt -> BREAK ; .)
    BREAK           reduce using rule 99 (stmt -> BREAK ; .)
    RETURN          reduce using rule 99 (stmt -> BREAK ; .)
    IF              reduce using rule 99 (stmt -> BREAK ; .)
    LOOP            reduce using rule 99 (stmt -> BREAK ; .)
    KEYS            reduce using rule 99 (stmt -> BREAK ; .)
    ID              reduce using rule 99 (stmt -> BREAK ; .)
    ORGANISM        reduce using rule 99 (stmt -> BREAK ; .)
    SIMULATION      reduce using rule 99 (stmt -> BREAK ; .)
    WORLD           reduce using rule 99 (stmt -> BREAK ; .)
    NUMBER          reduce using rule 99 (stmt -> BREAK ; .)
    STRING          reduce using rule 99 (stmt -> BREAK ; .)
    (               reduce using rule 99 (stmt -> BREAK ; .)
    [               reduce using rule 99 (stmt -> BREAK ; .)
    {               reduce using rule 99 (stmt -> BREAK ; .)
    NOT             reduce using rule 99 (stmt -> BREAK ; .)
    TRUE            reduce using rule 99 (stmt -> BREAK ; .)
    FALSE           reduce using rule 99 (stmt -> BREAK ; .)
    -               reduce using rule 99 (stmt -> BREAK ; .)
    }               reduce using rule 99 (stmt -> BREAK ; .)


state 258

    (100) stmt -> RETURN disjunction . ;

    ;               shift and go to state 302


state 259

    (101) stmt -> RETURN ; .

    CONTINUE        reduce using rule 101 (stmt -> RETURN ; .)
    BREAK           reduce using rule 101 (stmt -> RETURN ; .)
    RETURN          reduce using rule 101 (stmt -> RETURN ; .)
    IF              reduce using rule 101 (stmt -> RETURN ; .)
    LOOP            reduce using rule 101 (stmt -> RETURN ; .)
    KEYS            reduce using rule 101 (stmt -> RETURN ; .)
    ID              reduce using rule 101 (stmt -> RETURN ; .)
    ORGANISM        reduce using rule 101 (stmt -> RETURN ; .)
    SIMULATION      reduce using rule 101 (stmt -> RETURN ; .)
    WORLD           reduce using rule 101 (stmt -> RETURN ; .)
    NUMBER          reduce using rule 101 (stmt -> RETURN ; .)
    STRING          reduce using rule 101 (stmt -> RETURN ; .)
    (               reduce using rule 101 (stmt -> RETURN ; .)
    [               reduce using rule 101 (stmt -> RETURN ; .)
    {               reduce using rule 101 (stmt -> RETURN ; .)
    NOT             reduce using rule 101 (stmt -> RETURN ; .)
    TRUE            reduce using rule 101 (stmt -> RETURN ; .)
    FALSE           reduce using rule 101 (stmt -> RETURN ; .)
    -               reduce using rule 101 (stmt -> RETURN ; .)
    }               reduce using rule 101 (stmt -> RETURN ; .)


state 260

    (104) if_stmt -> IF disjunction . { stmt_list } else_stmt

    {               shift and go to state 303


state 261

    (102) var_stmt -> accessing = . disjunction
    (115) disjunction -> . conjunction OR conjunction
    (116) disjunction -> . conjunction
    (117) conjunction -> . negation AND negation
    (118) conjunction -> . negation
    (119) negation -> . NOT comparison
    (120) negation -> . comparison
    (121) comparison -> . expr EQ expr
    (122) comparison -> . expr NEQ expr
    (123) comparison -> . expr GE expr
    (124) comparison -> . expr LE expr
    (125) comparison -> . expr > expr
    (126) comparison -> . expr < expr
    (127) comparison -> . expr
    (128) expr -> . expr + term
    (129) expr -> . expr - term
    (130) expr -> . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    NOT             shift and go to state 228
    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    accessing                      shift and go to state 250
    disjunction                    shift and go to state 304
    conjunction                    shift and go to state 214
    negation                       shift and go to state 221
    comparison                     shift and go to state 229
    expr                           shift and go to state 227
    term                           shift and go to state 230
    factor                         shift and go to state 232
    power                          shift and go to state 233
    atom                           shift and go to state 248
    naming                         shift and go to state 249
    bool                           shift and go to state 226
    word                           shift and go to state 216

state 262

    (103) index_stmt -> naming [ . disjunction ] = disjunction
    (141) naming -> naming [ . disjunction ]
    (115) disjunction -> . conjunction OR conjunction
    (116) disjunction -> . conjunction
    (117) conjunction -> . negation AND negation
    (118) conjunction -> . negation
    (119) negation -> . NOT comparison
    (120) negation -> . comparison
    (121) comparison -> . expr EQ expr
    (122) comparison -> . expr NEQ expr
    (123) comparison -> . expr GE expr
    (124) comparison -> . expr LE expr
    (125) comparison -> . expr > expr
    (126) comparison -> . expr < expr
    (127) comparison -> . expr
    (128) expr -> . expr + term
    (129) expr -> . expr - term
    (130) expr -> . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    NOT             shift and go to state 228
    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    naming                         shift and go to state 249
    disjunction                    shift and go to state 305
    conjunction                    shift and go to state 214
    negation                       shift and go to state 221
    comparison                     shift and go to state 229
    expr                           shift and go to state 227
    term                           shift and go to state 230
    factor                         shift and go to state 232
    power                          shift and go to state 233
    atom                           shift and go to state 248
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 263

    (150) atom -> [ arg_list . ]

    ]               shift and go to state 306


state 264

    (160) arg_list -> disjunction .
    (161) arg_list -> disjunction . , arg_list

    ]               reduce using rule 160 (arg_list -> disjunction .)
    )               reduce using rule 160 (arg_list -> disjunction .)
    ,               shift and go to state 307


state 265

    (162) arg_list -> epsilon .

    ]               reduce using rule 162 (arg_list -> epsilon .)
    )               reduce using rule 162 (arg_list -> epsilon .)


state 266

    (115) disjunction -> conjunction OR . conjunction
    (117) conjunction -> . negation AND negation
    (118) conjunction -> . negation
    (119) negation -> . NOT comparison
    (120) negation -> . comparison
    (121) comparison -> . expr EQ expr
    (122) comparison -> . expr NEQ expr
    (123) comparison -> . expr GE expr
    (124) comparison -> . expr LE expr
    (125) comparison -> . expr > expr
    (126) comparison -> . expr < expr
    (127) comparison -> . expr
    (128) expr -> . expr + term
    (129) expr -> . expr - term
    (130) expr -> . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    NOT             shift and go to state 228
    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    conjunction                    shift and go to state 308
    negation                       shift and go to state 221
    comparison                     shift and go to state 229
    expr                           shift and go to state 227
    term                           shift and go to state 230
    factor                         shift and go to state 232
    power                          shift and go to state 233
    atom                           shift and go to state 248
    naming                         shift and go to state 249
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 267

    (108) loop_stmt -> LOOP loop_init . , loop_condition , loop_set { stmt_list }

    ,               shift and go to state 309


state 268

    (109) loop_init -> var_stmt .

    ,               reduce using rule 109 (loop_init -> var_stmt .)


state 269

    (110) loop_init -> epsilon .

    ,               reduce using rule 110 (loop_init -> epsilon .)


state 270

    (102) var_stmt -> accessing . = disjunction

    =               shift and go to state 261


state 271

    (154) word -> ID .

    .               reduce using rule 154 (word -> ID .)
    =               reduce using rule 154 (word -> ID .)
    [               reduce using rule 154 (word -> ID .)
    *               reduce using rule 154 (word -> ID .)
    /               reduce using rule 154 (word -> ID .)
    %               reduce using rule 154 (word -> ID .)
    INTDIV          reduce using rule 154 (word -> ID .)
    EQ              reduce using rule 154 (word -> ID .)
    NEQ             reduce using rule 154 (word -> ID .)
    GE              reduce using rule 154 (word -> ID .)
    LE              reduce using rule 154 (word -> ID .)
    >               reduce using rule 154 (word -> ID .)
    <               reduce using rule 154 (word -> ID .)
    +               reduce using rule 154 (word -> ID .)
    -               reduce using rule 154 (word -> ID .)
    AND             reduce using rule 154 (word -> ID .)
    OR              reduce using rule 154 (word -> ID .)
    ;               reduce using rule 154 (word -> ID .)
    {               reduce using rule 154 (word -> ID .)
    ,               reduce using rule 154 (word -> ID .)
    ]               reduce using rule 154 (word -> ID .)
    )               reduce using rule 154 (word -> ID .)
    }               reduce using rule 154 (word -> ID .)


state 272

    (153) accessing -> word . . accessing
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    ID              shift and go to state 271
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    word                           shift and go to state 216
    accessing                      shift and go to state 310

state 273

    (143) naming -> KEYS ( . naming )
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD
    (158) bool -> . TRUE
    (159) bool -> . FALSE

    KEYS            shift and go to state 217
    ID              shift and go to state 219
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103

    naming                         shift and go to state 311
    accessing                      shift and go to state 250
    atom                           shift and go to state 312
    word                           shift and go to state 216
    bool                           shift and go to state 226

state 274

    (149) atom -> ( expr . )
    (128) expr -> expr . + term
    (129) expr -> expr . - term

    )               shift and go to state 313
    +               shift and go to state 285
    -               shift and go to state 286


state 275

    (144) naming -> ID ( . arg_list )
    (160) arg_list -> . disjunction
    (161) arg_list -> . disjunction , arg_list
    (162) arg_list -> . epsilon
    (115) disjunction -> . conjunction OR conjunction
    (116) disjunction -> . conjunction
    (2) epsilon -> .
    (117) conjunction -> . negation AND negation
    (118) conjunction -> . negation
    (119) negation -> . NOT comparison
    (120) negation -> . comparison
    (121) comparison -> . expr EQ expr
    (122) comparison -> . expr NEQ expr
    (123) comparison -> . expr GE expr
    (124) comparison -> . expr LE expr
    (125) comparison -> . expr > expr
    (126) comparison -> . expr < expr
    (127) comparison -> . expr
    (128) expr -> . expr + term
    (129) expr -> . expr - term
    (130) expr -> . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    )               reduce using rule 2 (epsilon -> .)
    NOT             shift and go to state 228
    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    arg_list                       shift and go to state 314
    disjunction                    shift and go to state 264
    epsilon                        shift and go to state 265
    conjunction                    shift and go to state 214
    negation                       shift and go to state 221
    comparison                     shift and go to state 229
    expr                           shift and go to state 227
    term                           shift and go to state 230
    factor                         shift and go to state 232
    power                          shift and go to state 233
    atom                           shift and go to state 248
    naming                         shift and go to state 249
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 276

    (138) power -> atom ^ . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    atom                           shift and go to state 248
    factor                         shift and go to state 315
    power                          shift and go to state 233
    naming                         shift and go to state 249
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 277

    (139) power -> atom @ . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    atom                           shift and go to state 248
    factor                         shift and go to state 316
    power                          shift and go to state 233
    naming                         shift and go to state 249
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 278

    (117) conjunction -> negation AND . negation
    (119) negation -> . NOT comparison
    (120) negation -> . comparison
    (121) comparison -> . expr EQ expr
    (122) comparison -> . expr NEQ expr
    (123) comparison -> . expr GE expr
    (124) comparison -> . expr LE expr
    (125) comparison -> . expr > expr
    (126) comparison -> . expr < expr
    (127) comparison -> . expr
    (128) expr -> . expr + term
    (129) expr -> . expr - term
    (130) expr -> . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    NOT             shift and go to state 228
    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    negation                       shift and go to state 317
    comparison                     shift and go to state 229
    expr                           shift and go to state 227
    term                           shift and go to state 230
    factor                         shift and go to state 232
    power                          shift and go to state 233
    atom                           shift and go to state 248
    naming                         shift and go to state 249
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 279

    (121) comparison -> expr EQ . expr
    (128) expr -> . expr + term
    (129) expr -> . expr - term
    (130) expr -> . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    expr                           shift and go to state 318
    term                           shift and go to state 230
    factor                         shift and go to state 232
    power                          shift and go to state 233
    atom                           shift and go to state 248
    naming                         shift and go to state 249
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 280

    (122) comparison -> expr NEQ . expr
    (128) expr -> . expr + term
    (129) expr -> . expr - term
    (130) expr -> . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    expr                           shift and go to state 319
    term                           shift and go to state 230
    factor                         shift and go to state 232
    power                          shift and go to state 233
    atom                           shift and go to state 248
    naming                         shift and go to state 249
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 281

    (123) comparison -> expr GE . expr
    (128) expr -> . expr + term
    (129) expr -> . expr - term
    (130) expr -> . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    expr                           shift and go to state 320
    term                           shift and go to state 230
    factor                         shift and go to state 232
    power                          shift and go to state 233
    atom                           shift and go to state 248
    naming                         shift and go to state 249
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 282

    (124) comparison -> expr LE . expr
    (128) expr -> . expr + term
    (129) expr -> . expr - term
    (130) expr -> . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    expr                           shift and go to state 321
    term                           shift and go to state 230
    factor                         shift and go to state 232
    power                          shift and go to state 233
    atom                           shift and go to state 248
    naming                         shift and go to state 249
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 283

    (125) comparison -> expr > . expr
    (128) expr -> . expr + term
    (129) expr -> . expr - term
    (130) expr -> . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    expr                           shift and go to state 322
    term                           shift and go to state 230
    factor                         shift and go to state 232
    power                          shift and go to state 233
    atom                           shift and go to state 248
    naming                         shift and go to state 249
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 284

    (126) comparison -> expr < . expr
    (128) expr -> . expr + term
    (129) expr -> . expr - term
    (130) expr -> . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    expr                           shift and go to state 323
    term                           shift and go to state 230
    factor                         shift and go to state 232
    power                          shift and go to state 233
    atom                           shift and go to state 248
    naming                         shift and go to state 249
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 285

    (128) expr -> expr + . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    term                           shift and go to state 324
    factor                         shift and go to state 232
    power                          shift and go to state 233
    atom                           shift and go to state 248
    naming                         shift and go to state 249
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 286

    (129) expr -> expr - . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    term                           shift and go to state 325
    factor                         shift and go to state 232
    power                          shift and go to state 233
    atom                           shift and go to state 248
    naming                         shift and go to state 249
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 287

    (119) negation -> NOT comparison .

    AND             reduce using rule 119 (negation -> NOT comparison .)
    OR              reduce using rule 119 (negation -> NOT comparison .)
    ;               reduce using rule 119 (negation -> NOT comparison .)
    =               reduce using rule 119 (negation -> NOT comparison .)
    {               reduce using rule 119 (negation -> NOT comparison .)
    ,               reduce using rule 119 (negation -> NOT comparison .)
    ]               reduce using rule 119 (negation -> NOT comparison .)
    )               reduce using rule 119 (negation -> NOT comparison .)
    }               reduce using rule 119 (negation -> NOT comparison .)


state 288

    (131) term -> term * . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    factor                         shift and go to state 326
    power                          shift and go to state 233
    atom                           shift and go to state 248
    naming                         shift and go to state 249
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 289

    (132) term -> term / . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    factor                         shift and go to state 327
    power                          shift and go to state 233
    atom                           shift and go to state 248
    naming                         shift and go to state 249
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 290

    (133) term -> term % . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    factor                         shift and go to state 328
    power                          shift and go to state 233
    atom                           shift and go to state 248
    naming                         shift and go to state 249
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 291

    (134) term -> term INTDIV . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    factor                         shift and go to state 329
    power                          shift and go to state 233
    atom                           shift and go to state 248
    naming                         shift and go to state 249
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 292

    (136) factor -> - factor .

    *               reduce using rule 136 (factor -> - factor .)
    /               reduce using rule 136 (factor -> - factor .)
    %               reduce using rule 136 (factor -> - factor .)
    INTDIV          reduce using rule 136 (factor -> - factor .)
    EQ              reduce using rule 136 (factor -> - factor .)
    NEQ             reduce using rule 136 (factor -> - factor .)
    GE              reduce using rule 136 (factor -> - factor .)
    LE              reduce using rule 136 (factor -> - factor .)
    >               reduce using rule 136 (factor -> - factor .)
    <               reduce using rule 136 (factor -> - factor .)
    +               reduce using rule 136 (factor -> - factor .)
    -               reduce using rule 136 (factor -> - factor .)
    AND             reduce using rule 136 (factor -> - factor .)
    OR              reduce using rule 136 (factor -> - factor .)
    ;               reduce using rule 136 (factor -> - factor .)
    =               reduce using rule 136 (factor -> - factor .)
    {               reduce using rule 136 (factor -> - factor .)
    ,               reduce using rule 136 (factor -> - factor .)
    ]               reduce using rule 136 (factor -> - factor .)
    )               reduce using rule 136 (factor -> - factor .)
    }               reduce using rule 136 (factor -> - factor .)


state 293

    (66) worldsize -> INFINITE { worldsizeprop worldsizeprop } .

    SIZE            reduce using rule 66 (worldsize -> INFINITE { worldsizeprop worldsizeprop } .)
    TERRAIN         reduce using rule 66 (worldsize -> INFINITE { worldsizeprop worldsizeprop } .)
    }               reduce using rule 66 (worldsize -> INFINITE { worldsizeprop worldsizeprop } .)


state 294

    (75) terrainprop -> ID AT { NUMBER . terrainposn_list }
    (76) terrainposn_list -> . NUMBER terrainposn_list
    (77) terrainposn_list -> . epsilon
    (2) epsilon -> .

    NUMBER          shift and go to state 330
    }               reduce using rule 2 (epsilon -> .)

    terrainposn_list               shift and go to state 331
    epsilon                        shift and go to state 332

state 295

    (47) decide_stmt -> DECIDE ORGANISM TIME { stmt_list } .

    }               reduce using rule 47 (decide_stmt -> DECIDE ORGANISM TIME { stmt_list } .)


state 296

    (88) func_stmt -> FUNC ID = param_list { stmt_list } .

    FUNC            reduce using rule 88 (func_stmt -> FUNC ID = param_list { stmt_list } .)
    DECIDE          reduce using rule 88 (func_stmt -> FUNC ID = param_list { stmt_list } .)


state 297

    (78) sim_stmt -> SIMULATION { simprop simprop simprop simprop simprop } .

    $end            reduce using rule 78 (sim_stmt -> SIMULATION { simprop simprop simprop simprop simprop } .)


state 298

    (151) atom -> { keyarg_list } .

    ^               reduce using rule 151 (atom -> { keyarg_list } .)
    @               reduce using rule 151 (atom -> { keyarg_list } .)
    [               reduce using rule 151 (atom -> { keyarg_list } .)
    *               reduce using rule 151 (atom -> { keyarg_list } .)
    /               reduce using rule 151 (atom -> { keyarg_list } .)
    %               reduce using rule 151 (atom -> { keyarg_list } .)
    INTDIV          reduce using rule 151 (atom -> { keyarg_list } .)
    EQ              reduce using rule 151 (atom -> { keyarg_list } .)
    NEQ             reduce using rule 151 (atom -> { keyarg_list } .)
    GE              reduce using rule 151 (atom -> { keyarg_list } .)
    LE              reduce using rule 151 (atom -> { keyarg_list } .)
    >               reduce using rule 151 (atom -> { keyarg_list } .)
    <               reduce using rule 151 (atom -> { keyarg_list } .)
    +               reduce using rule 151 (atom -> { keyarg_list } .)
    -               reduce using rule 151 (atom -> { keyarg_list } .)
    AND             reduce using rule 151 (atom -> { keyarg_list } .)
    OR              reduce using rule 151 (atom -> { keyarg_list } .)
    ;               reduce using rule 151 (atom -> { keyarg_list } .)
    =               reduce using rule 151 (atom -> { keyarg_list } .)
    {               reduce using rule 151 (atom -> { keyarg_list } .)
    ,               reduce using rule 151 (atom -> { keyarg_list } .)
    ]               reduce using rule 151 (atom -> { keyarg_list } .)
    )               reduce using rule 151 (atom -> { keyarg_list } .)
    }               reduce using rule 151 (atom -> { keyarg_list } .)


state 299

    (164) keyarg_list -> keyarg , . keyarg_list
    (163) keyarg_list -> . keyarg
    (164) keyarg_list -> . keyarg , keyarg_list
    (165) keyarg_list -> . epsilon
    (166) keyarg -> . disjunction = disjunction
    (2) epsilon -> .
    (115) disjunction -> . conjunction OR conjunction
    (116) disjunction -> . conjunction
    (117) conjunction -> . negation AND negation
    (118) conjunction -> . negation
    (119) negation -> . NOT comparison
    (120) negation -> . comparison
    (121) comparison -> . expr EQ expr
    (122) comparison -> . expr NEQ expr
    (123) comparison -> . expr GE expr
    (124) comparison -> . expr LE expr
    (125) comparison -> . expr > expr
    (126) comparison -> . expr < expr
    (127) comparison -> . expr
    (128) expr -> . expr + term
    (129) expr -> . expr - term
    (130) expr -> . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    }               reduce using rule 2 (epsilon -> .)
    NOT             shift and go to state 228
    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    keyarg                         shift and go to state 245
    keyarg_list                    shift and go to state 333
    epsilon                        shift and go to state 246
    disjunction                    shift and go to state 247
    conjunction                    shift and go to state 214
    negation                       shift and go to state 221
    comparison                     shift and go to state 229
    expr                           shift and go to state 227
    term                           shift and go to state 230
    factor                         shift and go to state 232
    power                          shift and go to state 233
    atom                           shift and go to state 248
    naming                         shift and go to state 249
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 300

    (166) keyarg -> disjunction = . disjunction
    (115) disjunction -> . conjunction OR conjunction
    (116) disjunction -> . conjunction
    (117) conjunction -> . negation AND negation
    (118) conjunction -> . negation
    (119) negation -> . NOT comparison
    (120) negation -> . comparison
    (121) comparison -> . expr EQ expr
    (122) comparison -> . expr NEQ expr
    (123) comparison -> . expr GE expr
    (124) comparison -> . expr LE expr
    (125) comparison -> . expr > expr
    (126) comparison -> . expr < expr
    (127) comparison -> . expr
    (128) expr -> . expr + term
    (129) expr -> . expr - term
    (130) expr -> . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    NOT             shift and go to state 228
    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    disjunction                    shift and go to state 334
    conjunction                    shift and go to state 214
    negation                       shift and go to state 221
    comparison                     shift and go to state 229
    expr                           shift and go to state 227
    term                           shift and go to state 230
    factor                         shift and go to state 232
    power                          shift and go to state 233
    atom                           shift and go to state 248
    naming                         shift and go to state 249
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 301

    (141) naming -> naming [ . disjunction ]
    (115) disjunction -> . conjunction OR conjunction
    (116) disjunction -> . conjunction
    (117) conjunction -> . negation AND negation
    (118) conjunction -> . negation
    (119) negation -> . NOT comparison
    (120) negation -> . comparison
    (121) comparison -> . expr EQ expr
    (122) comparison -> . expr NEQ expr
    (123) comparison -> . expr GE expr
    (124) comparison -> . expr LE expr
    (125) comparison -> . expr > expr
    (126) comparison -> . expr < expr
    (127) comparison -> . expr
    (128) expr -> . expr + term
    (129) expr -> . expr - term
    (130) expr -> . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    NOT             shift and go to state 228
    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    naming                         shift and go to state 249
    disjunction                    shift and go to state 335
    conjunction                    shift and go to state 214
    negation                       shift and go to state 221
    comparison                     shift and go to state 229
    expr                           shift and go to state 227
    term                           shift and go to state 230
    factor                         shift and go to state 232
    power                          shift and go to state 233
    atom                           shift and go to state 248
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 302

    (100) stmt -> RETURN disjunction ; .

    CONTINUE        reduce using rule 100 (stmt -> RETURN disjunction ; .)
    BREAK           reduce using rule 100 (stmt -> RETURN disjunction ; .)
    RETURN          reduce using rule 100 (stmt -> RETURN disjunction ; .)
    IF              reduce using rule 100 (stmt -> RETURN disjunction ; .)
    LOOP            reduce using rule 100 (stmt -> RETURN disjunction ; .)
    KEYS            reduce using rule 100 (stmt -> RETURN disjunction ; .)
    ID              reduce using rule 100 (stmt -> RETURN disjunction ; .)
    ORGANISM        reduce using rule 100 (stmt -> RETURN disjunction ; .)
    SIMULATION      reduce using rule 100 (stmt -> RETURN disjunction ; .)
    WORLD           reduce using rule 100 (stmt -> RETURN disjunction ; .)
    NUMBER          reduce using rule 100 (stmt -> RETURN disjunction ; .)
    STRING          reduce using rule 100 (stmt -> RETURN disjunction ; .)
    (               reduce using rule 100 (stmt -> RETURN disjunction ; .)
    [               reduce using rule 100 (stmt -> RETURN disjunction ; .)
    {               reduce using rule 100 (stmt -> RETURN disjunction ; .)
    NOT             reduce using rule 100 (stmt -> RETURN disjunction ; .)
    TRUE            reduce using rule 100 (stmt -> RETURN disjunction ; .)
    FALSE           reduce using rule 100 (stmt -> RETURN disjunction ; .)
    -               reduce using rule 100 (stmt -> RETURN disjunction ; .)
    }               reduce using rule 100 (stmt -> RETURN disjunction ; .)


state 303

    (104) if_stmt -> IF disjunction { . stmt_list } else_stmt
    (91) stmt_list -> . stmt stmt_list
    (92) stmt_list -> . epsilon
    (93) stmt -> . if_stmt
    (94) stmt -> . var_stmt ;
    (95) stmt -> . index_stmt ;
    (96) stmt -> . disjunction ;
    (97) stmt -> . loop_stmt
    (98) stmt -> . CONTINUE ;
    (99) stmt -> . BREAK ;
    (100) stmt -> . RETURN disjunction ;
    (101) stmt -> . RETURN ;
    (2) epsilon -> .
    (104) if_stmt -> . IF disjunction { stmt_list } else_stmt
    (102) var_stmt -> . accessing = disjunction
    (103) index_stmt -> . naming [ disjunction ] = disjunction
    (115) disjunction -> . conjunction OR conjunction
    (116) disjunction -> . conjunction
    (108) loop_stmt -> . LOOP loop_init , loop_condition , loop_set { stmt_list }
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (117) conjunction -> . negation AND negation
    (118) conjunction -> . negation
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (119) negation -> . NOT comparison
    (120) negation -> . comparison
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (121) comparison -> . expr EQ expr
    (122) comparison -> . expr NEQ expr
    (123) comparison -> . expr GE expr
    (124) comparison -> . expr LE expr
    (125) comparison -> . expr > expr
    (126) comparison -> . expr < expr
    (127) comparison -> . expr
    (128) expr -> . expr + term
    (129) expr -> . expr - term
    (130) expr -> . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming

    CONTINUE        shift and go to state 207
    BREAK           shift and go to state 208
    RETURN          shift and go to state 209
    }               reduce using rule 2 (epsilon -> .)
    IF              shift and go to state 210
    LOOP            shift and go to state 215
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    NOT             shift and go to state 228
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    -               shift and go to state 231

    disjunction                    shift and go to state 205
    stmt_list                      shift and go to state 336
    stmt                           shift and go to state 200
    epsilon                        shift and go to state 201
    if_stmt                        shift and go to state 202
    var_stmt                       shift and go to state 203
    index_stmt                     shift and go to state 204
    loop_stmt                      shift and go to state 206
    accessing                      shift and go to state 211
    naming                         shift and go to state 212
    conjunction                    shift and go to state 214
    word                           shift and go to state 216
    atom                           shift and go to state 220
    negation                       shift and go to state 221
    bool                           shift and go to state 226
    expr                           shift and go to state 227
    comparison                     shift and go to state 229
    term                           shift and go to state 230
    factor                         shift and go to state 232
    power                          shift and go to state 233

state 304

    (102) var_stmt -> accessing = disjunction .

    ;               reduce using rule 102 (var_stmt -> accessing = disjunction .)
    ,               reduce using rule 102 (var_stmt -> accessing = disjunction .)
    {               reduce using rule 102 (var_stmt -> accessing = disjunction .)


state 305

    (103) index_stmt -> naming [ disjunction . ] = disjunction
    (141) naming -> naming [ disjunction . ]

    ]               shift and go to state 337


state 306

    (150) atom -> [ arg_list ] .

    ^               reduce using rule 150 (atom -> [ arg_list ] .)
    @               reduce using rule 150 (atom -> [ arg_list ] .)
    [               reduce using rule 150 (atom -> [ arg_list ] .)
    *               reduce using rule 150 (atom -> [ arg_list ] .)
    /               reduce using rule 150 (atom -> [ arg_list ] .)
    %               reduce using rule 150 (atom -> [ arg_list ] .)
    INTDIV          reduce using rule 150 (atom -> [ arg_list ] .)
    EQ              reduce using rule 150 (atom -> [ arg_list ] .)
    NEQ             reduce using rule 150 (atom -> [ arg_list ] .)
    GE              reduce using rule 150 (atom -> [ arg_list ] .)
    LE              reduce using rule 150 (atom -> [ arg_list ] .)
    >               reduce using rule 150 (atom -> [ arg_list ] .)
    <               reduce using rule 150 (atom -> [ arg_list ] .)
    +               reduce using rule 150 (atom -> [ arg_list ] .)
    -               reduce using rule 150 (atom -> [ arg_list ] .)
    AND             reduce using rule 150 (atom -> [ arg_list ] .)
    OR              reduce using rule 150 (atom -> [ arg_list ] .)
    ;               reduce using rule 150 (atom -> [ arg_list ] .)
    =               reduce using rule 150 (atom -> [ arg_list ] .)
    {               reduce using rule 150 (atom -> [ arg_list ] .)
    ,               reduce using rule 150 (atom -> [ arg_list ] .)
    ]               reduce using rule 150 (atom -> [ arg_list ] .)
    )               reduce using rule 150 (atom -> [ arg_list ] .)
    }               reduce using rule 150 (atom -> [ arg_list ] .)


state 307

    (161) arg_list -> disjunction , . arg_list
    (160) arg_list -> . disjunction
    (161) arg_list -> . disjunction , arg_list
    (162) arg_list -> . epsilon
    (115) disjunction -> . conjunction OR conjunction
    (116) disjunction -> . conjunction
    (2) epsilon -> .
    (117) conjunction -> . negation AND negation
    (118) conjunction -> . negation
    (119) negation -> . NOT comparison
    (120) negation -> . comparison
    (121) comparison -> . expr EQ expr
    (122) comparison -> . expr NEQ expr
    (123) comparison -> . expr GE expr
    (124) comparison -> . expr LE expr
    (125) comparison -> . expr > expr
    (126) comparison -> . expr < expr
    (127) comparison -> . expr
    (128) expr -> . expr + term
    (129) expr -> . expr - term
    (130) expr -> . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    ]               reduce using rule 2 (epsilon -> .)
    )               reduce using rule 2 (epsilon -> .)
    NOT             shift and go to state 228
    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    disjunction                    shift and go to state 264
    arg_list                       shift and go to state 338
    epsilon                        shift and go to state 265
    conjunction                    shift and go to state 214
    negation                       shift and go to state 221
    comparison                     shift and go to state 229
    expr                           shift and go to state 227
    term                           shift and go to state 230
    factor                         shift and go to state 232
    power                          shift and go to state 233
    atom                           shift and go to state 248
    naming                         shift and go to state 249
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 308

    (115) disjunction -> conjunction OR conjunction .

    ;               reduce using rule 115 (disjunction -> conjunction OR conjunction .)
    =               reduce using rule 115 (disjunction -> conjunction OR conjunction .)
    {               reduce using rule 115 (disjunction -> conjunction OR conjunction .)
    ,               reduce using rule 115 (disjunction -> conjunction OR conjunction .)
    ]               reduce using rule 115 (disjunction -> conjunction OR conjunction .)
    )               reduce using rule 115 (disjunction -> conjunction OR conjunction .)
    }               reduce using rule 115 (disjunction -> conjunction OR conjunction .)


state 309

    (108) loop_stmt -> LOOP loop_init , . loop_condition , loop_set { stmt_list }
    (113) loop_condition -> . disjunction
    (114) loop_condition -> . epsilon
    (115) disjunction -> . conjunction OR conjunction
    (116) disjunction -> . conjunction
    (2) epsilon -> .
    (117) conjunction -> . negation AND negation
    (118) conjunction -> . negation
    (119) negation -> . NOT comparison
    (120) negation -> . comparison
    (121) comparison -> . expr EQ expr
    (122) comparison -> . expr NEQ expr
    (123) comparison -> . expr GE expr
    (124) comparison -> . expr LE expr
    (125) comparison -> . expr > expr
    (126) comparison -> . expr < expr
    (127) comparison -> . expr
    (128) expr -> . expr + term
    (129) expr -> . expr - term
    (130) expr -> . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    ,               reduce using rule 2 (epsilon -> .)
    NOT             shift and go to state 228
    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    loop_condition                 shift and go to state 339
    disjunction                    shift and go to state 340
    epsilon                        shift and go to state 341
    conjunction                    shift and go to state 214
    negation                       shift and go to state 221
    comparison                     shift and go to state 229
    expr                           shift and go to state 227
    term                           shift and go to state 230
    factor                         shift and go to state 232
    power                          shift and go to state 233
    atom                           shift and go to state 248
    naming                         shift and go to state 249
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 310

    (153) accessing -> word . accessing .

    =               reduce using rule 153 (accessing -> word . accessing .)
    [               reduce using rule 153 (accessing -> word . accessing .)
    *               reduce using rule 153 (accessing -> word . accessing .)
    /               reduce using rule 153 (accessing -> word . accessing .)
    %               reduce using rule 153 (accessing -> word . accessing .)
    INTDIV          reduce using rule 153 (accessing -> word . accessing .)
    EQ              reduce using rule 153 (accessing -> word . accessing .)
    NEQ             reduce using rule 153 (accessing -> word . accessing .)
    GE              reduce using rule 153 (accessing -> word . accessing .)
    LE              reduce using rule 153 (accessing -> word . accessing .)
    >               reduce using rule 153 (accessing -> word . accessing .)
    <               reduce using rule 153 (accessing -> word . accessing .)
    +               reduce using rule 153 (accessing -> word . accessing .)
    -               reduce using rule 153 (accessing -> word . accessing .)
    AND             reduce using rule 153 (accessing -> word . accessing .)
    OR              reduce using rule 153 (accessing -> word . accessing .)
    ;               reduce using rule 153 (accessing -> word . accessing .)
    {               reduce using rule 153 (accessing -> word . accessing .)
    ,               reduce using rule 153 (accessing -> word . accessing .)
    ]               reduce using rule 153 (accessing -> word . accessing .)
    )               reduce using rule 153 (accessing -> word . accessing .)
    }               reduce using rule 153 (accessing -> word . accessing .)


state 311

    (143) naming -> KEYS ( naming . )
    (141) naming -> naming . [ disjunction ]

    )               shift and go to state 342
    [               shift and go to state 301


state 312

    (145) naming -> atom .

    )               reduce using rule 145 (naming -> atom .)
    [               reduce using rule 145 (naming -> atom .)


state 313

    (149) atom -> ( expr ) .

    ^               reduce using rule 149 (atom -> ( expr ) .)
    @               reduce using rule 149 (atom -> ( expr ) .)
    [               reduce using rule 149 (atom -> ( expr ) .)
    *               reduce using rule 149 (atom -> ( expr ) .)
    /               reduce using rule 149 (atom -> ( expr ) .)
    %               reduce using rule 149 (atom -> ( expr ) .)
    INTDIV          reduce using rule 149 (atom -> ( expr ) .)
    EQ              reduce using rule 149 (atom -> ( expr ) .)
    NEQ             reduce using rule 149 (atom -> ( expr ) .)
    GE              reduce using rule 149 (atom -> ( expr ) .)
    LE              reduce using rule 149 (atom -> ( expr ) .)
    >               reduce using rule 149 (atom -> ( expr ) .)
    <               reduce using rule 149 (atom -> ( expr ) .)
    +               reduce using rule 149 (atom -> ( expr ) .)
    -               reduce using rule 149 (atom -> ( expr ) .)
    AND             reduce using rule 149 (atom -> ( expr ) .)
    OR              reduce using rule 149 (atom -> ( expr ) .)
    ;               reduce using rule 149 (atom -> ( expr ) .)
    =               reduce using rule 149 (atom -> ( expr ) .)
    {               reduce using rule 149 (atom -> ( expr ) .)
    ,               reduce using rule 149 (atom -> ( expr ) .)
    ]               reduce using rule 149 (atom -> ( expr ) .)
    )               reduce using rule 149 (atom -> ( expr ) .)
    }               reduce using rule 149 (atom -> ( expr ) .)


state 314

    (144) naming -> ID ( arg_list . )

    )               shift and go to state 343


state 315

    (138) power -> atom ^ factor .

    *               reduce using rule 138 (power -> atom ^ factor .)
    /               reduce using rule 138 (power -> atom ^ factor .)
    %               reduce using rule 138 (power -> atom ^ factor .)
    INTDIV          reduce using rule 138 (power -> atom ^ factor .)
    EQ              reduce using rule 138 (power -> atom ^ factor .)
    NEQ             reduce using rule 138 (power -> atom ^ factor .)
    GE              reduce using rule 138 (power -> atom ^ factor .)
    LE              reduce using rule 138 (power -> atom ^ factor .)
    >               reduce using rule 138 (power -> atom ^ factor .)
    <               reduce using rule 138 (power -> atom ^ factor .)
    +               reduce using rule 138 (power -> atom ^ factor .)
    -               reduce using rule 138 (power -> atom ^ factor .)
    AND             reduce using rule 138 (power -> atom ^ factor .)
    OR              reduce using rule 138 (power -> atom ^ factor .)
    ;               reduce using rule 138 (power -> atom ^ factor .)
    =               reduce using rule 138 (power -> atom ^ factor .)
    {               reduce using rule 138 (power -> atom ^ factor .)
    ,               reduce using rule 138 (power -> atom ^ factor .)
    ]               reduce using rule 138 (power -> atom ^ factor .)
    )               reduce using rule 138 (power -> atom ^ factor .)
    }               reduce using rule 138 (power -> atom ^ factor .)


state 316

    (139) power -> atom @ factor .

    *               reduce using rule 139 (power -> atom @ factor .)
    /               reduce using rule 139 (power -> atom @ factor .)
    %               reduce using rule 139 (power -> atom @ factor .)
    INTDIV          reduce using rule 139 (power -> atom @ factor .)
    EQ              reduce using rule 139 (power -> atom @ factor .)
    NEQ             reduce using rule 139 (power -> atom @ factor .)
    GE              reduce using rule 139 (power -> atom @ factor .)
    LE              reduce using rule 139 (power -> atom @ factor .)
    >               reduce using rule 139 (power -> atom @ factor .)
    <               reduce using rule 139 (power -> atom @ factor .)
    +               reduce using rule 139 (power -> atom @ factor .)
    -               reduce using rule 139 (power -> atom @ factor .)
    AND             reduce using rule 139 (power -> atom @ factor .)
    OR              reduce using rule 139 (power -> atom @ factor .)
    ;               reduce using rule 139 (power -> atom @ factor .)
    =               reduce using rule 139 (power -> atom @ factor .)
    {               reduce using rule 139 (power -> atom @ factor .)
    ,               reduce using rule 139 (power -> atom @ factor .)
    ]               reduce using rule 139 (power -> atom @ factor .)
    )               reduce using rule 139 (power -> atom @ factor .)
    }               reduce using rule 139 (power -> atom @ factor .)


state 317

    (117) conjunction -> negation AND negation .

    OR              reduce using rule 117 (conjunction -> negation AND negation .)
    ;               reduce using rule 117 (conjunction -> negation AND negation .)
    =               reduce using rule 117 (conjunction -> negation AND negation .)
    {               reduce using rule 117 (conjunction -> negation AND negation .)
    ,               reduce using rule 117 (conjunction -> negation AND negation .)
    ]               reduce using rule 117 (conjunction -> negation AND negation .)
    )               reduce using rule 117 (conjunction -> negation AND negation .)
    }               reduce using rule 117 (conjunction -> negation AND negation .)


state 318

    (121) comparison -> expr EQ expr .
    (128) expr -> expr . + term
    (129) expr -> expr . - term

    AND             reduce using rule 121 (comparison -> expr EQ expr .)
    OR              reduce using rule 121 (comparison -> expr EQ expr .)
    ;               reduce using rule 121 (comparison -> expr EQ expr .)
    =               reduce using rule 121 (comparison -> expr EQ expr .)
    {               reduce using rule 121 (comparison -> expr EQ expr .)
    ,               reduce using rule 121 (comparison -> expr EQ expr .)
    ]               reduce using rule 121 (comparison -> expr EQ expr .)
    )               reduce using rule 121 (comparison -> expr EQ expr .)
    }               reduce using rule 121 (comparison -> expr EQ expr .)
    +               shift and go to state 285
    -               shift and go to state 286


state 319

    (122) comparison -> expr NEQ expr .
    (128) expr -> expr . + term
    (129) expr -> expr . - term

    AND             reduce using rule 122 (comparison -> expr NEQ expr .)
    OR              reduce using rule 122 (comparison -> expr NEQ expr .)
    ;               reduce using rule 122 (comparison -> expr NEQ expr .)
    =               reduce using rule 122 (comparison -> expr NEQ expr .)
    {               reduce using rule 122 (comparison -> expr NEQ expr .)
    ,               reduce using rule 122 (comparison -> expr NEQ expr .)
    ]               reduce using rule 122 (comparison -> expr NEQ expr .)
    )               reduce using rule 122 (comparison -> expr NEQ expr .)
    }               reduce using rule 122 (comparison -> expr NEQ expr .)
    +               shift and go to state 285
    -               shift and go to state 286


state 320

    (123) comparison -> expr GE expr .
    (128) expr -> expr . + term
    (129) expr -> expr . - term

    AND             reduce using rule 123 (comparison -> expr GE expr .)
    OR              reduce using rule 123 (comparison -> expr GE expr .)
    ;               reduce using rule 123 (comparison -> expr GE expr .)
    =               reduce using rule 123 (comparison -> expr GE expr .)
    {               reduce using rule 123 (comparison -> expr GE expr .)
    ,               reduce using rule 123 (comparison -> expr GE expr .)
    ]               reduce using rule 123 (comparison -> expr GE expr .)
    )               reduce using rule 123 (comparison -> expr GE expr .)
    }               reduce using rule 123 (comparison -> expr GE expr .)
    +               shift and go to state 285
    -               shift and go to state 286


state 321

    (124) comparison -> expr LE expr .
    (128) expr -> expr . + term
    (129) expr -> expr . - term

    AND             reduce using rule 124 (comparison -> expr LE expr .)
    OR              reduce using rule 124 (comparison -> expr LE expr .)
    ;               reduce using rule 124 (comparison -> expr LE expr .)
    =               reduce using rule 124 (comparison -> expr LE expr .)
    {               reduce using rule 124 (comparison -> expr LE expr .)
    ,               reduce using rule 124 (comparison -> expr LE expr .)
    ]               reduce using rule 124 (comparison -> expr LE expr .)
    )               reduce using rule 124 (comparison -> expr LE expr .)
    }               reduce using rule 124 (comparison -> expr LE expr .)
    +               shift and go to state 285
    -               shift and go to state 286


state 322

    (125) comparison -> expr > expr .
    (128) expr -> expr . + term
    (129) expr -> expr . - term

    AND             reduce using rule 125 (comparison -> expr > expr .)
    OR              reduce using rule 125 (comparison -> expr > expr .)
    ;               reduce using rule 125 (comparison -> expr > expr .)
    =               reduce using rule 125 (comparison -> expr > expr .)
    {               reduce using rule 125 (comparison -> expr > expr .)
    ,               reduce using rule 125 (comparison -> expr > expr .)
    ]               reduce using rule 125 (comparison -> expr > expr .)
    )               reduce using rule 125 (comparison -> expr > expr .)
    }               reduce using rule 125 (comparison -> expr > expr .)
    +               shift and go to state 285
    -               shift and go to state 286


state 323

    (126) comparison -> expr < expr .
    (128) expr -> expr . + term
    (129) expr -> expr . - term

    AND             reduce using rule 126 (comparison -> expr < expr .)
    OR              reduce using rule 126 (comparison -> expr < expr .)
    ;               reduce using rule 126 (comparison -> expr < expr .)
    =               reduce using rule 126 (comparison -> expr < expr .)
    {               reduce using rule 126 (comparison -> expr < expr .)
    ,               reduce using rule 126 (comparison -> expr < expr .)
    ]               reduce using rule 126 (comparison -> expr < expr .)
    )               reduce using rule 126 (comparison -> expr < expr .)
    }               reduce using rule 126 (comparison -> expr < expr .)
    +               shift and go to state 285
    -               shift and go to state 286


state 324

    (128) expr -> expr + term .
    (131) term -> term . * factor
    (132) term -> term . / factor
    (133) term -> term . % factor
    (134) term -> term . INTDIV factor

    EQ              reduce using rule 128 (expr -> expr + term .)
    NEQ             reduce using rule 128 (expr -> expr + term .)
    GE              reduce using rule 128 (expr -> expr + term .)
    LE              reduce using rule 128 (expr -> expr + term .)
    >               reduce using rule 128 (expr -> expr + term .)
    <               reduce using rule 128 (expr -> expr + term .)
    +               reduce using rule 128 (expr -> expr + term .)
    -               reduce using rule 128 (expr -> expr + term .)
    AND             reduce using rule 128 (expr -> expr + term .)
    OR              reduce using rule 128 (expr -> expr + term .)
    ;               reduce using rule 128 (expr -> expr + term .)
    =               reduce using rule 128 (expr -> expr + term .)
    {               reduce using rule 128 (expr -> expr + term .)
    ,               reduce using rule 128 (expr -> expr + term .)
    ]               reduce using rule 128 (expr -> expr + term .)
    )               reduce using rule 128 (expr -> expr + term .)
    }               reduce using rule 128 (expr -> expr + term .)
    *               shift and go to state 288
    /               shift and go to state 289
    %               shift and go to state 290
    INTDIV          shift and go to state 291


state 325

    (129) expr -> expr - term .
    (131) term -> term . * factor
    (132) term -> term . / factor
    (133) term -> term . % factor
    (134) term -> term . INTDIV factor

    EQ              reduce using rule 129 (expr -> expr - term .)
    NEQ             reduce using rule 129 (expr -> expr - term .)
    GE              reduce using rule 129 (expr -> expr - term .)
    LE              reduce using rule 129 (expr -> expr - term .)
    >               reduce using rule 129 (expr -> expr - term .)
    <               reduce using rule 129 (expr -> expr - term .)
    +               reduce using rule 129 (expr -> expr - term .)
    -               reduce using rule 129 (expr -> expr - term .)
    AND             reduce using rule 129 (expr -> expr - term .)
    OR              reduce using rule 129 (expr -> expr - term .)
    ;               reduce using rule 129 (expr -> expr - term .)
    =               reduce using rule 129 (expr -> expr - term .)
    {               reduce using rule 129 (expr -> expr - term .)
    ,               reduce using rule 129 (expr -> expr - term .)
    ]               reduce using rule 129 (expr -> expr - term .)
    )               reduce using rule 129 (expr -> expr - term .)
    }               reduce using rule 129 (expr -> expr - term .)
    *               shift and go to state 288
    /               shift and go to state 289
    %               shift and go to state 290
    INTDIV          shift and go to state 291


state 326

    (131) term -> term * factor .

    *               reduce using rule 131 (term -> term * factor .)
    /               reduce using rule 131 (term -> term * factor .)
    %               reduce using rule 131 (term -> term * factor .)
    INTDIV          reduce using rule 131 (term -> term * factor .)
    EQ              reduce using rule 131 (term -> term * factor .)
    NEQ             reduce using rule 131 (term -> term * factor .)
    GE              reduce using rule 131 (term -> term * factor .)
    LE              reduce using rule 131 (term -> term * factor .)
    >               reduce using rule 131 (term -> term * factor .)
    <               reduce using rule 131 (term -> term * factor .)
    +               reduce using rule 131 (term -> term * factor .)
    -               reduce using rule 131 (term -> term * factor .)
    AND             reduce using rule 131 (term -> term * factor .)
    OR              reduce using rule 131 (term -> term * factor .)
    ;               reduce using rule 131 (term -> term * factor .)
    =               reduce using rule 131 (term -> term * factor .)
    {               reduce using rule 131 (term -> term * factor .)
    ,               reduce using rule 131 (term -> term * factor .)
    ]               reduce using rule 131 (term -> term * factor .)
    )               reduce using rule 131 (term -> term * factor .)
    }               reduce using rule 131 (term -> term * factor .)


state 327

    (132) term -> term / factor .

    *               reduce using rule 132 (term -> term / factor .)
    /               reduce using rule 132 (term -> term / factor .)
    %               reduce using rule 132 (term -> term / factor .)
    INTDIV          reduce using rule 132 (term -> term / factor .)
    EQ              reduce using rule 132 (term -> term / factor .)
    NEQ             reduce using rule 132 (term -> term / factor .)
    GE              reduce using rule 132 (term -> term / factor .)
    LE              reduce using rule 132 (term -> term / factor .)
    >               reduce using rule 132 (term -> term / factor .)
    <               reduce using rule 132 (term -> term / factor .)
    +               reduce using rule 132 (term -> term / factor .)
    -               reduce using rule 132 (term -> term / factor .)
    AND             reduce using rule 132 (term -> term / factor .)
    OR              reduce using rule 132 (term -> term / factor .)
    ;               reduce using rule 132 (term -> term / factor .)
    =               reduce using rule 132 (term -> term / factor .)
    {               reduce using rule 132 (term -> term / factor .)
    ,               reduce using rule 132 (term -> term / factor .)
    ]               reduce using rule 132 (term -> term / factor .)
    )               reduce using rule 132 (term -> term / factor .)
    }               reduce using rule 132 (term -> term / factor .)


state 328

    (133) term -> term % factor .

    *               reduce using rule 133 (term -> term % factor .)
    /               reduce using rule 133 (term -> term % factor .)
    %               reduce using rule 133 (term -> term % factor .)
    INTDIV          reduce using rule 133 (term -> term % factor .)
    EQ              reduce using rule 133 (term -> term % factor .)
    NEQ             reduce using rule 133 (term -> term % factor .)
    GE              reduce using rule 133 (term -> term % factor .)
    LE              reduce using rule 133 (term -> term % factor .)
    >               reduce using rule 133 (term -> term % factor .)
    <               reduce using rule 133 (term -> term % factor .)
    +               reduce using rule 133 (term -> term % factor .)
    -               reduce using rule 133 (term -> term % factor .)
    AND             reduce using rule 133 (term -> term % factor .)
    OR              reduce using rule 133 (term -> term % factor .)
    ;               reduce using rule 133 (term -> term % factor .)
    =               reduce using rule 133 (term -> term % factor .)
    {               reduce using rule 133 (term -> term % factor .)
    ,               reduce using rule 133 (term -> term % factor .)
    ]               reduce using rule 133 (term -> term % factor .)
    )               reduce using rule 133 (term -> term % factor .)
    }               reduce using rule 133 (term -> term % factor .)


state 329

    (134) term -> term INTDIV factor .

    *               reduce using rule 134 (term -> term INTDIV factor .)
    /               reduce using rule 134 (term -> term INTDIV factor .)
    %               reduce using rule 134 (term -> term INTDIV factor .)
    INTDIV          reduce using rule 134 (term -> term INTDIV factor .)
    EQ              reduce using rule 134 (term -> term INTDIV factor .)
    NEQ             reduce using rule 134 (term -> term INTDIV factor .)
    GE              reduce using rule 134 (term -> term INTDIV factor .)
    LE              reduce using rule 134 (term -> term INTDIV factor .)
    >               reduce using rule 134 (term -> term INTDIV factor .)
    <               reduce using rule 134 (term -> term INTDIV factor .)
    +               reduce using rule 134 (term -> term INTDIV factor .)
    -               reduce using rule 134 (term -> term INTDIV factor .)
    AND             reduce using rule 134 (term -> term INTDIV factor .)
    OR              reduce using rule 134 (term -> term INTDIV factor .)
    ;               reduce using rule 134 (term -> term INTDIV factor .)
    =               reduce using rule 134 (term -> term INTDIV factor .)
    {               reduce using rule 134 (term -> term INTDIV factor .)
    ,               reduce using rule 134 (term -> term INTDIV factor .)
    ]               reduce using rule 134 (term -> term INTDIV factor .)
    )               reduce using rule 134 (term -> term INTDIV factor .)
    }               reduce using rule 134 (term -> term INTDIV factor .)


state 330

    (76) terrainposn_list -> NUMBER . terrainposn_list
    (76) terrainposn_list -> . NUMBER terrainposn_list
    (77) terrainposn_list -> . epsilon
    (2) epsilon -> .

    NUMBER          shift and go to state 330
    }               reduce using rule 2 (epsilon -> .)

    terrainposn_list               shift and go to state 344
    epsilon                        shift and go to state 332

state 331

    (75) terrainprop -> ID AT { NUMBER terrainposn_list . }

    }               shift and go to state 345


state 332

    (77) terrainposn_list -> epsilon .

    }               reduce using rule 77 (terrainposn_list -> epsilon .)


state 333

    (164) keyarg_list -> keyarg , keyarg_list .

    }               reduce using rule 164 (keyarg_list -> keyarg , keyarg_list .)


state 334

    (166) keyarg -> disjunction = disjunction .

    ,               reduce using rule 166 (keyarg -> disjunction = disjunction .)
    }               reduce using rule 166 (keyarg -> disjunction = disjunction .)


state 335

    (141) naming -> naming [ disjunction . ]

    ]               shift and go to state 346


state 336

    (104) if_stmt -> IF disjunction { stmt_list . } else_stmt

    }               shift and go to state 347


state 337

    (103) index_stmt -> naming [ disjunction ] . = disjunction
    (141) naming -> naming [ disjunction ] .

    =               shift and go to state 348
    [               reduce using rule 141 (naming -> naming [ disjunction ] .)
    *               reduce using rule 141 (naming -> naming [ disjunction ] .)
    /               reduce using rule 141 (naming -> naming [ disjunction ] .)
    %               reduce using rule 141 (naming -> naming [ disjunction ] .)
    INTDIV          reduce using rule 141 (naming -> naming [ disjunction ] .)
    EQ              reduce using rule 141 (naming -> naming [ disjunction ] .)
    NEQ             reduce using rule 141 (naming -> naming [ disjunction ] .)
    GE              reduce using rule 141 (naming -> naming [ disjunction ] .)
    LE              reduce using rule 141 (naming -> naming [ disjunction ] .)
    >               reduce using rule 141 (naming -> naming [ disjunction ] .)
    <               reduce using rule 141 (naming -> naming [ disjunction ] .)
    +               reduce using rule 141 (naming -> naming [ disjunction ] .)
    -               reduce using rule 141 (naming -> naming [ disjunction ] .)
    AND             reduce using rule 141 (naming -> naming [ disjunction ] .)
    OR              reduce using rule 141 (naming -> naming [ disjunction ] .)
    ;               reduce using rule 141 (naming -> naming [ disjunction ] .)


state 338

    (161) arg_list -> disjunction , arg_list .

    ]               reduce using rule 161 (arg_list -> disjunction , arg_list .)
    )               reduce using rule 161 (arg_list -> disjunction , arg_list .)


state 339

    (108) loop_stmt -> LOOP loop_init , loop_condition . , loop_set { stmt_list }

    ,               shift and go to state 349


state 340

    (113) loop_condition -> disjunction .

    ,               reduce using rule 113 (loop_condition -> disjunction .)


state 341

    (114) loop_condition -> epsilon .

    ,               reduce using rule 114 (loop_condition -> epsilon .)


state 342

    (143) naming -> KEYS ( naming ) .

    [               reduce using rule 143 (naming -> KEYS ( naming ) .)
    *               reduce using rule 143 (naming -> KEYS ( naming ) .)
    /               reduce using rule 143 (naming -> KEYS ( naming ) .)
    %               reduce using rule 143 (naming -> KEYS ( naming ) .)
    INTDIV          reduce using rule 143 (naming -> KEYS ( naming ) .)
    EQ              reduce using rule 143 (naming -> KEYS ( naming ) .)
    NEQ             reduce using rule 143 (naming -> KEYS ( naming ) .)
    GE              reduce using rule 143 (naming -> KEYS ( naming ) .)
    LE              reduce using rule 143 (naming -> KEYS ( naming ) .)
    >               reduce using rule 143 (naming -> KEYS ( naming ) .)
    <               reduce using rule 143 (naming -> KEYS ( naming ) .)
    +               reduce using rule 143 (naming -> KEYS ( naming ) .)
    -               reduce using rule 143 (naming -> KEYS ( naming ) .)
    AND             reduce using rule 143 (naming -> KEYS ( naming ) .)
    OR              reduce using rule 143 (naming -> KEYS ( naming ) .)
    ;               reduce using rule 143 (naming -> KEYS ( naming ) .)
    =               reduce using rule 143 (naming -> KEYS ( naming ) .)
    {               reduce using rule 143 (naming -> KEYS ( naming ) .)
    ,               reduce using rule 143 (naming -> KEYS ( naming ) .)
    ]               reduce using rule 143 (naming -> KEYS ( naming ) .)
    )               reduce using rule 143 (naming -> KEYS ( naming ) .)
    }               reduce using rule 143 (naming -> KEYS ( naming ) .)


state 343

    (144) naming -> ID ( arg_list ) .

    [               reduce using rule 144 (naming -> ID ( arg_list ) .)
    *               reduce using rule 144 (naming -> ID ( arg_list ) .)
    /               reduce using rule 144 (naming -> ID ( arg_list ) .)
    %               reduce using rule 144 (naming -> ID ( arg_list ) .)
    INTDIV          reduce using rule 144 (naming -> ID ( arg_list ) .)
    EQ              reduce using rule 144 (naming -> ID ( arg_list ) .)
    NEQ             reduce using rule 144 (naming -> ID ( arg_list ) .)
    GE              reduce using rule 144 (naming -> ID ( arg_list ) .)
    LE              reduce using rule 144 (naming -> ID ( arg_list ) .)
    >               reduce using rule 144 (naming -> ID ( arg_list ) .)
    <               reduce using rule 144 (naming -> ID ( arg_list ) .)
    +               reduce using rule 144 (naming -> ID ( arg_list ) .)
    -               reduce using rule 144 (naming -> ID ( arg_list ) .)
    AND             reduce using rule 144 (naming -> ID ( arg_list ) .)
    OR              reduce using rule 144 (naming -> ID ( arg_list ) .)
    ;               reduce using rule 144 (naming -> ID ( arg_list ) .)
    =               reduce using rule 144 (naming -> ID ( arg_list ) .)
    {               reduce using rule 144 (naming -> ID ( arg_list ) .)
    ,               reduce using rule 144 (naming -> ID ( arg_list ) .)
    ]               reduce using rule 144 (naming -> ID ( arg_list ) .)
    )               reduce using rule 144 (naming -> ID ( arg_list ) .)
    }               reduce using rule 144 (naming -> ID ( arg_list ) .)


state 344

    (76) terrainposn_list -> NUMBER terrainposn_list .

    }               reduce using rule 76 (terrainposn_list -> NUMBER terrainposn_list .)


state 345

    (75) terrainprop -> ID AT { NUMBER terrainposn_list } .

    ID              reduce using rule 75 (terrainprop -> ID AT { NUMBER terrainposn_list } .)
    DEFAULT         reduce using rule 75 (terrainprop -> ID AT { NUMBER terrainposn_list } .)
    }               reduce using rule 75 (terrainprop -> ID AT { NUMBER terrainposn_list } .)


state 346

    (141) naming -> naming [ disjunction ] .

    [               reduce using rule 141 (naming -> naming [ disjunction ] .)
    *               reduce using rule 141 (naming -> naming [ disjunction ] .)
    /               reduce using rule 141 (naming -> naming [ disjunction ] .)
    %               reduce using rule 141 (naming -> naming [ disjunction ] .)
    INTDIV          reduce using rule 141 (naming -> naming [ disjunction ] .)
    EQ              reduce using rule 141 (naming -> naming [ disjunction ] .)
    NEQ             reduce using rule 141 (naming -> naming [ disjunction ] .)
    GE              reduce using rule 141 (naming -> naming [ disjunction ] .)
    LE              reduce using rule 141 (naming -> naming [ disjunction ] .)
    >               reduce using rule 141 (naming -> naming [ disjunction ] .)
    <               reduce using rule 141 (naming -> naming [ disjunction ] .)
    +               reduce using rule 141 (naming -> naming [ disjunction ] .)
    -               reduce using rule 141 (naming -> naming [ disjunction ] .)
    AND             reduce using rule 141 (naming -> naming [ disjunction ] .)
    OR              reduce using rule 141 (naming -> naming [ disjunction ] .)
    =               reduce using rule 141 (naming -> naming [ disjunction ] .)
    ;               reduce using rule 141 (naming -> naming [ disjunction ] .)
    {               reduce using rule 141 (naming -> naming [ disjunction ] .)
    ,               reduce using rule 141 (naming -> naming [ disjunction ] .)
    ]               reduce using rule 141 (naming -> naming [ disjunction ] .)
    )               reduce using rule 141 (naming -> naming [ disjunction ] .)
    }               reduce using rule 141 (naming -> naming [ disjunction ] .)


state 347

    (104) if_stmt -> IF disjunction { stmt_list } . else_stmt
    (105) else_stmt -> . ELSE if_stmt
    (106) else_stmt -> . ELSE { stmt_list }
    (107) else_stmt -> . epsilon
    (2) epsilon -> .

    ELSE            shift and go to state 351
    CONTINUE        reduce using rule 2 (epsilon -> .)
    BREAK           reduce using rule 2 (epsilon -> .)
    RETURN          reduce using rule 2 (epsilon -> .)
    IF              reduce using rule 2 (epsilon -> .)
    LOOP            reduce using rule 2 (epsilon -> .)
    KEYS            reduce using rule 2 (epsilon -> .)
    ID              reduce using rule 2 (epsilon -> .)
    ORGANISM        reduce using rule 2 (epsilon -> .)
    SIMULATION      reduce using rule 2 (epsilon -> .)
    WORLD           reduce using rule 2 (epsilon -> .)
    NUMBER          reduce using rule 2 (epsilon -> .)
    STRING          reduce using rule 2 (epsilon -> .)
    (               reduce using rule 2 (epsilon -> .)
    [               reduce using rule 2 (epsilon -> .)
    {               reduce using rule 2 (epsilon -> .)
    NOT             reduce using rule 2 (epsilon -> .)
    TRUE            reduce using rule 2 (epsilon -> .)
    FALSE           reduce using rule 2 (epsilon -> .)
    -               reduce using rule 2 (epsilon -> .)
    }               reduce using rule 2 (epsilon -> .)

    else_stmt                      shift and go to state 350
    epsilon                        shift and go to state 352

state 348

    (103) index_stmt -> naming [ disjunction ] = . disjunction
    (115) disjunction -> . conjunction OR conjunction
    (116) disjunction -> . conjunction
    (117) conjunction -> . negation AND negation
    (118) conjunction -> . negation
    (119) negation -> . NOT comparison
    (120) negation -> . comparison
    (121) comparison -> . expr EQ expr
    (122) comparison -> . expr NEQ expr
    (123) comparison -> . expr GE expr
    (124) comparison -> . expr LE expr
    (125) comparison -> . expr > expr
    (126) comparison -> . expr < expr
    (127) comparison -> . expr
    (128) expr -> . expr + term
    (129) expr -> . expr - term
    (130) expr -> . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    NOT             shift and go to state 228
    -               shift and go to state 231
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    naming                         shift and go to state 249
    disjunction                    shift and go to state 353
    conjunction                    shift and go to state 214
    negation                       shift and go to state 221
    comparison                     shift and go to state 229
    expr                           shift and go to state 227
    term                           shift and go to state 230
    factor                         shift and go to state 232
    power                          shift and go to state 233
    atom                           shift and go to state 248
    bool                           shift and go to state 226
    accessing                      shift and go to state 250
    word                           shift and go to state 216

state 349

    (108) loop_stmt -> LOOP loop_init , loop_condition , . loop_set { stmt_list }
    (111) loop_set -> . var_stmt
    (112) loop_set -> . epsilon
    (102) var_stmt -> . accessing = disjunction
    (2) epsilon -> .
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD

    {               reduce using rule 2 (epsilon -> .)
    ID              shift and go to state 271
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223

    loop_set                       shift and go to state 354
    var_stmt                       shift and go to state 355
    epsilon                        shift and go to state 356
    accessing                      shift and go to state 270
    word                           shift and go to state 216

state 350

    (104) if_stmt -> IF disjunction { stmt_list } else_stmt .

    CONTINUE        reduce using rule 104 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    BREAK           reduce using rule 104 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    RETURN          reduce using rule 104 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    IF              reduce using rule 104 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    LOOP            reduce using rule 104 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    KEYS            reduce using rule 104 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    ID              reduce using rule 104 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    ORGANISM        reduce using rule 104 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    SIMULATION      reduce using rule 104 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    WORLD           reduce using rule 104 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    NUMBER          reduce using rule 104 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    STRING          reduce using rule 104 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    (               reduce using rule 104 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    [               reduce using rule 104 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    {               reduce using rule 104 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    NOT             reduce using rule 104 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    TRUE            reduce using rule 104 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    FALSE           reduce using rule 104 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    -               reduce using rule 104 (if_stmt -> IF disjunction { stmt_list } else_stmt .)
    }               reduce using rule 104 (if_stmt -> IF disjunction { stmt_list } else_stmt .)


state 351

    (105) else_stmt -> ELSE . if_stmt
    (106) else_stmt -> ELSE . { stmt_list }
    (104) if_stmt -> . IF disjunction { stmt_list } else_stmt

    {               shift and go to state 358
    IF              shift and go to state 210

    if_stmt                        shift and go to state 357

state 352

    (107) else_stmt -> epsilon .

    CONTINUE        reduce using rule 107 (else_stmt -> epsilon .)
    BREAK           reduce using rule 107 (else_stmt -> epsilon .)
    RETURN          reduce using rule 107 (else_stmt -> epsilon .)
    IF              reduce using rule 107 (else_stmt -> epsilon .)
    LOOP            reduce using rule 107 (else_stmt -> epsilon .)
    KEYS            reduce using rule 107 (else_stmt -> epsilon .)
    ID              reduce using rule 107 (else_stmt -> epsilon .)
    ORGANISM        reduce using rule 107 (else_stmt -> epsilon .)
    SIMULATION      reduce using rule 107 (else_stmt -> epsilon .)
    WORLD           reduce using rule 107 (else_stmt -> epsilon .)
    NUMBER          reduce using rule 107 (else_stmt -> epsilon .)
    STRING          reduce using rule 107 (else_stmt -> epsilon .)
    (               reduce using rule 107 (else_stmt -> epsilon .)
    [               reduce using rule 107 (else_stmt -> epsilon .)
    {               reduce using rule 107 (else_stmt -> epsilon .)
    NOT             reduce using rule 107 (else_stmt -> epsilon .)
    TRUE            reduce using rule 107 (else_stmt -> epsilon .)
    FALSE           reduce using rule 107 (else_stmt -> epsilon .)
    -               reduce using rule 107 (else_stmt -> epsilon .)
    }               reduce using rule 107 (else_stmt -> epsilon .)


state 353

    (103) index_stmt -> naming [ disjunction ] = disjunction .

    ;               reduce using rule 103 (index_stmt -> naming [ disjunction ] = disjunction .)


state 354

    (108) loop_stmt -> LOOP loop_init , loop_condition , loop_set . { stmt_list }

    {               shift and go to state 359


state 355

    (111) loop_set -> var_stmt .

    {               reduce using rule 111 (loop_set -> var_stmt .)


state 356

    (112) loop_set -> epsilon .

    {               reduce using rule 112 (loop_set -> epsilon .)


state 357

    (105) else_stmt -> ELSE if_stmt .

    CONTINUE        reduce using rule 105 (else_stmt -> ELSE if_stmt .)
    BREAK           reduce using rule 105 (else_stmt -> ELSE if_stmt .)
    RETURN          reduce using rule 105 (else_stmt -> ELSE if_stmt .)
    IF              reduce using rule 105 (else_stmt -> ELSE if_stmt .)
    LOOP            reduce using rule 105 (else_stmt -> ELSE if_stmt .)
    KEYS            reduce using rule 105 (else_stmt -> ELSE if_stmt .)
    ID              reduce using rule 105 (else_stmt -> ELSE if_stmt .)
    ORGANISM        reduce using rule 105 (else_stmt -> ELSE if_stmt .)
    SIMULATION      reduce using rule 105 (else_stmt -> ELSE if_stmt .)
    WORLD           reduce using rule 105 (else_stmt -> ELSE if_stmt .)
    NUMBER          reduce using rule 105 (else_stmt -> ELSE if_stmt .)
    STRING          reduce using rule 105 (else_stmt -> ELSE if_stmt .)
    (               reduce using rule 105 (else_stmt -> ELSE if_stmt .)
    [               reduce using rule 105 (else_stmt -> ELSE if_stmt .)
    {               reduce using rule 105 (else_stmt -> ELSE if_stmt .)
    NOT             reduce using rule 105 (else_stmt -> ELSE if_stmt .)
    TRUE            reduce using rule 105 (else_stmt -> ELSE if_stmt .)
    FALSE           reduce using rule 105 (else_stmt -> ELSE if_stmt .)
    -               reduce using rule 105 (else_stmt -> ELSE if_stmt .)
    }               reduce using rule 105 (else_stmt -> ELSE if_stmt .)


state 358

    (106) else_stmt -> ELSE { . stmt_list }
    (91) stmt_list -> . stmt stmt_list
    (92) stmt_list -> . epsilon
    (93) stmt -> . if_stmt
    (94) stmt -> . var_stmt ;
    (95) stmt -> . index_stmt ;
    (96) stmt -> . disjunction ;
    (97) stmt -> . loop_stmt
    (98) stmt -> . CONTINUE ;
    (99) stmt -> . BREAK ;
    (100) stmt -> . RETURN disjunction ;
    (101) stmt -> . RETURN ;
    (2) epsilon -> .
    (104) if_stmt -> . IF disjunction { stmt_list } else_stmt
    (102) var_stmt -> . accessing = disjunction
    (103) index_stmt -> . naming [ disjunction ] = disjunction
    (115) disjunction -> . conjunction OR conjunction
    (116) disjunction -> . conjunction
    (108) loop_stmt -> . LOOP loop_init , loop_condition , loop_set { stmt_list }
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (117) conjunction -> . negation AND negation
    (118) conjunction -> . negation
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (119) negation -> . NOT comparison
    (120) negation -> . comparison
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (121) comparison -> . expr EQ expr
    (122) comparison -> . expr NEQ expr
    (123) comparison -> . expr GE expr
    (124) comparison -> . expr LE expr
    (125) comparison -> . expr > expr
    (126) comparison -> . expr < expr
    (127) comparison -> . expr
    (128) expr -> . expr + term
    (129) expr -> . expr - term
    (130) expr -> . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming

    CONTINUE        shift and go to state 207
    BREAK           shift and go to state 208
    RETURN          shift and go to state 209
    }               reduce using rule 2 (epsilon -> .)
    IF              shift and go to state 210
    LOOP            shift and go to state 215
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    NOT             shift and go to state 228
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    -               shift and go to state 231

    stmt_list                      shift and go to state 360
    stmt                           shift and go to state 200
    epsilon                        shift and go to state 201
    if_stmt                        shift and go to state 202
    var_stmt                       shift and go to state 203
    index_stmt                     shift and go to state 204
    disjunction                    shift and go to state 205
    loop_stmt                      shift and go to state 206
    accessing                      shift and go to state 211
    naming                         shift and go to state 212
    conjunction                    shift and go to state 214
    word                           shift and go to state 216
    atom                           shift and go to state 220
    negation                       shift and go to state 221
    bool                           shift and go to state 226
    expr                           shift and go to state 227
    comparison                     shift and go to state 229
    term                           shift and go to state 230
    factor                         shift and go to state 232
    power                          shift and go to state 233

state 359

    (108) loop_stmt -> LOOP loop_init , loop_condition , loop_set { . stmt_list }
    (91) stmt_list -> . stmt stmt_list
    (92) stmt_list -> . epsilon
    (93) stmt -> . if_stmt
    (94) stmt -> . var_stmt ;
    (95) stmt -> . index_stmt ;
    (96) stmt -> . disjunction ;
    (97) stmt -> . loop_stmt
    (98) stmt -> . CONTINUE ;
    (99) stmt -> . BREAK ;
    (100) stmt -> . RETURN disjunction ;
    (101) stmt -> . RETURN ;
    (2) epsilon -> .
    (104) if_stmt -> . IF disjunction { stmt_list } else_stmt
    (102) var_stmt -> . accessing = disjunction
    (103) index_stmt -> . naming [ disjunction ] = disjunction
    (115) disjunction -> . conjunction OR conjunction
    (116) disjunction -> . conjunction
    (108) loop_stmt -> . LOOP loop_init , loop_condition , loop_set { stmt_list }
    (152) accessing -> . word
    (153) accessing -> . word . accessing
    (141) naming -> . naming [ disjunction ]
    (142) naming -> . accessing
    (143) naming -> . KEYS ( naming )
    (144) naming -> . ID ( arg_list )
    (145) naming -> . atom
    (117) conjunction -> . negation AND negation
    (118) conjunction -> . negation
    (154) word -> . ID
    (155) word -> . ORGANISM
    (156) word -> . SIMULATION
    (157) word -> . WORLD
    (146) atom -> . NUMBER
    (147) atom -> . STRING
    (148) atom -> . bool
    (149) atom -> . ( expr )
    (150) atom -> . [ arg_list ]
    (151) atom -> . { keyarg_list }
    (119) negation -> . NOT comparison
    (120) negation -> . comparison
    (158) bool -> . TRUE
    (159) bool -> . FALSE
    (121) comparison -> . expr EQ expr
    (122) comparison -> . expr NEQ expr
    (123) comparison -> . expr GE expr
    (124) comparison -> . expr LE expr
    (125) comparison -> . expr > expr
    (126) comparison -> . expr < expr
    (127) comparison -> . expr
    (128) expr -> . expr + term
    (129) expr -> . expr - term
    (130) expr -> . term
    (131) term -> . term * factor
    (132) term -> . term / factor
    (133) term -> . term % factor
    (134) term -> . term INTDIV factor
    (135) term -> . factor
    (136) factor -> . - factor
    (137) factor -> . power
    (138) power -> . atom ^ factor
    (139) power -> . atom @ factor
    (140) power -> . naming

    CONTINUE        shift and go to state 207
    BREAK           shift and go to state 208
    RETURN          shift and go to state 209
    }               reduce using rule 2 (epsilon -> .)
    IF              shift and go to state 210
    LOOP            shift and go to state 215
    KEYS            shift and go to state 217
    ID              shift and go to state 219
    ORGANISM        shift and go to state 222
    SIMULATION      shift and go to state 197
    WORLD           shift and go to state 223
    NUMBER          shift and go to state 224
    STRING          shift and go to state 225
    (               shift and go to state 218
    [               shift and go to state 213
    {               shift and go to state 198
    NOT             shift and go to state 228
    TRUE            shift and go to state 102
    FALSE           shift and go to state 103
    -               shift and go to state 231

    stmt_list                      shift and go to state 361
    stmt                           shift and go to state 200
    epsilon                        shift and go to state 201
    if_stmt                        shift and go to state 202
    var_stmt                       shift and go to state 203
    index_stmt                     shift and go to state 204
    disjunction                    shift and go to state 205
    loop_stmt                      shift and go to state 206
    accessing                      shift and go to state 211
    naming                         shift and go to state 212
    conjunction                    shift and go to state 214
    word                           shift and go to state 216
    atom                           shift and go to state 220
    negation                       shift and go to state 221
    bool                           shift and go to state 226
    expr                           shift and go to state 227
    comparison                     shift and go to state 229
    term                           shift and go to state 230
    factor                         shift and go to state 232
    power                          shift and go to state 233

state 360

    (106) else_stmt -> ELSE { stmt_list . }

    }               shift and go to state 362


state 361

    (108) loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list . }

    }               shift and go to state 363


state 362

    (106) else_stmt -> ELSE { stmt_list } .

    CONTINUE        reduce using rule 106 (else_stmt -> ELSE { stmt_list } .)
    BREAK           reduce using rule 106 (else_stmt -> ELSE { stmt_list } .)
    RETURN          reduce using rule 106 (else_stmt -> ELSE { stmt_list } .)
    IF              reduce using rule 106 (else_stmt -> ELSE { stmt_list } .)
    LOOP            reduce using rule 106 (else_stmt -> ELSE { stmt_list } .)
    KEYS            reduce using rule 106 (else_stmt -> ELSE { stmt_list } .)
    ID              reduce using rule 106 (else_stmt -> ELSE { stmt_list } .)
    ORGANISM        reduce using rule 106 (else_stmt -> ELSE { stmt_list } .)
    SIMULATION      reduce using rule 106 (else_stmt -> ELSE { stmt_list } .)
    WORLD           reduce using rule 106 (else_stmt -> ELSE { stmt_list } .)
    NUMBER          reduce using rule 106 (else_stmt -> ELSE { stmt_list } .)
    STRING          reduce using rule 106 (else_stmt -> ELSE { stmt_list } .)
    (               reduce using rule 106 (else_stmt -> ELSE { stmt_list } .)
    [               reduce using rule 106 (else_stmt -> ELSE { stmt_list } .)
    {               reduce using rule 106 (else_stmt -> ELSE { stmt_list } .)
    NOT             reduce using rule 106 (else_stmt -> ELSE { stmt_list } .)
    TRUE            reduce using rule 106 (else_stmt -> ELSE { stmt_list } .)
    FALSE           reduce using rule 106 (else_stmt -> ELSE { stmt_list } .)
    -               reduce using rule 106 (else_stmt -> ELSE { stmt_list } .)
    }               reduce using rule 106 (else_stmt -> ELSE { stmt_list } .)


state 363

    (108) loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .

    CONTINUE        reduce using rule 108 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    BREAK           reduce using rule 108 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    RETURN          reduce using rule 108 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    IF              reduce using rule 108 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    LOOP            reduce using rule 108 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    KEYS            reduce using rule 108 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    ID              reduce using rule 108 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    ORGANISM        reduce using rule 108 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    SIMULATION      reduce using rule 108 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    WORLD           reduce using rule 108 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    NUMBER          reduce using rule 108 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    STRING          reduce using rule 108 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    (               reduce using rule 108 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    [               reduce using rule 108 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    {               reduce using rule 108 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    NOT             reduce using rule 108 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    TRUE            reduce using rule 108 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    FALSE           reduce using rule 108 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    -               reduce using rule 108 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)
    }               reduce using rule 108 (loop_stmt -> LOOP loop_init , loop_condition , loop_set { stmt_list } .)

